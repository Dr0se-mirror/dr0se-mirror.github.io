[{"id":"190a5681495c8fcf46bf22c2590b534f","title":"代码审计漫谈","content":"前言因为自己想做一个代码审计工具，自己之前是有做过一点点代码审计的。审计过熊海，bluecms等等简单的一些cms。但是对其中的很多深层次原理都不了解。甚至可以说一点点都不懂，毕竟从用一个工具到做一个工具就是有本质上的区别。\n于我而言，做一个工具肯定是有很大的提升的。对于这个工具的构想，其实目标很简单，是想做出一款可以有多语言的，简洁的，几乎没有误报和漏报的一款简洁的代码审计工具(注意是几乎)。当然这个是很困难的QAQ。\n然后在写了一版申报书之后，发现自己想的太多了。这样一个大的项目以我本科生的水平几乎就是不可能完成的。所以呀，饭还是得一口一口吃。\n\n\n根据老师的一些建议，现在想的是如何从一个小的点上有所突破，做一个小而精的工具。我想这是我可以做到的\n一些概念其实一个好用的工具，最简单的标准就是自动化。不要当每一个人都是技术大牛，就算是技术大牛，有简单的工具我相信也没有人会去用复杂的工具\n所以自动化一定是最基础的要求点\n那怎么做到自动化，要有两个词的概念理解\n1.漏报率没有发现的bug\n2.误报率发现了错误的bug\n自动化代码审计工具正常来说都是我们给他一段代码，他给我们审计结果。这个结果中，里面这两个点就是绕不过的点。其实我之前的想法，什么深度学习，什么语法规则等等巴拉巴拉的东西，都是想为这两个点去服务。\n我们从深层原理去看看，为什么会出现这两个问题，也就是市面上的软件为什么也一直解决不了这个问题\n我们简单的把代码审计工具分为两类一类是动态的代码审计工具，一类是静态的代码审计工具\n动态代码审计工具这种工具基于代码运行的过程中处理挖掘漏洞一般称为IAST（interactive Application Security Testing）\n里面一般包含两个技术点\n1.hook在软件开发中，Hook是指在程序运行时，通过修改函数调用表（或者函数指针）的方法，使得程序在执行特定函数时，会先执行Hook函数，从而可以监控、修改或者替换原有函数的行为。在安全领域，攻击者可以使用Hook技术，将恶意代码注入到受攻击程序的运行过程中，从而获取敏感信息或者控制程序行为。\n2.前端爬虫在前端爬虫中，爬虫程序会模拟浏览器行为，对目标网站进行访问，并收集需要的数据。恶意攻击者可以使用Hook技术，监控网页中的某些函数调用。\n这里附上一张流程图\n\n\n我们通过前端爬虫模仿浏览器访问，同时使用hook，修改程序的执行流，如果如果Hook函数被触发，并满足某种条件，那么我们认为该漏洞存在。\n这类扫描工具的优势在于，通过这类工具发现的漏洞误报率比较低，且不依赖代码，一般来说，只要策略足够完善，能够触发到相应恶意函数的操作都会相应的满足某种恶意操作。而且可以跟踪动态调用也是这种方法最主要的优势之一。\n但是也有缺点\n(1) 前端Fuzz爬虫可以保证对正常功能的覆盖率，却很难保证对代码功能的覆盖率。如果曾使用动态代码审计工具对大量的代码扫描，不难发现，这类工具针对漏洞的扫描结果并不会比纯黑盒的漏洞扫描工具有什么优势，其中最大的问题主要集中在功能的覆盖度上。\n一般来说一个项目的代码是会有冗余的。也有很多开发人员也没想到的东西。有太多的代码不会从功能处发现，这样的检测就会有很高漏报率。\n(2) 动态代码审计对底层以及hook策略依赖较强，这里有很多问题。比如我们如果想要依赖IAST来做代码审计工具，我们的核心点就是要设计很多很多的hook方案，但是如果hook的深度不够，我们也不能执行我们的恶意代码，不能判断这里有漏洞。（漏报）还有也不是触发了恶意函数就可以判断有漏洞，比如有一个echo可以执行，不能直接判断为xss。同时由于需要运行，环境，执行效率等等都是很大很大的问题，这样也只能审计单一语言。多语言几乎是海量的工作量，所以现在的代码审计工具基本已经很少完全使用IAST了\n静态代码审计工具静态代码审计主要是通过分析目标代码，通过纯静态的手段进行分析处理，并挖掘相应的漏洞&#x2F;Bug.\n其实就是简单的人工读代码变成了机器读代码\n最基础的东西，也是最早或者说是最容易想到的方法\n正则匹配\n\n\n虽然我们匹配到了这个简单的漏洞，但是很快发现，事情并没有那么简单。\n\n\n但是这样永远没有尽头，你说用正则过滤过滤输入还是有用的，但是我们要去匹配代码，不可能完全覆盖，你永远不知道一些牛鬼蛇神怎么写代码\n于是有两种思路\n1.高覆盖性这类工具最经典的就是Seay，通过简单的关键字来匹配经可能多的目标，之后使用者可以通过人工审计的方式进一步确认。\n\\beval\\b\\(\n\n2.高可用性这类工具最经典的是Rips免费版\n\\beval\\b\\(\\$_(GET|POST)\n\n用更多的正则来约束，用更多的规则来覆盖多种情况。这也是早期静态自动化代码审计工具普遍的实现方法。\n但问题显而易见，高覆盖性和高可用性是这种实现方法永远无法解决的硬伤，不但维护成本巨大，而且误报率和漏报率也是居高不下。所以被时代所淘汰也是历史的必然。\n但是现在seay和rips依旧是主流软件，有人可能会问为什么，因为要其他钱啊！（开玩笑）\n再牛逼一点点AST!!!\nAST（Abstract Syntax Tree，抽象语法树）是一种用于表示程序源代码语法结构的树状数据结构。在编译器、解释器等程序分析工具中，AST通常是从源代码中生成的一种中间表示形式，用于对程序进行分析、优化、转换等操作。\nAST通常由一系列节点组成，每个节点表示源代码中的一个语法结构，例如函数、变量声明、表达式、控制流语句等。节点之间通过父子关系组织成一棵树，每个节点包含了语法结构的信息，例如标识符、运算符、字面量等。\nAST可以被用于各种程序分析和转换任务中，例如语法检查、编译优化、代码重构、程序理解和分析等。在编译器中，AST通常是编译过程中的一个重要中间表示形式，被用于生成目标代码。在静态分析工具中，AST可以被用于检查和修复代码中的各种问题，例如潜在的安全漏洞、性能瓶颈、代码风格问题等。\nAST在许多编程语言的编译器和解释器中都得到了广泛的应用，以下是一些使用AST的编程语言：\n\nC&#x2F;C++：GCC、Clang等编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\nJava：Java编译器使用AST作为中间表示形式，用于语法检查、编译优化和代码生成。\nPython：Python解释器和静态分析工具使用AST进行代码检查、代码重构和性能优化。\nJavaScript：JavaScript解释器和编译器使用AST进行代码分析、优化和转换。\nRuby：Ruby解释器和编译器使用AST进行代码分析、优化和转换。\nGo：Go编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\n\n除此之外，许多其他编程语言的编译器和解释器也采用了AST作为中间表示形式，以便于对程序进行分析和优化。\n看完这个概念大家有没有什么想法？再直观一点\n以php为例\n\n\n没错，我们只需要在AST上做文章，有了统一的AST语法树，上面的问题迎刃而解\n现在如何对AST语法树做分析也就成了我们这个工具最大的问题\n在理解如何分析AST语法树之前，我们首先要明白information flow、source、sink三个概念，\n\nsource： 我们可以简单的称之为输入，也就是information flow的起点\nsink： 我们可以称之为输出，也就是information flow的终点\n\n而information flow，则是指数据在source到sink之间流动的过程。\n也就是信息流分析\n把这个概念放在PHP代码审计过程中，Source就是指用户可控的输入，比如$_GET、$_POST等，而Sink就是指我们要找到的敏感函数，比如echo、eval，如果某一个Source到Sink存在一个完整的流，那么我们就可以认为存在一个可控的漏洞，这也就是基于information flow的代码审计原理。\n举个例子：\n\n\n\n\n这么一段代码生成的AST是什么捏\n\n\n也很简单\n在上面的分析过程中，Sink就是eval函数，source就是$_GET，通过逆向分析Sink的来源，我们成功找到了一条流向Sink的information flow，也就成功发现了这个漏洞。\n\n\n\n\n在分析information flow中明确作用域是基础中的基础\n如果我们只关注左值和右值的回溯\n\n\n我们会得到这样的结果\n但是这里有个get函数\n\n\n这样才是正确的流程\n所以我们的分析过程中作用域很重要\n在这段代码中，从主语法树的作用域跟到Get函数的作用域，如何控制这个作用域的变动，就是基于AST语法树分析的一大难点，当我们在代码中不可避免的使用递归来控制作用域时，在多层递归中的统一标准也就成了分析的基础核心问题。\n可是！\n\n\n还是有问题\n\n\n这样一段代码\n我们怎么分析\n应该说机器怎么分析\n逆向分析可以解决这个代码\n\n\n看到这里的分析，我们新建了一个规则作用于一个作用域。越来越复杂了。\n可能到现在你觉得我讲的有点懵、\n就是我们需要发现危险函数，但是AST的作用域就是程序的作用域，我们一但跳出一个函数就要建立新的规则，也就是说，每来一个作用域，我们都要新建立规则\n很复杂了吧，但是可以解决\n但是来个简单的\n\n\n这几乎是一个没有漏洞的代码，因为被过滤了\n但是AST不行\n这是一个典型的全局过滤，人工审计可以很容易看出这里被过滤了。但是如果在自动化分析过程中，当回溯到Source为$_GET[&#39;a&#39;]时，已经满足了从Source到sink的information flow。已经被识别为漏洞。一个典型的误报就出现了。\n而基于AST的自动化代码审计工具也正是在与这样的问题做博弈，从PHP自动化代码审计中比较知名的Rips、Cobra\n都是在不同的方式方法上，优化information flow分析的结果，而最大的区别则是离不开的高可用性、高覆盖性两点核心\n对于基于AST的代码分析来说，最大的挑战在于没人能保证自己完美的处理所有的AST结构，再加上基于单向流的分析方式，无法应对100%的场景，这也正是这类工具面临的问题（或者说，这也就是为什么选择逆向的原因）。\n所以呀，逆向很重要\nemmmm看来到目前也没有很好的解决方法\n还有基于IR&#x2F;CFG的分析AST是一个中间树，还有别的吗，答案是肯定的\nAST是编译原理中IR&#x2F;CFG的更上层\n也就是说，分析AST更接近分析代码，换句话就是说基于AST的分析得到的流，更接近脑子里对代码执行里的流程，忽略了大多数的分支、跳转、循环这类影响执行过程顺序的条件，这也是基于AST的代码分析的普遍解决方案，当然，从结果论上很难辨别忽略带来的后果。所以基于IR&#x2F;CFG这类带有控制流的解决方案，是现在更主流的代码分析方案，但不是唯一。\n什么是IR&#x2F;CFGIR（Intermediate Representation，中间表示）是一种高级语言和机器语言之间的抽象表示形式，通常是一种低级别的、机器无关的表示形式。IR可以作为编译器的一个重要中间表示形式，用于在源代码和目标代码之间进行转换和优化。IR通常是一种树状结构，包含了程序的控制流、数据流和操作等信息。\nCFG（Control Flow Graph，控制流图）是一种用于表示程序控制流的图形表示形式。CFG通过将程序的各个基本块（basic block）抽象为节点，将基本块之间的控制流关系抽象为有向边，从而形成一个图形结构。CFG可以用于描述程序的控制流结构，帮助程序员理解程序的执行过程，并在编译器中用于代码优化和转换。\n一般来说，我们需要遍历IR来生成CFG，其中需要按照一定的规则.当然，也可以用AST来生成CFG，毕竟AST是比较高的层级。\n而基于CFG的代码分析思路优势在于，对于一份代码来说，你首先有了一份控制流图（或者说是执行顺序），然后才到漏洞挖掘这一步。比起基于AST的代码分析来说，你只需要专注于从Source到Sink的过程即可。\n挑战的核心仍然维持在如何控制流，维持作用域，处理程序逻辑的分支过程，确认Source与Sink。\n理所当然的是，既然存在基于AST的代码分析，又存在基于CFG的代码分析，自然也存在其他的种类。比如现在市场上主流的fortify，Checkmarx，Coverity包括最新的Rips都使用了自己构造的语言的某一个中间部分，比如fortify和Coverity就需要对源码编译的某一个中间语言进行分析。前段时间被阿里收购的源伞甚至实现了多种语言生成统一的IR，这样一来对于新语言的扫描支持难度就变得大大减少了。\n新东西QLAST,CFG等其实本质上还是对于数据流的分析\n而QL就是把这个流的每一个环节具象化，把每个节点的操作具像成状态的变化，并且储存到数据库中。这样一来，通过构造QL语言，我们就能找到满足条件的节点，并构造成流。下面我举一个简单的例子来说：\n&lt;?php\n\n$a &#x3D; $_GET[&#39;a&#39;];\n$b &#x3D; htmlspecialchars($a);\n\necho $b;\n\n我们简单的把前面的流写成一个表达式\necho &#x3D;&gt; $_GET.is_filterxss\n\n这里is_filterxss被认为是输入$_GET的一个标记，在分析这类漏洞的时候，我们就可以直接用QL表达\nselect * where &#123;\n    Source : $_GET,\n    Sink : echo,\n    is_filterxss : False,\n&#125;\n\n我们就可以找到这个漏洞（上面的代码仅为伪代码），从这样的一个例子我们不难发现，QL其实更接近一个概念，他鼓励将信息流具象化，这样我们就可以用更通用的方式去写规则筛选。\n也就是更加的简单和方便\n也正是建立在这个基础上，CodeQL诞生了，它更像是一个基础平台，让你不需要在操心底层逻辑，使用AST还是CFG又或是某种平台，你可以将自动化代码分析简化约束为我们需要用怎么样的规则来找到满足某个漏洞的特征。这个概念也正是现代代码分析主流的实现思路，也就是将需求转嫁到更上层。\n参考文献：https://paper.seebug.org/1339/#_1\n","slug":"代码审计漫谈","date":"2023-05-05T10:30:49.000Z","categories_index":"代码审计","tags_index":"代码审计","author_index":"Dr0se"},{"id":"93ccd316627eee66752597ff33d20c8e","title":"HNCTF 2022 week1 Writeup","content":"[HNCTF 2022 Week1]easy_html\n\n看看cookie\n\n\n\n\n有个框框，来我们猜猜是什么?xss ,ssti,sql?\n\n\n但是我发现这里好像只有10个位置，我的思路第一时间想到1到9999999999爆破。经过我的不断尝试，发现，我是呆逼\n手机号怎么可能只有10位呢。\n\n\n随便修改前端为超过10的数，然后输入10个以上的数就ok了\n亏得我电脑风扇还飞了起来\n\n\n[HNCTF 2022 Week1]Interesting_include\n\n读题就是过滤了大小写flag\n这种直接用过滤器，因为正则匹配都是匹配字符，而过滤器传递的是路径当攻击者使用php://filter/read=convert.base64-encode/resource=flag.php作为filter参数时，PHP解析器会将这个参数作为一个文件路径，传递给include函数。因为这个参数不是一个标准的文件路径，而是一个流过滤器，因此在执行include函数时，会先对这个参数进行处理，将flag.php文件的内容转换为base64编码，再输出到标准输出流中。\n\n\n[HNCTF 2022 Week1]easy_upload基础中的基础，直接改后缀名为php，蚁剑连接根目录一看就有了\n[HNCTF 2022 Week1]Interesting_http一开始叫我们post一个want\n按他说的做\n\n\n然后想要啥flag\n\n\n肯定没那么简单\n这种不是管理员一般看看cookie\n\n\n改改\n\n\nxff改改\n\n\n[HNCTF 2022 Week1]Challenge__rce\n\n传个hint试试\n\n\n一眼顶真\n\n\n无字符rce\n一直有接触但是没有系统学习，这里来一波。\n\n\n参考：https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;8107\n\n最简单的无字符过滤\n&lt;?php\nif(!preg_match(&#39;&#x2F;[a-z0-9]&#x2F;is&#39;,$_GET[&#39;shell&#39;])) &#123;\n  eval($_GET[&#39;shell&#39;]);\n&#125;\n\n研究这段代码的绕过\n我们先从异或看起\n\n\n输出是’o’，我们来分析下原因,5的ASCII码是53,转成二进制是00110101,Z的ASCII码是90,转成二进制是01011010,将他们进行异或,为,也即十进制的111,为o\n\n\n再学习一下这段代码\n刚刚讲过’5’^’Z’为’o’\n这样我们就将$__赋值为’o’然后php允许把字符串当函数用。这样我们就成功的调用了o()这个函数\n$_是一个没有定义过的变量，php会给他赋一个默认值NULL&#x3D;&#x3D;0\n那么这个1就不难理解了\n","slug":"HNCTF2022Week1部分wp","date":"2023-05-04T17:13:22.000Z","categories_index":"writeups","tags_index":"html,无字符rce,文件上传,文件包含,cookie","author_index":"Dr0se"}]